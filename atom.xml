<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://muouren7.github.io</id>
    <title>muouren7のBlog</title>
    <updated>2022-10-16T06:52:13.761Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://muouren7.github.io"/>
    <link rel="self" href="https://muouren7.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://muouren7.github.io/images/avatar.png</logo>
    <icon>https://muouren7.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, muouren7のBlog</rights>
    <entry>
        <title type="html"><![CDATA[Vue项目页面上方有空白]]></title>
        <id>https://muouren7.github.io/post/vue-xiang-mu-ye-mian-shang-fang-you-kong-bai/</id>
        <link href="https://muouren7.github.io/post/vue-xiang-mu-ye-mian-shang-fang-you-kong-bai/">
        </link>
        <updated>2022-10-14T08:11:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vue项目页面上方有空白解决方案">Vue项目页面上方有空白（解决方案）</h1>
<h2 id="问题">问题</h2>
<p>新建的vue项目，里面的每个页面中，上方都有几像素的空白<br>
<img src="https://raw.githubusercontent.com/muouren7/PIC/master/img/202209150953701.png" alt="解决前" loading="lazy"></p>
<h2 id="解决">解决</h2>
<p>在vue项目下的App.vue中，样式表的顶部外边距默认是60像素,会将页面的body元素与html隔开,将样式表的顶部外边距改位0px即可</p>
<pre><code class="language-css">#app {
  margin-top: 60px;
}
</code></pre>
<p><img src="https://raw.githubusercontent.com/muouren7/PIC/master/img/202209150956088.png" alt="解决后" loading="lazy"><br>
改了之后就没有空白了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言程序设计（一）]]></title>
        <id>https://muouren7.github.io/post/C语言（一）/</id>
        <link href="https://muouren7.github.io/post/C语言（一）/">
        </link>
        <updated>2022-10-14T08:06:38.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rcjsrnpyj21g40i642g.jpg" alt="image-20220531094944782" loading="lazy"></figure>
<p>**温馨提示：**所有的笔记（需要使用Typora软件打开）在视频下方简介中直接获取，纯个人录制，不用加什么公众号这些，各位小伙伴直接网盘自取吧。</p>
<h1 id="计算机思维导论">计算机思维导论</h1>
<p>计算机自1946年问世以来，几乎改变了整个世界。</p>
<p>现在我们可以通过电脑来做很多事情，比如我们常常听到的什么人工智能、电子竞技、大数据等等，都和计算机息息相关，包括我们现在的手机、平板等智能设备，也是计算机转变而来的。各位可以看看最顶上的这张图片，如果你在小时候接触过计算机，那么一定对这张图片（照片拍摄于1996年，在美国加利福尼亚州加利福尼亚州的锁诺玛县）印象深刻，这张壁纸作为WindowsXP系统的默认壁纸，曾经展示在千家万户的电脑屏幕上。</p>
<p>也许你没有接触过计算机，也许你唯一接触计算机就是用来打游戏，也有可能你曾经捣鼓过计算机，在学习C语言之前，先让我们来了解一下计算机的世界。</p>
<h2 id="计算机的世界">计算机的世界</h2>
<p>计算机虽然名字听着很高级，不过它也是由一个个简单电路组成的。</p>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rd1x1rtgj21dy0cw74r.jpg" alt="image-20220531100709841" loading="lazy"></figure>
<p>这是我们在初中就学习过的电路图，不过这种电路太过简单，只能完成一些很基础的的操作，比如点亮小灯泡等。</p>
<p>很明显想要实现计算机怎么高级的运算机器，肯定是做不到的，这时我们就需要引入更加强大的数字电路了。</p>
<blockquote>
<p>用数字信号完成对数字量进行<a href="https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97/3118202">算术运算</a>和<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/7224729">逻辑运算</a>的电路称为数字电路，或数字系统。由于它具有逻辑运算和逻辑处理功能，所以又称数字逻辑电路。现代的数字电路由半导体工艺制成的若干数字集成器件构造而成。逻辑门是数字逻辑电路的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83/5246264">基本单元</a>。</p>
<p>计算机专业一般会在大一开放《数字电路》这门课程，会对计算机底层的数字电路实现原理进行详细介绍。</p>
</blockquote>
<p>数字电路引入了逻辑判断，我们来看看简单的数字电路：</p>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rdj1916aj21iq0dygm4.jpg" alt="image-20220531102337270" loading="lazy"></figure>
<p>数字电路中，用电压的高低来区分出两种信号，低电压表示0，高电压表示1，由于只能通过这种方式表示出两种类型的信号，所以计算机采用的是二进制。</p>
<blockquote>
<p><a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457">二进制</a>是计算技术中广泛采用的一种<a href="https://baike.baidu.com/item/%E6%95%B0%E5%88%B6/217113">数制</a>。二进制数据是用0和1两个数码来表示的数。它的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0/4260">基数</a>为2，进位规则是“逢二进一”，借位规则是“借一当二”。</p>
<p>比如我们一般采用的都是十进制表示，比如9再继续加1的话，就需要进位了，变成10，在二进制中，因为只有0和1，所以当1继续加1时，就需要进位了，就变成10了（注意这不是十，读成一零就行了）</p>
</blockquote>
<p>当然，仅仅有两种信号还不够，我们还需要逻辑门来辅助我们完成更多的计算，最基本的逻辑关系是与、或、非，而逻辑门就有相应的是<a href="https://baike.baidu.com/item/%E4%B8%8E%E9%97%A8">与门</a>、<a href="https://baike.baidu.com/item/%E6%88%96%E9%97%A8">或门</a>和<a href="https://baike.baidu.com/item/%E9%9D%9E%E9%97%A8">非门</a>，可以用电阻、电容、二极管、三极管等分立原件构成（具体咋构成的咱这里就不说了）</p>
<p>比如与操作，因为只有两种类型，我们一般将1表示为真，0表示为假，与操作（用&amp;表示）要求两个数参与进来，比如：</p>
<ul>
<li>1 &amp; 1 = 1    必须两边都是真，结果才为真。</li>
<li>1 &amp; 0 = 0    两边任意一个或者都不是真，结果为假。</li>
</ul>
<p>或运算（用 | 表示）：</p>
<ul>
<li>1 | 0 = 1    两边只要有一个为真，结果就为真</li>
<li>0 | 0 = 0    两边同时为假，结果才是假</li>
</ul>
<p>非运算实际上就是取反操作（可以是 ! 表示）</p>
<ul>
<li>!1 = 0</li>
<li>!0 = 1     非运算会将真变成假，假变成真</li>
</ul>
<p>有了这些运算之后，我们的电路不仅仅可以实现计算，也可以实现各种各样的逻辑判断，最终才能发展成我们的计算机。</p>
<p>前面我们大概介绍一下计算机的底层操作原理，接着我们来看看计算机的基本组成。</p>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2reca0cgoj20x60b40uu.jpg" alt="image-20220531105143154" loading="lazy"></figure>
<p>相信各位熟知的计算机都是一个屏幕+一个主机的形式，然后配上我们的键盘鼠标，就可以开始使用了，但是实际上标准的计算机结构并没有这么简单，我们来看看：</p>
<figure data-type="image" tabindex="5"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2reersjdmj21k20fqdhl.jpg" alt="image-20220531105407595" loading="lazy"></figure>
<p>我们电脑最核心的部件，当属CPU，因为几乎所有的运算都是依靠CPU进行（各种各样的计算电路已经在CPU中安排好了，我们只需要发送对应的指令就可以进行对应的运算），它就像我们人的大脑一样，有了大脑才能进行思考。不过光有大脑还不行，还要有一些其他的部分来辅助工作，比如我们想向电脑里面打字，那么就需要连接一个键盘才能输入，我们想要点击桌面上的图标，那么就需要一个鼠标来操作光标，这些都是输入设备。我们的电脑开机之后显示器上会显示出画面，实际上显示器就是输出设备。</p>
<p>当然除了这些内容之外，我们的电脑还需要内存来保存运行时的一些数据，以及外存来保存文件（比如硬盘）等。我们常说的iPhone13 512G，这个512G并不是指的内存，而是指的外存，准确的说是用于存放文件硬盘大小，而真正的内存是我们常说的4G/6G/8G运行内存，内存的速度远高于外存的速度，所以1G内存的价格远超1G硬盘的价格。</p>
<figure data-type="image" tabindex="6"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2riw9u06uj21bs0b4jso.jpg" alt="image-20220531132920027" loading="lazy"></figure>
<p>计算机包括五大部件：运算器、控制器、存储器、输入和输出设备。有了这一套完整的硬件环境，我们的电脑才算是有了一个完整的身体。</p>
<p>**问题：**我们上面提到的这些硬件设备哪些是属于外设？</p>
<h2 id="操作系统概述">操作系统概述</h2>
<p>前面我们了解了一下计算机的大致原理和组成结构，但是光有这一套硬件可不行，如何让这一套硬件按照我们想要的方式运作起来，也是非常重要的，这时我们就需要介绍操作系统了。</p>
<blockquote>
<p>操作系统（operating system，简称OS）是管理<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/5459592">计算机硬件</a>与<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6/12053">软件</a>资源的<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F/3220205">计算机程序</a>。操作系统需要处理如管理与<a href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE/2394679">配置</a><a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98/103614">内存</a>、决定<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/974435">系统资源</a>供需的优先次序、控制<a href="https://baike.baidu.com/item/%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87/10823368">输入设备</a>与<a href="https://baike.baidu.com/item/%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/10823333">输出设备</a>、操作网络与管理<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/4827215">文件系统</a>等基本事务。操作系统也提供一个让用户与系统<a href="https://baike.baidu.com/item/%E4%BA%A4%E4%BA%92/6964417">交互</a>操作的界面。</p>
<p>一般在计算机专业大二，会开放《操作系统》课程，会详细讲解操作系统的底层运作机制和调度。</p>
</blockquote>
<p>一般我们电脑上都安装了Windows操作系统（苹果笔记本安装的是MacOS操作系统），现在主流的电脑都已经预装Windows11了：</p>
<figure data-type="image" tabindex="7"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rjnis7lkj21ew0e041a.jpg" alt="image-20220531135531352" loading="lazy"></figure>
<p>有了操作系统，我们的电脑才能真正运行起来，我们就可以轻松地通过键盘和鼠标来操作电脑了。</p>
<p>不过操作系统最开始并不是图形化界面，它类似于Windows中的命令提示符：</p>
<figure data-type="image" tabindex="8"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rkezow9dj21v60ew40f.jpg" alt="image-20220531142155616" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rkjitqqnj21kc08475e.jpg" alt="image-20220531142617124" loading="lazy"></figure>
<p>没有什么图标这些概念，只有一个简简单单的黑框让我们进行操作，通过输入命令来进行一些简单的使用，程序的运行结果也会在黑框框（命令行）中打印出来，不过虽然仅仅是一个黑框，但是能运行的程序可是非常非常多的，只需要运行我们编写好的程序，就能完成各种各样复杂的计算任务，并且计算机的计算速度远超我们的人脑。</p>
<blockquote>
<p>中国超级计算机系统天河二号，计算速度达到每秒5.49亿亿次。</p>
</blockquote>
<p>当然，除了我们常见的Windows和MacOS系统之外，还有我们以后需要经常打交道的Linux操作系统，这种操作系统是开源的，意思是所有的人都可以拿到源代码进行修改，于是就出现了很多发行版：</p>
<figure data-type="image" tabindex="10"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rkm3bo7sj21gk0b4dh3.jpg" alt="image-20220531142844465" loading="lazy"></figure>
<p>这些发行版有带图形化界面的，也有不带图形化界面的，不带图形化界面的Linux将是我们以后学习的重点。</p>
<p>不同操作系统之间的软件并不是通用的，比如Windows下我们的软件一般是.exe后缀名称，而MacOS下则不是，并且也无法直接运行.exe文件，这是因为不同操作系统的具体实现会存在一些不同，程序编译（我们之后会介绍到）之后的格式也会不同，所以是无法做到软件通用的。</p>
<p>正是因为有了操作系统，才能够组织我们计算机的底层硬件（包括CPU、内存、输入输出设备等）进行有序工作，没有操作系统电脑就如同一堆废铁，只有躯壳没有灵魂。</p>
<h2 id="计算机编程语言">计算机编程语言</h2>
<p>现在我们大致了解了我们的电脑的运作原理，实际上是一套完整的硬件+一个成形的操作系统共同存在的。接着我们就可以开始了解一下计算机的编程语言了。我们前面介绍的操作系统也是由编程语言写出来的，操作系统本身也算是一个软件。</p>
<figure data-type="image" tabindex="11"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rl228014j21eq0a2gnf.jpg" alt="image-20220531144405958" loading="lazy"></figure>
<p>那么操作系统是如何让底层硬件进行工作的呢？实际上就是通过向CPU发送指令来完成的。</p>
<blockquote>
<p>计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。而指令集的先进与否，也关系到CPU的性能发挥，它也是CPU性能体现的一个重要标志。</p>
</blockquote>
<p>我们电脑中的CPU有多种多样的，不同的CPU之间可能也会存在不同的架构，比如现在最常用的是x86架构，还有我们手机平板这样的移动设备使用的arm架构，不同的架构指令集也会有不同。</p>
<p>我们知道，计算机底层硬件都是采用的0和1这样的二进制表示，所以指令也是一样的，比如（这里随便写的）：</p>
<ul>
<li>000001  -  代表开机</li>
<li>000010  -  代表关机</li>
<li>000011  -  代表进行加法运算</li>
</ul>
<p>当我们通过电路发送给CPU这样的二进制指令，CPU就能够根据我们的指令执行对应的任务，而我们编写的程序保存在硬盘中也是这样的二进制形式，我们只需要将这些指令组织好，按照我们的思路一条一条执行对应的命令，就能够让计算机计算任何我们需要的内容了，这其实就是机器语言。</p>
<p>不过随着时代的进步，指令集越来越大，CPU支持的运算类型也越来越多，这样的纯二进制编写实在是太累了，并且越来越多的命令我们根本记不住，于是就有了汇编语言。汇编语言将这些二进制的操作码通过助记符来替换：</p>
<ul>
<li>MOV   传送字或字节。</li>
<li>MOVSX  先符号扩展,再传送。</li>
<li>MOVZX  先零扩展,再传送。</li>
<li>PUSH  把字压入堆栈。</li>
</ul>
<p>把这些原有的二进制命令通过一个单词来代替，这样是不是就好记多了，在程序编写完成后，我们只需要最后将这些单词转换回二进制指令就可以了，这也是早期出现的低级编程语言。</p>
<figure data-type="image" tabindex="12"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rlmjqp3dj217e09agmz.jpg" alt="image-20220531150346899" loading="lazy"></figure>
<p>不过虽然通过这些助记符就能够很轻松地记住命令，但是还是不够方便，因为可能我们的程序需要完成一个很庞大的任务，但是如果还是这样一条一条指令进行编写，是不是太慢了点，有时候可能做一个简单的计算，都需要好几条指令来完成。于是，高级编程语言——C语言，终于诞生了。</p>
<blockquote>
<p>C语言诞生于美国的<a href="https://baike.baidu.com/item/%E8%B4%9D%E5%B0%94%E5%AE%9E%E9%AA%8C%E5%AE%A4/686816">贝尔实验室</a>，由<a href="https://baike.baidu.com/item/%E4%B8%B9%E5%B0%BC%E6%96%AF%C2%B7%E9%87%8C%E5%A5%87/7267171">丹尼斯·里奇</a>（Dennis MacAlistair Ritchie）以肯尼斯·蓝·汤普森（Kenneth Lane Thompson）设计的<a href="https://baike.baidu.com/item/B%E8%AF%AD%E8%A8%80/1845842">B语言</a>为基础发展而来，在它的主体设计完成后，汤普森和里奇用它完全重写了UNIX操作系统，且随着UNIX操作系统的发展，C语言也得到了不断的完善。</p>
</blockquote>
<p>高级语言不同于低级语言，低级语言的主要操作对象是指令本身，而高级语言却更加符合我们人脑的认知，更像是通过我们人的思维，去告诉计算机你需要做什么，包括语法也会更加的简单易懂。下面是一段简单的C语言代码：</p>
<pre><code class="language-c">int main() {
  	int a = 10;   //定义一个a等于10
  	int b = 10;   //定义一个b等于10
  	int c = a + b;   //语义非常明确，c就是a加上b计算出来的结果。
  	return 0;
}
</code></pre>
<p>不过现在看不懂没关系，我们后面慢慢学。</p>
<p>C语言虽然支持按照我们更容易理解的方式去进行编程，但是最后还是会编译成汇编指令最后变成计算机可以直接执行的指令，不过具体的编译过程，我们不需要再关心了，我们只需要去写就可以了，而对我们代码进行编译的东西，称为编译器。</p>
<figure data-type="image" tabindex="13"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2uzn81nwsj21qk07mdhd.jpg" alt="image-20220603123928430" loading="lazy"></figure>
<p>当然，除了C语言之外，还有很多其他的高级语言，比如Java、Python、C#、PHP等等，相比其他编程语言，C算是比较古老的一种了，但是时隔多年直至今日，其他编程语言也依然无法撼动它的王者地位：</p>
<figure data-type="image" tabindex="14"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rlw7fvhmj20xo0b0wf4.jpg" alt="image-20220531151304124" loading="lazy"></figure>
<p>可以看到在2021年9月，依然排在编程语言排行榜的<strong>第一名</strong>（Python和Java紧随其后），可见这门语言是多么的不可撼动，很多操作系统、高级编程语言底层实现，几乎都是依靠C语言去编写的（包括Java的底层也是C/C++实现的）所以学习这一门语言，对于理工科尤其是计算机专业极为重要，学好C语言你甚至可以融汇贯通到其他语言，学起来也会轻松很多。</p>
<p>那么从下节课开始，我们就先做好一些环境上的准备。</p>
<h2 id="c语言开发环境部署">C语言开发环境部署</h2>
<p>完成开发环境部署之后，我们就可以使用C语言来将一句话输出到控制台了，成功编译运行下面的简单程序：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello, World!\n&quot;);
    return 0;
}
</code></pre>
<p>首先，我们既然要将我们编写的C语言代码进行编译，那么肯定得找到一个合适的编译器才行，现代的集成开发环境IDE一般都包含了这些编译器，所以我们不需要进行单独的安装。</p>
<p>我们只需要找一个集成开发环境去安装就行了，目前功能比较完善的集成开发环境有：</p>
<ul>
<li>Codeblocks（支持Windows、Linux、MacOS操作系统）</li>
<li>Visual Studio（支持Windows、MacOS操作系统）</li>
<li>CLion（支持Windows、Linux、MacOS操作系统）</li>
</ul>
<p>这里我们就使用CLion作为我们的开发工具使用（这个IDE是收费的，但是学生可以申请免费使用，别担心，大学四年肯定是够你用了，选这个是考虑到后面同学们可能会继续学习Java，Java语言的推荐IDE也是同一个公司的产品，界面都长得差不多）当然如果你想要使用其他的开发工具，也可以，但是这里我们就不演示了。</p>
<p>首先前往官网下载：<a href="https://www.jetbrains.com/clion/">CLion: A Cross-Platform IDE for C and C++ by JetBrains</a></p>
<figure data-type="image" tabindex="15"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rn0oo80lj22h00eudia.jpg" alt="image-20220531155158399" loading="lazy"></figure>
<p>下载完成后我们直接点击安装：</p>
<figure data-type="image" tabindex="16"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rna8jfzdj21wa0lg438.jpg" alt="image-20220531160109168" loading="lazy"></figure>
<p>如果你不是很熟悉，建议直接点Next安装到C盘默认路径，不要去修改，当然如果确实C盘没有空间，那可以自行修改为其他路径，但是注意最好路径中不要出现中文。</p>
<figure data-type="image" tabindex="17"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rncm5g59j220k0l4q7u.jpg" alt="image-20220531160325932" loading="lazy"></figure>
<p>勾选一下创建快捷方式，然后继续点Next等待安装就行了：</p>
<figure data-type="image" tabindex="18"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rnd7qj7mj22080l67b2.jpg" alt="image-20220531160400589" loading="lazy"></figure>
<p>安装完成后，我们可以直接打开：</p>
<figure data-type="image" tabindex="19"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rnjvf3k1j227w0r079b.jpg" alt="image-20220531161024539" loading="lazy"></figure>
<p>这里会提示我们激活，点击按钮去官网注册一个账号。注册完成后，推荐去申请一下学生授权，因为试用只有30天：<a href="https://zhuanlan.zhihu.com/p/378185042">Jetbrains学生授权获取指南 - 知乎 (zhihu.com)</a></p>
<figure data-type="image" tabindex="20"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rnltppqfj22c40segr3.jpg" alt="image-20220531161215214" loading="lazy"></figure>
<p>这里我们点击开始试用，然后就可以点击Continue了，现在成功来到主界面：</p>
<figure data-type="image" tabindex="21"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rnnis1prj22020u00xg.jpg" alt="image-20220531161354913" loading="lazy"></figure>
<p>由于是英文，使用不太方便，所以我们安装一下中文插件：</p>
<figure data-type="image" tabindex="22"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rnom1mcvj223k0u0k1k.jpg" alt="image-20220531161457379" loading="lazy"></figure>
<p>现在我们就成功安装好CLion集成开发环境了。</p>
<figure data-type="image" tabindex="23"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rnpj7nshj222r0u0wjs.jpg" alt="image-20220531161549721" loading="lazy"></figure>
<p>现在我们来创建我们的第一个C语言项目（我们的程序是以一个项目的形式进行管理的，这里知道怎么创建就行了）：</p>
<figure data-type="image" tabindex="24"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rnqck8fyj22450u0tf6.jpg" alt="image-20220531161637209" loading="lazy"></figure>
<p>这里选择C可执行文件，然后项目的保存位置可以自行修改，配置完成后点击创建：</p>
<figure data-type="image" tabindex="25"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rnveombnj21kx0u00vt.jpg" alt="image-20220531162129788" loading="lazy"></figure>
<p>可以看到，在创建之后，会自动为我们生成一段示例代码，而之后我们要编写的代码，都在生成的main.c中进行编写，除了这个文件，其他的全部不要去修改，也不用管是什么意思，后面我们会慢慢介绍。</p>
<p>接着我们需要配置一下工具链，选择捆绑的MinGW（如果已经有了就不需要配置了）</p>
<figure data-type="image" tabindex="26"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2robghz53j21kq0u0tdo.jpg" alt="image-20220531163655149" loading="lazy"></figure>
<p>那么这段示例代码有了，我们如何编译运行呢？</p>
<figure data-type="image" tabindex="27"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rnyucqxmj21kv0u00wb.jpg" alt="image-20220531162447514" loading="lazy"></figure>
<p>我们可以点击代码旁边的绿色三角形符号或是右上角的绿色三角形，就可以直接编译运行我们的代码了。运行的结果是在控制台输出一个“HelloWorld！”，当然我们也可以直接运行编译出来的可执行文件：</p>
<figure data-type="image" tabindex="28"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ro0rgqnaj21u20e4di5.jpg" alt="image-20220531162638883" loading="lazy"></figure>
<p>我们可以看到，这里生成了一个<code>项目名称.exe</code>文件，这种就是Windows环境下可以直接运行的应用程序，我们可以打开这个文件夹，直接使用cmd来运行：</p>
<figure data-type="image" tabindex="29"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ro2lc6rxj218404qt9n.jpg" alt="image-20220531162824734" loading="lazy"></figure>
<p>运行出来的效果是一样的，这种程序实际上就是最原始的命令行程序，输入和输出都是在这种黑框框中进行的，而我们的主要学习目标也是这种命令行程序。</p>
<p>这样我们就配置好了开发环境，然后就不要去动其他的东西了，一般新手最容易遇到一些奇奇怪怪的问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言程序设计（三）]]></title>
        <id>https://muouren7.github.io/post/C语言（三）/</id>
        <link href="https://muouren7.github.io/post/C语言（三）/">
        </link>
        <updated>2022-10-14T08:06:38.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://s2.loli.net/2022/06/19/XpyacVrNM16d8qb.png" alt="image-20220619215833870" loading="lazy"></figure>
<h1 id="c语言高级特性">C语言高级特性</h1>
<p>前面我们了解了C语言的相关基础内容，我们来看看C语言的高级部分。这一章的学习难道会比较大，尤其是指针板块，因为需要理解计算机内存模型，所以说是很多初学者的噩梦。</p>
<h2 id="函数">函数</h2>
<p>其实函数我们在一开始就在使用了：</p>
<pre><code class="language-c">int main() {   //这是定义函数
   ...
}
</code></pre>
<p>我们程序的入口点就是<code>main</code>函数，我们只需要将我们的程序代码编写到主函数中就可以运行了，不够这个函数只是由我们来定义，而不是我们自己来调用。当然，除了主函数之外，我们一直在使用的<code>printf</code>也是一个函数，不过这个函数是标准库中已经实现好了的，现在是我们在调用这个函数：</p>
<pre><code class="language-c">printf(&quot;Hello World!&quot;);    //直接通过 函数名称(参数...) 的形式调用函数
</code></pre>
<p>那么，函数的具体定义是什么呢？</p>
<blockquote>
<p>函数是完成特定任务的独立程序代码单元。</p>
</blockquote>
<p>其实简单来说，函数时为了完成某件任务而生的，可能我们要完成某个任务并不是一行代码就可以搞定的，但是现在可能会遇到这种情况：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    
    printf(&quot;H&quot;);   //比如下面这三行代码就是我们要做的任务
    printf(&quot;A&quot;);
    a += 10;
    
    if(a &gt; 20) {
        printf(&quot;H&quot;);   //这里我们还需要执行这个任务
        printf(&quot;A&quot;);
        a += 10;
    }

    switch (a) {
        case 30:
            printf(&quot;H&quot;);   //这里又要执行这个任务
            printf(&quot;A&quot;);
            a += 10;
            
    }
}
</code></pre>
<p>我们每次要做这个任务时，都要完完整整地将任务的每一行代码都写下来，如果我们的程序中多处都需要执行这个任务，每个地方都完整地写一遍，实在是太臃肿了，有没有一种更好的办法能优化我们的代码呢？</p>
<p>这时我们就可以考虑使用函数了，我们可以将我们的程序逻辑代码全部编写到函数中，当我们执行函数时，实际上执行的就是函数中的全部内容，也就是按照我们制定的规则执行对应的任务，每次需要做这个任务时，只需要调用函数即可。</p>
<p>我们来看看，如何创建和使用函数。</p>
<h3 id="创建和使用函数">创建和使用函数</h3>
<p>首先我们来看看如何创建一个函数，其实创建一个函数是很简单的，格式如下：</p>
<pre><code class="language-c">返回值类型 函数名称([函数参数...]);
</code></pre>
<p>其中函数名称也是有要求的，并不是所有的字符都可以用作函数名称，它的命名规则与变量的命名规则基本一致，所以这里就不一一列出了。</p>
<p>函数不仅仅需要完成我们的任务，可能某些函数还需要告诉我们结果，比如我们之前认识的<code>getchar</code>函数，这个函数实际上返回了一个int值作为结果（也就是我们输入的字符）我们同样可以将函数返回的结果赋值给变量或是参与运算等等。</p>
<p>当然如果我们的函数只需要完成任务，不需要告诉我们结果，返回值类型可以写成<code>void</code>表示为空。</p>
<p>函数参数我们放在下一个小节中讲解，所以这里我们不使用任何参数，所以这里也将参数设定为<code>void</code>表示没有参数（当然为了方便，我们也可以直接什么都不写）</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void test(void);   //定义函数原型，因为C语言是从上往下的，所以如果要在下面的主函数中使用这个函数，一定要定义到它的上面。

int main() {
    
}

void test(void){   //函数具体定义，添加一个花括号并在其中编写程序代码，就和我们之前在main中编写一样
    printf(&quot;我是测试函数!&quot;);
}
</code></pre>
<p>或是直接在上方写上函数的具体定义：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void test(void){   //函数具体定义，添加一个花括号并在其中编写程序代码，就和我们之前在main中编写一样
    printf(&quot;我是测试函数!&quot;);
}

int main() {
    
}
</code></pre>
<p>那么现在我们将函数定义好之后，该如何去使用呢？</p>
<pre><code class="language-c">int main() {
    test();   //这里我们只需要使用 函数名称(); 就可以调用函数了
  	printf(&quot;Hello World!&quot;);   //实际上printf也是一个函数，功能是向控制台打印字符串，只不过这个函数是系统提供的，已经提前实现好了，其中的参数我们后续还会进行介绍。
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://s2.loli.net/2022/06/19/s1uqceI3g6kFiXa.png" alt="image-20220619224057060" loading="lazy"></figure>
<p>这样，我们就可以很好解决上面的代码复用性的问题，我们只需要将会重复使用的逻辑代码定义到函数中，当我们需要执行时，直接调用编写好的函数就可以了，这样是不是简单多了？</p>
<pre><code class="language-c">int main() {
    int a = 10;

    test();   //多次使用的情况下，函数会让我们的程序简单很多

    if(a &gt; 20) test();

    switch (a) {
        case 30:
            test();
    }
}
</code></pre>
<p>当然函数除了可以实现代码的复用之外，也可以优化我们的程序，让我们的代码写得更有层次感，我们的程序可能会有很多很多的功能，需要写很多的代码，但是谁愿意去看一个几百行上千行的<code>main</code>函数呢？我们可以将每个功能都写到一个对应的函数中，这样就可以大大减少<code>main</code>函数中的代码量了。</p>
<pre><code class="language-c">int main() {
    func1();   //直接把多行代码写到一个函数中，在main中调用对应的函数，这样能够大幅度减少代码量
    func2();
    func3();
}
</code></pre>
<p>而我们从一开始就在编写main函数实际上是一种比较特殊的函数，C语言规定程序一律从主函数开始执行，所以这也是为什么我们一定要写成<code>int main()</code>的形式。</p>
<h3 id="全局变量和局部变量">全局变量和局部变量</h3>
<p>现在我们已经了解了如何创建和调用函数，在继续学习后续内容之前，我们需要先认识一下全局变量和局部变量这两个概念（啊这，变量就变量，还分这么细啊？）</p>
<p>我们首先来看看局部变量，实际上我们之前使用的都是局部变量，比如：</p>
<pre><code class="language-c">int main() {
    int i = 10;   //这里定义的变量i实际上是main函数中的局部变量，它的作用域只能是main函数中，也就是说其他地方是无法使用的
}
</code></pre>
<p>局部变量只会在其作用域中生效：</p>
<figure data-type="image" tabindex="3"><img src="https://s2.loli.net/2022/06/21/1sTwRq95uWce3Az.png" alt="image-20220621104906130" loading="lazy"></figure>
<p>可以看到在其他函数中，无法使用main函数中的变量，因为局部变量的作用域是有限的，比如位于某个函数内部的变量，那么它的作用域就是整个函数内部，而在其他位置均无法访问。又比如我们之前学习的for循环，当我们这样定义时：</p>
<figure data-type="image" tabindex="4"><img src="https://s2.loli.net/2022/06/21/NohbirYPSBVLQap.png" alt="image-20220621110340649" loading="lazy"></figure>
<p>可以看到，在for循环中定义的变量i，只能在for循环内部使用，而出了这个花括号之后就用不了了，当然由于作用域不同，所以下面这种写法是完全没问题的：</p>
<pre><code class="language-c">int main() {
    for (int i = 0; i &lt; 10; ++i) {   //虽然这里写了两个for都使用了i，但是由于处于两个不同的作用域，所以这两个i半毛钱关系都没有

    }

    for (int i = 0; i &lt; 20; ++i) {

    }
}
</code></pre>
<p>所以，清楚了局部变量的作用域之后，我们在编写程序的时候就很清楚了：</p>
<figure data-type="image" tabindex="5"><img src="https://s2.loli.net/2022/06/21/jPTobYLNdn6sgcH.png" alt="image-20220621110503710" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://s2.loli.net/2022/06/21/PaACqnRBTNXkESY.png" alt="image-20220621110555759" loading="lazy"></figure>
<p>那么如果现在我们想要在任何位置都能使用一个变量，该怎么办呢？这时就要用到全局变量了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void test();

int a = 10;   //我们可以直接将变量定义放在外面，这样所有的函数都可以访问了

int main() {
    a += 10;
    test();    //现在各位觉得，这两个操作完成后，a会是多少呢？
    printf(&quot;%d&quot;, a);
}

void test(){
    a += 10;
}
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://s2.loli.net/2022/06/21/Sdya9HZ7lDMTcIA.png" alt="image-20220621111319786" loading="lazy"></figure>
<p>因为现在所有函数都能使用全局变量，所以这个结果不难得到。</p>
<h3 id="函数参数和返回">函数参数和返回</h3>
<p>我们的函数可以接受参数来完成任务，比如我们现在想要实现<strong>用一个函数计算两个数的和并输出到控制台。</strong></p>
<p>这种情况我们就需要将我们需要进行加法计算的两个数，告诉函数，这样函数才能对这两个数求和，那么怎么才能告诉函数呢？我们可以通过设定参数：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void test(int, int);   //函数原型中需要写上需要的参数类型，多个参数用逗号隔开，比如这里我们需要的就是两个int类型的参数

int main() {

}

void test(int a, int b){  //函数具体定义中也要写上，这里的a和b我们称为形式参数（形参），等价于函数中的局部变量，作用域仅限此函数
		printf(&quot;%d&quot;, a + b);
}
</code></pre>
<p>那么现在定义完成了，该如何使用这个函数呢，还记得我们怎么使用<code>printf</code>函数的吗？我们只需要把它所需要的参数填入即可：</p>
<pre><code class="language-c">int main() {
    test(10, 20);   //这里直接填写一个常量、变量或是运算表达式都是可以的，我们称实际传入的值为实际参数（实参）
}
</code></pre>
<p>可以看到，成功计算出结果：</p>
<figure data-type="image" tabindex="8"><img src="https://s2.loli.net/2022/06/21/dauFW2DNL3PnvYG.png" alt="image-20220621113243405" loading="lazy"></figure>
<p>实际上我们传入的实参在进入到函数时，会自动给函数中形参（局部变量）进行赋值，这样我们在函数中就可以得到外部传入的参数值了。</p>
<figure data-type="image" tabindex="9"><img src="https://s2.loli.net/2022/06/23/8zv1O5ZYAQTJNoV.png" alt="image-20220623224355944" loading="lazy"></figure>
<p>我们来看看<code>printf</code>函数是怎么写的：</p>
<pre><code class="language-c">int  printf(const char * __restrict, ...) __printflike(1, 2);   //看起来比较高级
</code></pre>
<p>这里我们主要关心它的两个参数，一个是<code>char *</code>由于还没有学习指针，这里就把它当做<code>const char[]</code>就行了，表示一个不可修改的字符串，而第二个参数我们看到是<code>...</code>，这三个点是个啥？</p>
<p>我们知道，如果我们想要填写具体需要打印的值时，可以一直往后写：</p>
<pre><code class="language-c">printf(&quot;%d, %d&quot;, 1, 2);   //参数可以一直写
</code></pre>
<p>正常情况下我们函数的参数列表都是固定的，怎么才能像这样写很多个呢？这就要用到可变长参数了，不过可变长参数的使用比较麻烦，这里我们就不做讲解了。</p>
<p>这里给大家提一个问题，如果我们修改形式参数的值，外面的实参值会跟着发生修改吗？</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void swap(int, int);

int main() {
    int a = 10, b = 20;
    swap(a, b);

    printf(&quot;a = %d, b = %d&quot;, a, b);   //最后会得到什么结果？
}

void swap(int a, int b){
    int tmp = a;   //这里对a和b的值进行交换
    a = b;
    b = tmp;
}
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://s2.loli.net/2022/06/23/5QbExfHNM76pBOY.png" alt="image-20220623224752943" loading="lazy"></figure>
<p>通过结果发现，虽然调用了函数对a和b的值进行交换，但貌似并没有什么卵用。这是为什么呢？</p>
<p>还记得我们前面说的吗，函数的形参实际上就是函数内的局部变量，它的作用域仅仅是这个函数，而我们外面传入的实参，仅仅知识将值赋值给了函数内的形参而已，并且外部的变量跟函数内部的变量作用域都不同，所以半毛钱关系都没有，这里交换的仅仅是函数内部的两个形参变量值，跟外部作实参的变量没有任何关系。</p>
<p>那么，怎么样才能实现通过函数交换两个变量的值呢？这个问题我们会在指针部分进行讨论。</p>
<p>不过数组却不受限制，我们在函数中修改数组的值，是直接可以生效的：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void test(int arr[]);

int main() {
    int arr[] = {4, 3, 8, 2, 1, 7, 5, 6, 9, 0};
    test(arr);
    printf(&quot;%d&quot;, arr[0]);  //打印的是修改后的值了
}

void test(int arr[]) {
    arr[0] = 999;   //数组就可以做到这边修改，外面生效
}
</code></pre>
<p>我们再来看一个例子：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void test(int a){
    a += 10;
    printf(&quot;%d\n&quot;, a);
}

int main() {
    int a = 10;
    test(a);
    test(a);   //连续两次调用，那么这两次的结果会是什么？
}
</code></pre>
<p>可以看到结果都是20，（如果猜对了可以直接跳过，如果你猜测的是20和30的话，需要听我解释了）注意每次调用函数都是单独进行的，并不是复用函数中的形参，不要认为第一次调用函数test就将函数的局部变量变成20了，再次调用就是20+10变成30。实际上这两次调用都是单独进行的，形参a都是在一开始的时候被赋值为实参的值的，这两次调用没有任何关系，并且函数执行完毕后就自动销毁了。</p>
<p>那要是我就希望每次调用函数时保留变量的值呢？我们可以使用静态变量：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void test();

int main() {
    test();
    test();
}

void test() {
    static int a = 20;   //静态变量并不会在函数结束时销毁其值，而是保持
    a += 20;
    printf(&quot;%d &quot;, a);
}
</code></pre>
<p>我们接着来看函数的返回值，并不是所有的函数都是执行完毕就结束了的，可能某些时候我们需要函数告诉我们执行的结果如何，这时我们就需要用到返回值了，比如现在我们希望实现一个函数计算a+b的值：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int sum(int ,int );   //现在我们要返回a和b的和（那么肯定也是int类型）所以这里需要将返回值类型修改为int

int main() {
    int a = 10, b = 20;   //计算a和b的和
  	int result = sum(a, b);   //函数执行后，会返回一个int类型的结果，我们可以接收它，也可以像下面一样直接打印，当然也可以参与运算等等。
    printf(&quot;a+b=%d&quot;, sum(a, b));
}

int sum(int a, int b) {
    return a + b;   //通过return关键字来返回计算的结果
}
</code></pre>
<p>我们接着来看下一个例子，现在我们希望你通过函数找到数组中第一个小于0的数字并将其返回，如果没有找到任何小于0的数，就返回0即可：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int findMin(int arr[], int len);   //需要两个参数，一个是数组本身，还有一个是数组的长度

int main() {
    int arr[] = {1, 4, -9, 2, -4, 7};
    int min = findMin(arr, 6);
    printf(&quot;第一个小于0的数是：%d&quot;, min);
}

int findMin(int arr[], int len) {
    for (int i = 0; i &lt; len; ++i) {
        if(arr[i] &lt; 0) return arr[i];   //当判断找到后，直接return返回即可，这样的话函数会直接返回结果，无论后面还有没有代码没有执行完，整个函数都会直接结束。
    }
    return 0;   //如果没有找到就返回0
}
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://s2.loli.net/2022/06/23/fRw8nbV15dQGIUH.png" alt="image-20220623231617525" loading="lazy"></figure>
<p>这里我们使用了<code>return</code>关键字来返回结果，注意当我们的程序走到<code>return</code>时，无论还有什么内容没执行完，整个函数都将结束，并返回结果。注意带返回值（非void）的函数中的所有情况都需要有一个对应的返回值：</p>
<pre><code class="language-c">int test(int a) {
    if (a &gt; 0) {
        return 10;   //当a大于0时有返回语句
    } else{
          //但是当a不大于0时就没有返回值了，这样虽然可以编译通过，但是会有警告（黄标），运行后可能会出现一些无法预知的问题
    }
}
</code></pre>
<p>如果是没有返回值的函数，我们也可以调用<code>return</code>来返回，不过默认情况下是可以省略的：</p>
<pre><code class="language-c">void test(int a){
    if(a == 10) return;   //因为是void，所以什么都不需要加，直接return
    printf(&quot;%d&quot;, a);
}
</code></pre>
<h3 id="递归调用">递归调用</h3>
<p>我们的函数除了在其他地方被调用之外，也可以自己调用自己（好家伙，套娃是吧），这种玩法我们称为递归。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void test(){
    printf(&quot;Hello World!\n&quot;);
    test();   //函数自己在调用自己，这样的话下一轮又会进入到这个函数中
}

int main() {
    test();
}
</code></pre>
<p>我们可以尝试运行一下上面的程序，会发现程序直接无限打印<code>Hello World!</code>这个字符串，这是因为函数自己在调用自己，不断地重复进入到这个函数，理论情况下，它将永远都不会结束，而是无限地执行这个函数的内容。</p>
<figure data-type="image" tabindex="12"><img src="https://s2.loli.net/2022/06/23/feq6xUPDjSLAKYF.png" alt="image-20220623233305190" loading="lazy"></figure>
<p>但是到最后我们的程序还是终止了，这是因为函数调用有最大的深度限制，因为计算机不可能放任函数无限地进行下去。</p>
<blockquote>
<p><strong>（选学）<strong>我们来大致了解一下函数的调用过程，实际上在程序运行时会有一个叫做</strong>函数调用栈</strong>的东西，它用于控制函数的调用：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;   //我们以下面的调用关系为例

void test2(){
    printf(&quot;giao&quot;);
}

void test(){
    test2();   //main -&gt; test -&gt; test2
  	printf(&quot;giao&quot;);
}

int main() {
    test();
  	printf(&quot;giao&quot;);
}
</code></pre>
<p>其实我们可以很轻易地看出整个调用关系，首先是从main函数进入，然后调用test函数，在test函数中又调用了test2函数，此时我们就需要等待test2函数执行完毕，test才能继续，而main则需要等待test执行完毕才能继续。而实际上这个过程是由函数调用栈在控制的：</p>
<figure data-type="image" tabindex="13"><img src="https://s2.loli.net/2022/06/23/lAfGyoDWBstz6bm.png" alt="image-20220623235007335" loading="lazy"></figure>
<p>而当test2函数执行完毕后，每个栈帧又依次从栈中出去：</p>
<figure data-type="image" tabindex="14"><img src="https://s2.loli.net/2022/06/23/IWYsq8m2htNeEaP.png" alt="image-20220623235649397" loading="lazy"></figure>
<p>当所有的栈全部出去之后，程序结束。</p>
<p>所以这也就不难解释为什么无限递归会导致程序出现错误，因为栈的空间有限，而函数又一直在进行自我调用，所以会导致不断地有新的栈帧进入，最后塞满整个栈的空间，就爆炸了，这种问题我们称为栈溢出（Stack Overflow）</p>
</blockquote>
<p>当然，如果我们好好地按照规范使用递归操作，是非常方便的，比如我们现在需要求某个数的阶乘：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int test(int n);

int main() {
    printf(&quot;%d&quot;, test(3));
}

int test(int n){
    if(n == 1) return 1;   //因为不能无限制递归下去，所以我们这里添加一个结束条件，在n = 1时返回
    return test(n - 1) * n;  //每次都让n乘以其下一级的计算结果，下一级就是n-1了
}
</code></pre>
<p>通过给递归调用适当地添加结束条件，这样就不会无限循环了，并且我们的程序看起来无比简洁，那么它是如何执行的呢：</p>
<figure data-type="image" tabindex="15"><img src="https://s2.loli.net/2022/06/24/SsJWqGKyQko47Mm.png" alt="image-20220624002051266" loading="lazy"></figure>
<p>它看起来就像是一个先走到底部，然后拿到问题的钥匙后逐步返回的一个过程，并在返回的途中不断进行计算最后得到结果（妙啊）</p>
<p>所以，合理地使用递归反而是一件很有意思的事情。</p>
<h3 id="实战斐波那契数列解法其三">实战：斐波那契数列解法其三</h3>
<p>前面我们介绍了函数的递归调用，我们来看一个具体的实例吧，我们还是以解斐波那契数列为例。</p>
<p>既然每个数都是前两个数之和，那么我们是否也可以通过递归的形式不断划分进行计算呢？我们依然可以借鉴之前动态规划的思想，通过划分子问题，分而治之来完成计算。</p>
<h3 id="实战汉诺塔">实战：汉诺塔</h3>
<p>什么是汉诺塔？</p>
<blockquote>
<p><strong>汉诺塔</strong>（Tower of Hanoi），又称<strong>河内塔</strong>，是一个源于<a href="https://baike.baidu.com/item/%E5%8D%B0%E5%BA%A6/121904">印度</a>古老传说的<a href="https://baike.baidu.com/item/%E7%9B%8A%E6%99%BA%E7%8E%A9%E5%85%B7/223159">益智玩具</a>。<a href="https://baike.baidu.com/item/%E5%A4%A7%E6%A2%B5%E5%A4%A9/711550">大梵天</a>创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令<a href="https://baike.baidu.com/item/%E5%A9%86%E7%BD%97%E9%97%A8/1796550">婆罗门</a>把圆盘从下面开始</p>
<p><strong>按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</strong></p>
</blockquote>
<figure data-type="image" tabindex="16"><img src="https://s2.loli.net/2022/06/24/Z7iN526FOQLS3Kz.png" alt="image-20220624002507501" loading="lazy"></figure>
<p>这三根柱子我们就依次命名为A、B、C，现在请你设计一个C语言程序，计算N阶（n片圆盘）汉诺塔移动操作的每一步。</p>
<p>这个问题看似很难，实际上我们也可以对每一步进行推理：</p>
<blockquote>
<p>当汉诺塔只有1阶的情况下：直接把A上的圆盘移动到C，搞定。</p>
</blockquote>
<blockquote>
<p>当汉诺塔只有2阶的情况下：我们的最终目标还是需要将A柱最下面的圆盘丢到C，不过现在多了圆盘，我们得先把这个圆盘给处理了，所以我们得把这上面的1个圆盘丢到B上去，这样才能把A最下面的圆盘丢给C。然后再把B上面的1个圆盘丢到C上去</p>
</blockquote>
<blockquote>
<p>当汉诺塔只有3阶的情况下：我们的最终目标还是需要将A柱最下面的圆盘丢到C，不过现在多了圆盘，我们得先把这个圆盘给处理了，所以我们得把这上面的2个圆盘丢到B上去，这样才能把A最下面的圆盘丢给C。然后再把B上面的2个圆盘丢到C上</p>
</blockquote>
<p>实际上我们发现，把A移动到C是一定要进行的，而在进行之前需要先把压在上面全部的圆盘全部放到B去。而移动之后也要把B上的圆盘全部移动到C上去。其实所有的情况下最终都会有一个n=1的情况，将A上的最后一个圆盘移动到C，只是多了一个前面的步骤和后面的步骤。</p>
<p>不过难点就是，怎么把A上的n-1个圆盘移动到B去呢？其实这时我们可以依靠C作为中间商，来帮助我们移动（比如n = 3，那么先把最上面的移动到C，然后把第二大的移动到B，再从C上把最小的移动到B上，这样就借助了C完成了两个圆盘的转移），而最后又怎么把B上的圆盘全部移到C去呢，这时就可以依靠A作为中间商，方法同理；实际上大问题最后都会变成n = 2时这样的小问题，只不过是要移动目标不同罢了。</p>
<p>只要想通了怎么去借助中间商进行移动，就很好写出程序了。</p>
<p>递归函数如下设计：</p>
<pre><code class="language-c">//a存放圆盘的初始柱子，b作为中间柱子存放使用，c作为目标柱子，n表示要从a移动到c的圆盘数
void hanoi(char a, char b, char c, int n){
    
}
</code></pre>
<p>现在我们来实现一下吧。</p>
<pre><code class="language-c">void move(char start, char end, int n){   //用于打印移动操作到控制台，start是起始柱子，end是结束柱子，n是哪一个圆盘
    printf(&quot;第%d个圆盘：%c --&gt; %c\n&quot;, n, start, end);
}

void hanoi(char a, char b, char c, int n){  //刚进来的时候，B作为中间柱子，C作为目标柱子，要移动A上的n个圆盘到C去
    if(n == 1) {
        move(a, c, n);   //无论a,b,c如何变换，通过递归，最后都会变成一个n = 1的问题，直接移动就完事了
    } else{
        hanoi(a, c ,b, n - 1);  //首要目标是先把上面n-1个圆盘全部放到B去，这里就变换一下，让B作为目标柱子，C作为中间
        move(a, c, n);   //现在A上只剩下一个最大的圆盘了，接着把A最下方的一个圆盘移到C去
        hanoi(b, a, c, n - 1);   //最后需要把B上的全部搬到C上去，这里就可以以C为目标柱子，A为中间柱子
    }
}
</code></pre>
<p>简化一波：</p>
<pre><code class="language-c">void hanoi(char a, char b, char c, int n){
    if(n == 0) return;
    hanoi(a, c ,b, n - 1);
    printf(&quot;第%d个圆盘：%c --&gt; %c\n&quot;, n, a, c);
    hanoi(b, a, c, n - 1);
}
</code></pre>
<p>看似如此复杂的问题，其实只需要4行就可以解决了。</p>
<h3 id="实战快速排序算法选学">实战：快速排序算法（选学）</h3>
<p>有一个数组：</p>
<pre><code class="language-c">int arr[] = {4, 3, 8, 2, 1, 7, 5, 6, 9, 0};
</code></pre>
<p>现在请你设计一个C语言程序，对数组按照从小到大的顺序进行排序。这里我们使用冒泡排序的进阶版本——<strong>快速排序</strong>来完成，它的核心思想是分而治之，每一轮排序都会选出一个基准，一轮排序完成后，所以比基准小的数一定在左边，比基准大的数一定在右边，在分别通过同样的方法对左右两边的数组进行排序，不断划分，最后完成整个数组的排序。它的效率相比冒泡排序的双重for循环有所提升。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void quickSort(int arr[], int left, int right){  //arr是数组，left是起始下标，right是结束下标
    //请实现这一部分
}

int main() {
    int arr[] = {4, 3, 8, 2, 1, 7, 5, 6, 9, 0};
    quickSort(arr, 0, 9);  //10个数字下标就是0-9
    for (int i = 0; i &lt; 10; ++i) {
        printf(&quot;%d &quot;, arr[i]);
    }
}
</code></pre>
<p>不过虽然这种排序算法很快，但是极端情况下（比如遇到了刚好倒序的数组）还是会退化成冒泡排序的。</p>
<hr>
<h2 id="指针">指针</h2>
<p>指针可以说是整个C语言中最难以理解的部分了，不过其实说简单也简单，你会发现也并没有想象中的那么难，你与它的距离可能只差了那么一些基础知识，这一部分都会及时进行补充的。</p>
<h3 id="什么是指针">什么是指针</h3>
<p>还记得我们在上一个部分谈到的通过函数交换两个变量的值吗？</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void swap(int, int);

int main() {
    int a = 10, b = 20;
    swap(a, b);

    printf(&quot;a = %d, b = %d&quot;, a, b);   //最后会得到什么结果？
}

void swap(int a, int b){
    int tmp = a;   //这里对a和b的值进行交换
    a = b;
    b = tmp;
}
</code></pre>
<p>实际上这种写法是错误的，因为交换的并非是真正的a和b，而是函数中的局部变量。那么有没有办法能够直接对函数外部的变量进行操作呢？这就需要指针的帮助了。</p>
<p>我们知道，程序中使用的变量实际上都在内存中创建的，每个变量都会被保存在内存的某一个位置上（具体在哪个位置是由系统分配的），就像我们最终会在这个世界上的某个角落安家一样，所有的变量在对应的内存位置上都有一个地址（地址是独一无二的），而我们可以通过这个地址寻找到这个变量本体，比如int占据4字节，因此int类型变量的地址就是这4个字节的起始地址，后面32个bit位全部都是用于存放此变量的值的。</p>
<figure data-type="image" tabindex="17"><img src="https://s2.loli.net/2022/06/24/zi5ZwxK76REpYUI.png" alt="image-20220624221635066" loading="lazy"></figure>
<p>这里的<code>0x</code>是十六进制的表示形式（10-15用字母A - F表示）如果我们能够知道变量的内存地址，那么无论身在何处，都可以通过地址找到这个变量了。而指针的作用，就是专门用来保存这个内存地址的。</p>
<p>我们来看看如何创建一个指针变量用于保存变量的内存地址：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    int a = 10;
  	//指针类型需要与变量的类型相同，且后面需要添加一个*符号（注意这里不是乘法运算）表示是对于类型的指针
    int * p = &amp;a;   //这里的&amp;并不是进行按位与运算，而是取地址操作，也就是拿到变量a的地址
    printf(&quot;a在内存中的地址为：%p&quot;, p);  //地址使用%p表示
}
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://s2.loli.net/2022/06/24/Pb3cWuOFIMkJLEa.png" alt="image-20220624222718731" loading="lazy"></figure>
<p>可以看到，我们通过取地址操作<code>&amp;</code>，将变量a的地址保存到了一个地址变量<code>p</code>中。</p>
<p>拿到指针之后，我们可以很轻松地获取指针所指地址上的值：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    int a = 666;
    int * p = &amp;a;
    printf(&quot;内存%p上存储的值为：%d&quot;, p, *p);   //我们可以在指针变量前添加一个*号（间接运算符，也可以叫做解引用运算符）来获取对应地址存储的值
}
</code></pre>
<p>注意这里访问指针所指向地址的值时，是根据类型来获取的，比如int类型占据4个字节，那么就读取地址后面4个字节的内容作为一个int值，如果指针是char类型的，那么就只读取地址后面1个字节作为char类型的值。</p>
<figure data-type="image" tabindex="19"><img src="https://s2.loli.net/2022/06/24/GHS8UAoKNT6vZXy.png" alt="image-20220624224026228" loading="lazy"></figure>
<p>同样的，我们也可以直接像这样去修改对应地址存放的值：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    int a = 666;
    int * p = &amp;a;

    *p = 999;   //通过*来访问对应地址的值，并通过赋值运算对其进行修改

    printf(&quot;a的值为：%d&quot;, a);
}
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://s2.loli.net/2022/06/24/3gFKBEuRQlD8wpq.png" alt="image-20220624225026394" loading="lazy"></figure>
<p>实际上拿到一个变量的地址之后，我们完全不需要再使用这个变量，而是可以通过它的指针来对其进行各种修改。因此，现在我们想要实现对两个变量的值进行交换的函数就很简单了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

// 这里是两个指针类型的形参，其值为实参传入的地址，
// 虽然依然是值传递，但是这里传递的可是地址啊，
// 只要知道地址改变量还不是轻轻松松？
void swap(int * a, int * b){
    int tmp = *a;   //先暂存一下变量a地址上的值
    *a = *b;   //将变量b地址上的值赋值给变量a对应的位置
    *b = tmp;   //最后将a的值赋值给b对应位置，OK，这样就成功交换两个变量的值了
}

int main(){
    int a = 10, b = 20;
    swap(&amp;a, &amp;b);   //只需要把a和b的内存地址给过去就行了，这里取一下地址
    printf(&quot;a = %d, b = %d&quot;, a, b);
}
</code></pre>
<figure data-type="image" tabindex="21"><img src="https://s2.loli.net/2022/06/24/8U6pSiKeEFTg2H4.png" alt="image-20220624225800731" loading="lazy"></figure>
<p>通过地址操作，我们就轻松实现了使用函数交换两个变量的值了。</p>
<p>了解了指针的相关操作之后，我们再来看看<code>scanf</code>函数，实际上就很好理解了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    int a;
    scanf(&quot;%d&quot;, &amp;a);   //这里就是取地址，我们需要告诉scanf函数变量的地址，这样它才能通过指针访问变量的内存地址，对我们变量的值进行修改，这也是为什么scanf里面的变量（除数组外）前面都要进行一个取地址操作
    printf(&quot;%d&quot;, a);
}
</code></pre>
<p>当然，和变量一样，要是咱们不给指针变量赋初始值的话，就不知道指的哪里了，因为指针变量也是变量，存放的其他变量的地址值也在内存中保存，如果不给初始值，那么存放别人地址的这块内存可能在其他地方使用过，这样就不知道初始值是多少了（那么指向的地址可能是一个很危险的地址，随意使用可能导致会出现严重错误），所以一定要记得给个初始值或是将其设定为NULL，表示空指针，不指向任何内容。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    int * a = NULL;
}
</code></pre>
<p>我们接着来看看<code>const</code>类型的指针，这种指针比较特殊：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    int a = 9, b = 10;
    const int * p = &amp;a;
    *p = 20;   //这里直接报错，因为被const标记的指针，所指地址上的值不允许发生修改
  	p = &amp;b;   //但是指针指向的地址是可以发生改变的
}
</code></pre>
<p>我们再来看另一种情况：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    int a = 9, b = 10;
    int * const p = &amp;a;   //const关键字被放在了类型后面
    *p = 20;   //允许修改所指地址上的值
    p = &amp;b;   //但是不允许修改指针存储的地址值，其实就是反过来了。
}
</code></pre>
<p>当然也可以双管齐下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    int a = 9, b = 10;
    const int * const p = &amp;a;
    *p = 20;   //两个都直接报错，都不让改了
    p = &amp;b;
}
</code></pre>
<h3 id="指针与数组">指针与数组</h3>
<p>前面我们介绍了指针的基本使用，我们来回顾一个问题，为什么数组可以以原身在函数之间进行传递呢？先说结论，数组表示法实际上是在变相地使用指针，你甚至可以将其理解为数组变量其实就是一个指针变量，它存放的就是数组中第一个元素的起始地址。</p>
<p>为什么这么说？</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    char str[] = &quot;Hello World!&quot;;
    char * p = str;   //？？？啥情况，为什么能直接把数组作为地址赋值给指针变量p？？？

    printf(&quot;%c&quot;, *p);   //还能正常使用，打印出第一个字符？？？
}
</code></pre>
<figure data-type="image" tabindex="22"><img src="https://s2.loli.net/2022/06/24/WaPeLR8o295YpsC.png" alt="image-20220624231833371" loading="lazy"></figure>
<p>你以为这就完了？还能这样玩呢：</p>
<pre><code class="language-c">int main(){
    char str[] = &quot;Hello World!&quot;;
    char * p = str;

    printf(&quot;%c&quot;, p[1]);   //？？？怎么像在使用数组一样用指针？？？
}
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://s2.loli.net/2022/06/24/hV6orYOmebDRyJG.png" alt="image-20220624232337311" loading="lazy"></figure>
<p>太迷了吧，怎么数组和指针还能这样混着用呢？我们先来看看数组在内存中是如何存放的：</p>
<figure data-type="image" tabindex="24"><img src="https://s2.loli.net/2022/06/24/ij6eKTYqDSxL7tE.png" alt="image-20220624233249216" loading="lazy"></figure>
<p>数组在内存中是一块连续的空间，所以为什么声明数组一定要明确类型和大小，因为这一块连续的内存空间生成后就固定了。</p>
<p>而我们的数组变量实际上存放的就是首元素的地址，而实际上我们之前一直使用的都是<strong>数组表示法</strong>来操作数组，这样可以很方便地让我们对内存中的各个元素值进行操作：</p>
<pre><code class="language-c">int main(){
    char str[] = &quot;Hello World!&quot;;
    printf(&quot;%c&quot;, str[0]);   //直接在中括号中输入对应的下标就能访问对应位置上的数组了
}
</code></pre>
<p>而我们知道实际上<code>str</code>表示的就是数组的首地址，所以我们完全可以将其赋值给一个指针变量，因为指针变量也是存放的地址：</p>
<pre><code class="language-c">char str[] = &quot;Hello World!&quot;;
char * p = str;   //直接把str代表的首元素地址给到p
</code></pre>
<p>而使用指针后，实际上我们可以使用另一种表示法来操作数组，这种表示法叫做<strong>指针表示法</strong>：</p>
<pre><code class="language-c">int main(){
    char str[] = &quot;Hello World!&quot;;
    char * p = str;

    printf(&quot;第一个元素值为：%c，第二个元素值为：%c&quot;, *p, *(p+1));   //通过指针也可以表示对应位置上的值
}
</code></pre>
<p>比如我们现在需要表示数组中的第二个元素：</p>
<ul>
<li>数组表示法：<code>str[1]</code></li>
<li>指针表示法：<code>*(p+1)</code></li>
</ul>
<p>虽然写法不同，但是他们表示的意义是完全相同的，都代表了数组中的第二个元素，其中指针表示法使用了<code>p+1</code>的形式表示第二个元素，这里的<code>+1</code>操作并不是让地址+1，而是让地址<code>+ 一倍的对应类型大小</code>，也就是说地址后移一个char的长度，所以正好指向了第二个元素，然后通过<code>*</code>取到对应的值（注意这种操作仅对数组是有意义的，如果是普通的变量，虽然也可以通过这种方式获得后一个char的长度的数据，但是毫无意义）</p>
<pre><code class="language-c">*(p+i)   &lt;=&gt;    str[i]    //实际上就是可以相互转换的
</code></pre>
<p>这两种表示法都可以对内存中存放的数组内容进行操作，只是写法不同罢了，所以你会看到数组和指针混用也就不奇怪了。了解了这些东西之后，我们来看看下面的各个表达式分别代表什么：</p>
<pre><code class="language-c">*p   //数组的第一个元素
p   //数组的第一个元素的地址
p == str   //肯定是真，因为都是数组首元素地址
*str    //因为str就是首元素的地址，所以这里对地址加*就代表第一个元素，使用的是指针表示法
&amp;str[0]   //这里得到的实际上还是首元素的地址
*(p + 1)   //代表第二个元素
p + 1    //第二个元素的内存地址
*p + 1    //注意*的优先级比+要高，所以这里代表的是首元素的值+1，得到字符'K'
</code></pre>
<p>所以不难理解，为什么<code>printf</code>函数的参数是一个<code>const char * </code>了，实际上就是需要我们传入一个字符串而已，只不过这里采用的是指针表示法而已。</p>
<p>当然指针也可以进行自增和自减操作，比如：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    char str[] = &quot;Hello World!&quot;;
    char * p = str;

    p++;  //自增后相当于指针指向了第二个元素的地址

    printf(&quot;%c&quot;, *p);   //所以这里打印的就是第二个元素的值了
}
</code></pre>
<p>一维数组看完了，我们来看看二维数组，那么二维数组在内存中是如何表示的呢？</p>
<pre><code class="language-c">int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
</code></pre>
<p>这是一个2x3的二维数组，其中存放了两个能够容纳三个元素的数组，在内存中，是这样的：</p>
<figure data-type="image" tabindex="25"><img src="https://s2.loli.net/2022/06/25/nEOomiYuMI7UWNy.png" alt="image-20220625113701632" loading="lazy"></figure>
<p>所以虽然我们可以使用二维数组的语法来访问这些元素，但其实我们也可以使用指针来进行访问：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    int arr[][3] = {{1, 2, 3}, {4, 5, 6}};
    int * p = arr[0];  //因为是二维数组，注意这里要指向第一个元素，来降一个维度才能正确给到指针
    //同理如果这里是arr[1]的话那么就表示指向二维数组中第二个数组的首元素
    printf(&quot;%d = %d&quot;, *(p + 4), arr[1][1]);   //实际上这两种访问形式都是一样的
}
</code></pre>
<h3 id="多级指针">多级指针</h3>
<p>我们知道，实际上指针本身也是一个变量，它存放的是目标的地址，但是它本身作为一个变量，它也要将地址信息保存到内存中，所以，实际上当我们有指针之后：</p>
<figure data-type="image" tabindex="26"><img src="https://s2.loli.net/2022/06/25/NLyVRJU8OmYBTlM.png" alt="image-20220625105757445" loading="lazy"></figure>
<p>实际上，我们我们还可以继续创建一个指向指针变量地址的指针，甚至可以创建更多级（比如指向指针的指针的指针）比如现在我们要创建一个指向指针的指针：</p>
<figure data-type="image" tabindex="27"><img src="https://s2.loli.net/2022/06/25/ISWsVwEDlqLFPbd.png" alt="image-20220625110252586" loading="lazy"></figure>
<p>落实到咱们的代码中：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    int a = 20;
    int * p = &amp;a;   //指向普通变量的指针
    //因为现在要指向一个int *类型的变量，所以类型为int* 再加一个*
    int ** pp = &amp;p;   //指向指针的指针（二级指针）
    int *** ppp = &amp;pp;   //指向指针的指针的指针（三级指针）
}
</code></pre>
<p>那么我们如何访问对应地址上的值呢？</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    int a = 20;
    int * p = &amp;a;
    int ** pp = &amp;p;

    printf(&quot;p = %p, a = %d&quot;, *pp, **pp);  //使用一次*表示二级指针指向的指针变量，继续使用一次*会继续解析成指针变量所指的普通变量
}
</code></pre>
<p>本质其实就是一个套娃而已，只要把各个层次分清楚，实际上还是很好理解的。</p>
<p>**特别提醒：**一级指针可以操作一维数组，那么二级指针是否可以操作二维数组呢？不能！因为二级指针的含义都不一样了，它是表示指针的指针，而不是表示某个元素的指针了。下面我们会认识数组指针，准确的说它才更贴近于二维数组的形式。</p>
<h3 id="指针数组与数组指针">指针数组与数组指针</h3>
<p>前面我们了解了指针的一些基本操作，包括它与数组的一些关系。我们接着来看指针数组和数组指针，这两词语看着就容易搞混，不过哪个词在后面就哪个，我们先来看指针数组，虽然名字很像数组指针，但是它本质上是一个数组，不过这个数组是用于存放指针的数组。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    int a, b, c;
    int * arr[3] = {&amp;a, &amp;b, &amp;c};   //可以看到，实际上本质还是数组，只不过存的都是地址
}
</code></pre>
<p>因为这个数组中全都是指针，比如现在我们想要访问数组中第一个指针指向的地址：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    int a, b, c;
    int * arr[3] = {&amp;a, &amp;b, &amp;c};

    *arr[0] = 999;   //[]运算符的优先级更高，所以这里先通过[0]取出地址，然后再使用*将值赋值到对应的地址上
    printf(&quot;%d&quot;, a);
}
</code></pre>
<p>当然我们也可以用二级指针变量来得到指针数组的首元素地址：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    int * p[3];   //因为数组内全是指针
    int ** pp = p;  //所以可以直接使用指向指针的指针来指向数组中的第一个指针元素
}
</code></pre>
<p>实际上指针数组还是很好理解的，那么数组指针呢？可以看到指针在后，说明本质是一个指针，不过这个指针比较特殊，它是一个指向数组的指针（注意它的目标是整个数组，和我们之前认识的指针不同，之前认识的指针是指向某种类型变量的指针）</p>
<p>比如：</p>
<pre><code class="language-c">int * p;   //指向int类型的指针
</code></pre>
<p>而数组指针则表示指向整个数组：</p>
<pre><code class="language-c">int (*p)[3];   //注意这里需要将*p括起来，因为[]的优先级更高
</code></pre>
<p>注意它的目标是整个数组，而不是普通的指针那样指向的是数组的首个元素：</p>
<pre><code class="language-c">int arr[3] = {111, 222, 333};
int (*p)[3] = &amp;arr;  //直接对整个数组再取一次地址（因为数组指针代表的是整个数组的地址，虽然和普通指针都是指向首元素地址，但是意义不同）
</code></pre>
<p>那么现在已经取到了指向整个数组的指针，该怎么去使用呢？</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
    int arr[3] = {111, 222, 333};
    int (*p)[3] = &amp;arr;  //直接对整个数组再取一次地址

    printf(&quot;%d, %d, %d&quot;, *(*p+0), *(*p+1), *(*p+2));   //要获取数组中的每个元素，稍微有点麻烦
}
</code></pre>
<p>注意此时：</p>
<ul>
<li><code>p</code>代表整个数组的地址</li>
<li><code>*p</code>表示所指向数组中首元素的地址</li>
<li><code>*p+i</code>表示所指向数组中第<code>i</code>个（0开始）元素的地址（实际上这里的*p就是指向首元素的指针）</li>
<li><code>*(*p + i)</code>就是取对应地址上的值了</li>
</ul>
<p>虽然在处理一维数组上感觉有点麻烦，但是它同样也可以处理二维数组：</p>
<pre><code class="language-c">int arr[][3] = {{111, 222, 333}, {444, 555, 666}};
int (*p)[3] = arr;  //二维数组不需要再取地址了，因为现在维度提升，数组指针指向的是二维数组中的其中一个元素（因为元素本身就是一个数组）
</code></pre>
<p>比如现在我们想要访问第一个数组的第二个元素，根据上面p各种情况下的意义：</p>
<pre><code class="language-c">printf(&quot;%d&quot;, *(*p+1));   //因为上面直接指向的就是第一个数组，所以想要获取第一个元素和之前是一模一样的
</code></pre>
<p>那么要是我们现在想要获取第二个数组中的最后一个元素呢？</p>
<pre><code class="language-c">printf(&quot;%d&quot;, *(*(p+1)+2);   //首先*(p+1)为一个整体，表示第二个数组（因为是数组指针，所以这里+1一次性跳一个数组的长度），然后再到外层+2表示数组中的第三个元素，最后再取地址，就是第二个数组的第三个元素了
</code></pre>
<p>当然也可以使用数组表示法：</p>
<pre><code class="language-java">printf(&quot;%d&quot;, p[1][2]);   //好家伙，这不就是二维数组的用法吗，没错，看似很难，你甚至可以认为这两用着是同一个东西
</code></pre>
<h3 id="指针函数与函数指针">指针函数与函数指针</h3>
<p>我们的函数可以返回一个指针类型的结果，这种函数我们就称为<strong>指针函数</strong>。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int * test(int * a){   //函数的返回值类型是int *指针类型的
    return a;
}

int main(){
    int a = 10;
    int * p = test(&amp;a);   //使用指针去接受函数的返回值
    printf(&quot;%d&quot;, *p);
  	printf(&quot;%d&quot;, *test(&amp;a));   //当然也可以直接把间接运算符在函数调用前面表示直接对返回的地址取地址上的值
}
</code></pre>
<p>不过要注意指针函数不要尝试去返回一个局部变量的地址：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int * test(int a){
    int i = a;
    return &amp;i;   //返回局部变量i的地址
}

int main(){
    int * p = test(20);   //连续调用两次test函数
    test(30);

    printf(&quot;%d&quot;, *p);   //最后结果可能并不是我们想的那样
}
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://s2.loli.net/2022/06/25/my89qFcS73J4Hif.png" alt="image-20220625133343155" loading="lazy"></figure>
<p>为什么会这样呢？还记得我们前面说的吗？函数一旦返回，那么其中的局部变量就会全部销毁了，至于这段内存之后又会被怎么去使用，我们也就不得而知了。</p>
<p><em>局部变量其实是存放在栈帧中的，如果前面的选学部分听了之后，你就知道为什么这里得到的是第二次的30了，因为第二次调用的栈帧入栈后就覆盖了这段内存，又因为是同一个函数所以栈帧结构是一样的，最后在同样的位置就存放了新的30这个值。</em></p>
<p>我们接着来看<strong>函数指针</strong>，实际上指针除了指向一个变量之外，也可以指向一个函数，当然函数指针本身还是一个指针，所以依然是用变量表示，但是它代表的是一个函数的地址（编译时系统会为函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址）</p>
<p>我们来看看如何定义：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int sum(int a, int b) {
    return a + b;
}

int main(){
  	//类型 (*指针变量名称)(函数参数...)  //注意一定要把*和指针变量名称括起来，不然优先级不够
    int (*p)(int, int) = sum;
    printf(&quot;%p&quot;, p);
}
</code></pre>
<p>这样我们就拿到了函数的地址，既然拿到函数的地址，那么我们就可以通过函数的指针调用这个函数了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int sum(int a, int b) {
    return a + b;
}

int main(){
    int (*p)(int, int) = sum;

    int result = (*p)(1, 2);   //就像我们正常使用函数那样，(*p)表示这个函数，后面依然是在小括号里面填上实参
  	int result = p(1, 2);  //当然也可以直接写函数指针变量名称，效果一样（咋感觉就是给函数换了个名呢）
    printf(&quot;%d&quot;, result);
}
</code></pre>
<p>有了函数指针，我们就可以编写函数回调了（所谓回调就让别人去调用我们提供的函数，而不是我们主动来调别人的函数），比如现在我们定义了一个函数，不过这个函数需要参数通过一个处理的逻辑才能正常运行：</p>
<pre><code class="language-c">int sum(int (*p)(int, int), int a, int b){  //将函数指针作为参数传入
  	//函数回调
    return p(a, b);    //就像你进了公司然后花钱请别人帮你写代码，工资咱们五五开，属于是直接让别人帮你实现
}
</code></pre>
<p>于是我们就还要给他一个其他函数的地址：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int sum(int (*p)(int, int), int a, int b){
    return p(a, b);
}

int sumImpl(int a, int b){   //这个函数实现了a + b
    return a + b;
}

int main(){
    int (*p)(int, int) = sumImpl;  //拿到实现那个函数的地址
    printf(&quot;%d&quot;, sum(p, 10, 20));  
}
</code></pre>
<p>当然，函数指针也可以保存一组函数的地址，成为函数指针数组，但是这里就不多说了，相信各位已经快顶不住了吧。</p>
<h3 id="实战合并两个有序数组">实战：合并两个有序数组</h3>
<p><strong>来源：力扣 No.88 合并两个有序数组</strong>：https://leetcode.cn/problems/merge-sorted-array/</p>
<p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<blockquote>
<p>示例 1：</p>
<p>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>
输出：[1,2,2,3,5,6]<br>
解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</p>
<p>示例 2：</p>
<p>输入：nums1 = [1], m = 1, nums2 = [], n = 0<br>
输出：[1]<br>
解释：需要合并 [1] 和 [] 。<br>
合并结果是 [1] 。</p>
<p>示例 3：</p>
<p>输入：nums1 = [0], m = 0, nums2 = [1], n = 1<br>
输出：[1]<br>
解释：需要合并的数组是 [] 和 [1] 。<br>
合并结果是 [1] 。<br>
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</p>
</blockquote>
<p>现在请你设计一个C语言程序，实现下面的函数（要求全程使用指针，不允许出现数组用法）：</p>
<pre><code class="language-c">void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){

}
</code></pre>
<h3 id="实战二维数组中的查找">实战：二维数组中的查找</h3>
<p><strong>来源：剑指Offer 04. 二维数组中的查找</strong>：https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</p>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<blockquote>
<p>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<p>[<br>
[1,   4,  7, 11, 15],<br>
[2,   5,  8, 12, 19],<br>
[3,   6,  9, 16, 22],<br>
[10, 13, 14, 17, 24],<br>
[18, 21, 23, 26, 30]<br>
]</p>
<p>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
</blockquote>
<p>现在请你设计一个C语言程序，实现下面的函数（要求全程使用指针，不允许出现数组用法）：</p>
<pre><code class="language-c">/*
 * 输入 **matrix 是长度为 matrixSize 的数组指针的数组，其中每个元素（也是一个数组）
 * 的长度组成 *matrixColSize 数组作为另一输入，*matrixColSize 数组的长度也为 matrixSize
 */
bool findNumberIn2DArray(int** matrix, int matrixSize, int* matrixColSize, int target){

}
</code></pre>
<hr>
<h2 id="结构体-联合体和枚举">结构体、联合体和枚举</h2>
<p>终于熬过了最难的一个部分，后面的内容就相对简单多了，我们接着来看结构体。</p>
<p>我们之前认识过很多种数据类型，包括整数、小数、字符、数组等，通过使用对应的数据类型，我们就可以很轻松地将我们的数据进行保存了，但是有些时候，这种简单类型很难去表示一些复杂结构。</p>
<h3 id="创建和使用结构体">创建和使用结构体</h3>
<p>比如现在我们要保存100个学生的信息（学生信息包括学号、姓名、年龄）我们发现似乎找不到一种数据类型能够同时保存这三种数据（数组虽然能保存一些列的元素，但是只能保存同种类型的）。但是如果把它们拆开单独存在，就可以使用对应的类型存放了，不过这样也太不方便了吧，这些数据应该是捆绑在一起的，而不是单独地去存放。所以，为了解决这种问题，C语言提供了结构体类型，它能够将多种类型的数据集结到一起，让他们形成一个整体。</p>
<pre><code class="language-c">struct Student {   //使用 (struct关键字 + 结构体类型名称) 来声明结构体类型，这种类型是我们自己创建的（同样也可以作为函数的参数、返回值之类的）
    int id;    //结构体中可以包含多个不同类型的数据，这些数据共同组成了整个结构体类型（当然结构体内部也能包含结构体类型的变量）
    int age;
    char * name;   //用户名可以用指针指向一个字符串，也可以用char数组来存，如果是指针的话，那么数据不会存在结构体中，只会存放字符串的地址，但是如果是数组的话，数据会存放在结构体中
};
</code></pre>
<pre><code class="language-c">int main() {
    struct Student {   //也可以以局部形式存在
        
    };
}
</code></pre>
<p>定义好结构体后，我们只需要使用结构体名称作为类型就可以创建一个结构体变量了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct Student {
    int id;
    int age;
    char * name;
};

int main() {
  	//类型需要写为struct Student，后面就是变量名称
    struct Student s = {1, 18, &quot;小明&quot;};     //结构体包含多种类型的数据（它们是一个整体），只需要把这些数据依次写好放在花括号里面就行了
}
</code></pre>
<pre><code class="language-c">struct Student {
    int id;
    int age;
    char * name;
} s;  //也可以直接在花括号后面写上变量名称（多个用逗号隔开），声明一个全局变量
</code></pre>
<p>这样我们就创建好了一个结构体变量，而这个结构体表示的就是学号为1、年龄18、名称为小明的结构体数据了。</p>
<p>当然，结构体的初始化需要注意：</p>
<pre><code class="language-c">struct Student s = {1, 18};   //如果只写一半，那么只会初始化其中一部分数据，剩余的内容相当于没有初始值，跟数组是一样的
struct Student s = {1, .name = &quot;小红&quot;};   //也可以指定去初始化哪一个属性 .变量名称 = 初始值
</code></pre>
<p>那么现在我们拿到结构体变量之后，怎么去访问结构体内部存储的各种数据呢？</p>
<pre><code class="language-c">printf(&quot;id = %d, age = %d, name = %s&quot;, s.id, s.age, s.name);  //结构体变量.数据名称 (这里.也是一种运算符) 就可以访问结构体中存放的对应的数据了
</code></pre>
<p>是不是很简单？当然我们也可以通过同样的方式对结构体中的数据进行修改：</p>
<pre><code class="language-C">int main() {
    struct Student s = {1, 18, &quot;小明&quot;};

    s.name = &quot;小红&quot;;
  	s.age = 17;

    printf(&quot;id = %d, age = %d, name = %s&quot;, s.id, s.age, s.name);
}
</code></pre>
<p>那么结构体在内存中占据的大小是如何计算的呢？比如下面的这个结构体</p>
<pre><code class="language-c">struct Object {
    int a;
    short b;
    char c;
};
</code></pre>
<p>这里我们可以借助<code>sizeof</code>关键字来帮助我们计算：</p>
<pre><code class="language-c">int main() {
    printf(&quot;int类型的大小是：%lu&quot;, sizeof(int));  //sizeof能够计算数据在内存中所占据的空间大小（字节为单位）
}
</code></pre>
<figure data-type="image" tabindex="29"><img src="https://s2.loli.net/2022/06/25/GvmlqIwNQn6Eszo.png" alt="image-20220625220121753" loading="lazy"></figure>
<p>当然也可以计算变量的值占据的大小：</p>
<pre><code class="language-c">int main() {
    int arr[10];
    printf(&quot;int arr[10]占据的大小是：%lu&quot;, sizeof (arr)); //在判断非类型时，sizeof 括号可省
}
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://s2.loli.net/2022/06/25/yogRvUqtucjkYa7.png" alt="image-20220625220323403" loading="lazy"></figure>
<p>同样的，它也能计算我们的结构体类型会占用多少的空间：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct Object {
  	char a;
    int b;
    short c;
};

int main() {
    printf(&quot;%lu&quot;, sizeof(struct Object));   //直接填入struct Object作为类型
}
</code></pre>
<figure data-type="image" tabindex="31"><img src="https://s2.loli.net/2022/06/25/evxSWPQGMZgEoaA.png" alt="image-20220625223336229" loading="lazy"></figure>
<p>可以看到结果是8，那么，这个8字节是咋算出来的呢？</p>
<blockquote>
<p>int（4字节）+ short（2字节）+ char（1字节） =  7字节（这咋看都算不出来12啊？）</p>
</blockquote>
<p>实际上结构体的大小是遵循下面的规则来进行计算的：</p>
<ul>
<li>结构体中的各个数据要求字节对齐，规则如下：
<ul>
<li>**规则一：**结构体中元素按照定义顺序依次置于内存中，但并不是紧密排列的。从结构体首地址开始依次将元素放入内存时，元素会被放置在其自身对齐大小的整数倍地址上（0默认是所有大小的整数倍）</li>
<li>**规则二：**如果结构体大小不是所有元素中最大对齐大小的整数倍，则结构体对齐到最大元素对齐大小的整数倍，填充空间放置到结构体末尾。</li>
<li>**规则三：**基本数据类型的对齐大小为其自身的大小，结构体数据类型的对齐大小为其元素中最大对齐大小元素的对齐大小。</li>
</ul>
</li>
</ul>
<p>这里我们以下面的为例：</p>
<pre><code class="language-c">struct Object {
  	char a;   //char占据1个字节
    int b;   //int占据4个字节，因为前面存了一个char，按理说应该从第2个字节开始存放，但是根据规则一，必须在自己的整数倍位置上存放，所以2不是4的整数倍位置，这时离1最近的下一个整数倍地址就是4了，所以前面空3个字节的位置出来，然后再放置
    short c; //前面存完int之后，就是从8开始了，刚好满足short（2字节）的整数倍，但是根据规则二，整个结构体大小必须是最大对齐大小的整数倍（这里最大对齐大小是int，所以是4），存完short之后，只有10个字节，所以屁股后面再补两个空字节，这样就可以了
};
</code></pre>
<figure data-type="image" tabindex="32"><img src="https://s2.loli.net/2022/06/25/gpPDKMLw7z3GBOC.png" alt="image-20220625224302673" loading="lazy"></figure>
<p>这样，就不难得出为什么结构体的大小是12了。</p>
<h3 id="结构体数组和指针">结构体数组和指针</h3>
<p>前面我们介绍了结构体，现在我们可以将各种类型的数据全部安排到结构体中一起存放了。</p>
<p>不过仅仅只是使用结构体，还不够，我们可能需要保存很多个学生的信息，所以我们需要使用结构体类型的数组来进行保存：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct Student {
    int id;
    int age;
    char * name;
};

int main() {
    struct Student arr[3] = {{1, 18, &quot;小明&quot;},   //声明一个结构体类型的数组，其实和基本类型声明数组是一样的
                             {2, 17, &quot;小红&quot;},   //多个结构体数据用逗号隔开
                             {3, 18, &quot;小刚&quot;}};
}
</code></pre>
<p>那么现在如果我们想要访问数组中第二个结构体的名称属性，该怎么做呢？</p>
<pre><code class="language-c">int main() {
    struct Student arr[3] = {{1, 18, &quot;小明&quot;},
                             {2, 17, &quot;小红&quot;},
                             {3, 18, &quot;小刚&quot;}};

    printf(&quot;%s&quot;, arr[1].name);   //先通过arr[1]拿到第二个结构体，然后再通过同样的方式 .数据名称 就可以拿到对应的值了
}
</code></pre>
<p>当然，除了数组之外，我们可以创建一个指向结构体的指针。</p>
<pre><code class="language-c">int main() {
    struct Student student = {1, 18, &quot;小明&quot;};
    struct Student * p = &amp;student;   //同样的，类型后面加上*就是一个结构体类型的指针了
}
</code></pre>
<p>我们拿到结构体类型的指针后，实际上指向的就是结构体对应的内存地址，和之前一样，我们也可以通过地址去访问结构体中的数据：</p>
<pre><code class="language-c">int main() {
    struct Student student = {1, 18, &quot;小明&quot;};
    struct Student * p = &amp;student;

    printf(&quot;%s&quot;, (*p).name);  //由于.运算符优先级更高，所以需要先使用*p得到地址上的值，然后再去访问对应数据
}
</code></pre>
<p>不过这样写起来太累了，我们可以使用简便写法：</p>
<pre><code class="language-c">printf(&quot;%s&quot;, p-&gt;name);   //使用 -&gt; 运算符来快速将指针所指结构体的对应数据取出
</code></pre>
<p>我们来看看结构体作为参数在函数之间进行传递时会经历什么：</p>
<pre><code class="language-c">void test(struct Student student){
    student.age = 19;   //我们对传入的结构体中的年龄进行修改
}

int main() {
    struct Student student = {1, 18, &quot;小明&quot;};
    test(student);
    printf(&quot;%d&quot;, student.age);  //最后会是修改后的值吗？
}
</code></pre>
<figure data-type="image" tabindex="33"><img src="https://s2.loli.net/2022/06/25/bAghYZQ9JtEfIud.png" alt="image-20220625232218359" loading="lazy"></figure>
<p>可以看到在其他函数中对结构体内容的修改并没有对外面的结构体生效，因此，实际上结构体也是值传递。我们修改的只是另一个函数中的局部变量而已。</p>
<p>所以如果我们需要再另一个函数中处理外部的结构体，需要传递指针：</p>
<pre><code class="language-c">void test(struct Student * student){   //这里使用指针，那么现在就可以指向外部的结构体了
    student-&gt;age = 19;   //别忘了指针怎么访问结构体内部数据的
}

int main() {
    struct Student student = {1, 18, &quot;小明&quot;};
    test(&amp;student);   //传递结构体的地址过去
    printf(&quot;%d&quot;, student.age);
}
</code></pre>
<figure data-type="image" tabindex="34"><img src="https://s2.loli.net/2022/06/25/km5Ov62CUJa7ITM.png" alt="image-20220625232826388" loading="lazy"></figure>
<p>当然一般情况下推荐传递结构体的指针，而不是直接进行值传递，因为如果结构体非常大的话，光是数据拷贝就需要花费很大的精力，并且某些情况下我们可能根本用不到结构体中的所有数据，所以完全没必要浪费空间，使用指针反而是一种更好的方式。</p>
<h3 id="联合体">联合体</h3>
<p>联合体也可以在内部定义很多种类型的变量，但是它与结构体不同的是，所以的变量共用同一个空间。？？？？啥意思？</p>
<pre><code class="language-c">union Object {   //定义一个联合体类型唯一不同的就是前面的union了
    int a;
    char b;
    float c;
};
</code></pre>
<p>我们来看看一个神奇的现象：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

union Object {
    int a;
    char b;
    float c;
};

int main() {
    union Object object;
    object.a = 66;   //先给a赋值66
    printf(&quot;%d&quot;, object.b);   //访问b
}
</code></pre>
<figure data-type="image" tabindex="35"><img src="https://s2.loli.net/2022/06/25/y6gXHTaeBODFsYP.png" alt="image-20220625234018499" loading="lazy"></figure>
<p>？？？？</p>
<p>我修改的是a啊，怎么b也变成66了？这是因为它们共用了内存空间，实际上我们先将a修改为66，那么就将这段内存空间上的值修改为了66，因为内存空间共用，所以当读取b时，也会从这段内存空间中读取一个char长度的数据出来，所以得到的也是66。</p>
<pre><code class="language-c">int main() {
    union Object object;
    object.a = 128;
    printf(&quot;%d&quot;, object.b);
}
</code></pre>
<figure data-type="image" tabindex="36"><img src="https://s2.loli.net/2022/06/25/hGDKQgMclqrZwIY.png" alt="image-20220625234747277" loading="lazy"></figure>
<p>因为：128 = 10000000，所以用char读取后，由于第一位是符号位，于是就变成了-128。</p>
<p>那么联合体的大小又是如何决定的呢？</p>
<pre><code class="language-c">union Object {
    int a;
    char b;
    float c;
};

int main() {
    printf(&quot;%lu&quot;, sizeof(union Object));
}
</code></pre>
<figure data-type="image" tabindex="37"><img src="https://s2.loli.net/2022/06/25/ehHpAXPfYwZ7yBN.png" alt="image-20220625234931303" loading="lazy"></figure>
<p>实际上，联合体的大小至少是其内部最大类型的大小，这里是int所以就是4，当然，当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。</p>
<p>当然联合体的其他使用基本与结构体差不多，这里就不提了。</p>
<h3 id="枚举">枚举</h3>
<p>最后我们来看一下枚举类型，枚举类型一般用于表示一些预设好的整数常量，比如我们风扇有低、中、高三个档位，我们总是希望别人使用我们预设好的这三个档位，而不希望使用其他的档位，因为我们风扇就只设计了这三个档位。</p>
<p>这时我们就可以告诉别人，我们的风扇有哪几个档位，这种情况使用枚举就非常适合。在我们的程序中，只能使用基本数据类型对这三种档位进行区分，这样显然可读性不够，别人怎么知道哪个代表哪个档位呢？而使用枚举就没有这些问题了：</p>
<pre><code class="language-c">/**
 * 比如现在我们设计：
 * 1 = 低档位
 * 2 = 中档位
 * 3 = 高档位
 */
enum status {low = 1, middle = 2, high = 3};   //enum 枚举类型名称 {枚举 = 初始值, 枚举...}
</code></pre>
<p>我们可以创建多个自定义名称的枚举，命名规则和变量差不多。我们可以当每一个枚举对应一个整数值，这样的话，我们就不需要去记忆每个数值代表的是什么档位了，我们可以直接根据枚举的名称来进行分辨，是不是很方便？</p>
<p>使用枚举也非常地方便：</p>
<pre><code class="language-c">enum status {low = 1, middle = 2, high = 3};

int main() {
    enum status a = low;   //和之前一样，直接定义即可，类型为enum + 枚举名称，后面是变量名称，值可以直接写对应的枚举
    printf(&quot;%d&quot;, a);
}
</code></pre>
<pre><code class="language-c">int main() {
    enum status a = high;
    if(a == low) {   //判断起来就方便多了
        printf(&quot;低档位&quot;);
    } else if (a == high){
        printf(&quot;高档位&quot;);
    } else {
        printf(&quot;中档位&quot;);
    }
}
</code></pre>
<p>当然也可以直接加入到<code>switch</code>语句中：</p>
<pre><code class="language-c">int main() {
    enum status a = high;
    switch (a) {
        case low:
        case high:
        case middle:
        default: ;
    }
}
</code></pre>
<p>不过在枚举变量定义时需要注意：</p>
<pre><code class="language-c">enum status {low, middle, high};   //如果不给初始值的话，那么会从第一个枚举开始，默认值为0，后续依次+1
</code></pre>
<p>所以这里的low就是0，middle就是1，high就是2了。</p>
<p>如果中途设定呢？</p>
<pre><code class="language-c">enum status {low, middle = 6, high};   //这里我们给middle设定为6
</code></pre>
<p>这时low由于是第一个，所以还是从0开始，不过middle这里已经指定为6了，所以紧跟着的high初始值就是middle的值+1了，因此low现在是0，middle就是6，high就是7了。</p>
<h3 id="typedef关键字">typedef关键字</h3>
<p>这里最后还要提一下typedef关键字，这个关键字用于给指定的类型起别名。怎么个玩法呢？</p>
<pre><code class="language-c">typedef int lbwnb;   //食用方式：typedef 类型名称 自定义类型别名
</code></pre>
<p>比如这里我们给int起了一个别名，那么现在我们不仅可以使用int来表示一个int整数，而且也可以使用别名作为类型名称了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef int lbwnb;

int main() {
    lbwnb i = 666;   //类型名称直接写成别名，实际上本质还是int
    printf(&quot;%d&quot;, i);
}
</code></pre>
<pre><code class="language-c">typedef const char * String;   //const char * 我们就起个名称为String表示字符串

int main() {
    String str = &quot;Hello World!&quot;;  //是不是有Java那味了
    printf(str);
}
</code></pre>
<p>当然除了这种基本类型之外，包括指针、结构体、联合体、枚举等等都可以使用这个关键字来完全起别名操作：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef struct test {
    int age;
    char name[10];
} Student;   //为了方便可以直接写到后面，当然也可以像上面一样单独声明

int main() {
    Student student = {18, &quot;小明&quot;};   //直接使用别名，甚至struct关键字都不用加了
}
</code></pre>
<p>在数据结构的学习总，typedef使用会更加地频繁。</p>
<hr>
<h2 id="预处理">预处理</h2>
<p>虽然我们的C语言学习已经快要接近尾声了，但是有一个东西迟迟还没有介绍，就是我们一直在写的：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
</code></pre>
<p>这到底是个什么东西，为什么每次都要加上呢？这一部分，我们将详细讨论它缘由。</p>
<p><code>#include</code>实际上是一种预处理指令，在我们的程序运行之前，会有一个叫做&quot;C预处理器&quot;的东西，根据我们程序中的预处理指令，预处理器能把对应的指令替换为指令想要表示的内容。我们先来看看<code>#include</code>做了什么。</p>
<h3 id="文件包含">文件包含</h3>
<p>当预处理器发现<code>#include</code>指令时，会查看后面的文件名并把文件的内容包含到当前文件中，来替换掉<code>#include</code>指令。比如：</p>
<pre><code class="language-c">int main() {
    printf(&quot;Hello World!&quot;);   //一个很普通的printf打印函数
}
</code></pre>
<p>我们说了，这个函数是由系统为我们提供的函数，实际上这个函数实在其他源文件中定义好的，而定义这个函数的源文件，就是<code>stdio.h</code>，我们可以点进去看看：</p>
<figure data-type="image" tabindex="38"><img src="https://s2.loli.net/2022/06/26/OCd6iGrXkuZslpQ.png" alt="image-20220626131600936" loading="lazy"></figure>
<p>除了<code>printf</code>之外，我们看到还有很多很多的函数原型定义，他们都写到这个源文件中，而这个文件并不是以<code>.c</code>结尾的，而是以<code>.h</code>结尾的，这种文件我们称为<strong>头文件</strong>。头文件一般仅包含定义一类的简单信息，只要能让编译器认识就行了。</p>
<p>而<code>#include</code>则是将这些头文件中提供的信息包含到我们的C语言源文件中，这样我们才能使用定义好的<code>printf</code>函数，如果我们不添加这个指令的话，那么会：</p>
<figure data-type="image" tabindex="39"><img src="https://s2.loli.net/2022/06/26/injLFga1oDvurJG.png" alt="image-20220626132927056" loading="lazy"></figure>
<p>直接不认识了，<code>printf</code>是啥，好吃吗？说白了就是，我们如果不告诉编译器我们的这个函数是从哪来的，它怎么知道这个函数的具体定义什么是，程序又该怎么执行呢？</p>
<p><code>#include</code>的具体使用格式如下：</p>
<pre><code class="language-c">#include &lt;文件名称&gt;
</code></pre>
<p>当然也可以写成：</p>
<pre><code>#include &quot;文件名称&quot;
</code></pre>
<p>这两种写法虽然都能引入头文件，但是区别还是有的：</p>
<ul>
<li>**尖括号：**引用的是编译器的库路径里面的头文件。</li>
<li>**双引号：**引用的是程序目录中相对路径中的头文件，如果找不到再去上面的库里面找。</li>
</ul>
<figure data-type="image" tabindex="40"><img src="https://s2.loli.net/2022/06/26/IDFk4TvXq62g7Y8.png" alt="image-20220626133419361" loading="lazy"></figure>
<p>可以看到系统已经为我们提供好了多种多样的头文件了，通过这些系统提供的库，我们就可以做很多的事情了。</p>
<p>当然我们也可以自己编写一个头文件，直接在项目根目录下创建一个新的C/C++头文件：</p>
<pre><code class="language-c">//
// Created by Nago Coler on 2023/6/26.
//

#ifndef UNTITLED_TEST_H
#define UNTITLED_TEST_H

#endif //UNTITLED_TEST_H
</code></pre>
<p>可以看到系统自动为我们生成好了这些内容，只不过现在还没学到（后面会介绍），现在直接删掉：</p>
<pre><code class="language-c">int test(int a, int b);
</code></pre>
<p>我们直接在头文件中随便声明一个函数原型，接着我们就可以引入这个头文件了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;test.h&quot;   //因为是我们自己项目目录中的，所以需要使用双引号

int main() {
    int c = test(1, 2);   //这样就可以使用头文件中声明的函数了
}
</code></pre>
<p>通过导入头文件，我们就可以使用定义好的各种内容了，当然，不仅仅局限于函数。</p>
<p>不过现在还没办法执行，因为我们这里只是引入了头文件中定义的函数原型，具体的函数实现我们一般还是使用<code>.c</code>源代码文件去进行编写，这里我们创建一个同名的C源文件（不强制要求同名，但是这样看着整齐一点）去实现一下：</p>
<pre><code class="language-c">#include &quot;test.h&quot;  //这里也需要把定义引入

int test(int a, int b) {   //编写函数具体实现
    return a + b;
}
</code></pre>
<p>这样，我们再次运行程序就可以正确得到结果了：</p>
<figure data-type="image" tabindex="41"><img src="https://s2.loli.net/2022/06/26/L1z3sAJxWNIcQ7m.png" alt="image-20220626135746834" loading="lazy"></figure>
<p>实际上预处理器正是通过头文件得到编译代码时所需的一些信息，然后才能把我们程序需要的内容（比如这里要用到的test函数）替换到我们的源文件中，最后才能正确编译为可执行程序。</p>
<p>比如现在我们要做一个学生管理库，这个库中提供了学生结构体的定义，以及对学生信息相关操作：</p>
<pre><code class="language-c">struct stu {   //学生结构体定义
    int id;
    int age;
    char name[20];
} typedef Student;

void print(Student * student);   //打印学生信息
void modifyAge(Student * student, int newAge);   //修改年龄 
void modifyId(Student * student, int newId);   //修改学号
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;    //函数具体实现源文件
#include &quot;student.h&quot;

void print(Student * student) {
    printf(&quot;ID: %d, 姓名: %s, 年龄: %d岁\n&quot;, student-&gt;id, student-&gt;name, student-&gt;age);
}

void modifyAge(Student * student, int newAge) {
    student-&gt;age = newAge;
}

void modifyId(Student * student, int newId) {
    student-&gt;id = newId;
}
</code></pre>
<p>最后我们就可以愉快地使用了：</p>
<pre><code class="language-c">#include &quot;student.h&quot;

int main() {
    Student student = {1, 18, &quot;小明&quot;};
    modifyAge(&amp;student, 19);
    print(&amp;student);   //打印
}
</code></pre>
<p>通过使用<code>#include</code>我们就可以将我们的项目拆分成多个模块去进行编写了。</p>
<h3 id="系统库介绍">系统库介绍</h3>
<p>前面我们了解了如何使用<code>#include</code>引入其他文件，我们接着来了解一下系统为我们提供的一些常用库。实际上我们已经用过不少官方库提供的内容了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a;
    scanf(&quot;%d&quot;, &amp;a);
    printf(&quot;%d&quot;, a);
    getchar();
    putchar('A');
    ...
}
</code></pre>
<p>包括前面我们在实战中用到了一次<code>string.h</code>中提供的计算字符串长度的函数：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char * c = &quot;Hello World!&quot;;
    printf(&quot;%lu&quot;, strlen(c));   //使用strlen计算长度，注意返回值类型是size_t（别名而已，本质上就是unsigned long）
}
</code></pre>
<p>当然除了这个函数之外，实际上还有很多实用的字符串处理函数，都在这里定义了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char a[20] = &quot;Hello&quot;,* b = &quot;World!&quot;;   //现在有两个字符串，但是我们希望把他们拼接到一起
  	//注意不能这样写 char * a = &quot;Hello&quot;,* b = &quot;World!&quot;; 如果直接用指针指向字符串常量，是无法进行拼接的，因为大小已经固定了
  	//这里需要两个参数，第一个是目标字符串，一会会将第二个参数的字符串拼接到第一个字符串中（注意要装得下才行）
    strcat(a, b);
    printf(&quot;%s&quot;, a);
}
</code></pre>
<pre><code class="language-c">int main() {
    char str[10], * c = &quot;Hello&quot;;
    strcpy(str, c);   //使用cpy会直接将后面的字符串拷贝到前面的字符串数组中（同样需要前面装得下才行）
    printf(&quot;%s&quot;, str);
}
</code></pre>
<pre><code class="language-c">int main() {
    char * a = &quot;AAA&quot;, * b = &quot;AAB&quot;;
    int value = strcmp(a, b);   //strcmp会比较两个字符串，并返回结果
    printf(&quot;%d&quot;, value);
}
</code></pre>
<p>这里需要说一下的比较规则：把字符串str1和str2从首字符开始逐个字符的进行比较，直到某个字符不相同或者其中一个字符串比较完毕才停止比较，字符的比较按照ASCII码的大小进行判断。</p>
<p>比较完成后，会返回不匹配的两个字符的ASCII码之差：</p>
<figure data-type="image" tabindex="42"><img src="https://s2.loli.net/2022/06/26/3QXnw4jCflyziR5.png" alt="image-20220626151419133" loading="lazy"></figure>
<p>我们接着来看用于处理数学问题的相关库：</p>
<pre><code class="language-c">#include &lt;math.h&gt;
</code></pre>
<p>这里要用到<code>math.h</code>，它提供了我们场景的数学计算函数，比如求算术平方根、三角函数、对数等。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int a = 2;
    double d = sqrt(a);   //使用sqrt可以求出非负数的算术平方根（底层采用牛顿逼近法计算）
    printf(&quot;%lf&quot;, d);
}
</code></pre>
<figure data-type="image" tabindex="43"><img src="https://s2.loli.net/2022/06/26/m6HWZqA4XCDvf3j.png" alt="image-20220626152208591" loading="lazy"></figure>
<p>当然能够开根，也可以做乘方：</p>
<pre><code class="language-c">int main() {
    int a = 2;
    double d = pow(a, 3);   //使用pow可以快速计算乘方，这里求的是a的3次方
    printf(&quot;%lf&quot;, d);
}
</code></pre>
<p>有了这个函数，写个水仙花数更简单了：</p>
<pre><code class="language-c">int main() {
    for (int i = 0; i &lt; 1000; ++i) {
        int a = i % 10, b = i / 10 % 10, c = i / 10 / 10;
        if(pow(a, 3) + pow(b, 3) + pow(c, 3) == i) {
            printf(&quot;%d 是水仙花数！\n&quot;, i);
        }
    }
}
</code></pre>
<p>当然也可以计算三角函数：</p>
<pre><code class="language-c">int main() {
    printf(&quot;%f&quot;, tan(M_PI));   //这里我们使用正切函数计算tan180度的值，注意要填入的是弧度值
    //M_PI也是预先定义好的π的值，非常精确
}
</code></pre>
<p>当然某些没有不存在的数可能算出来会得到一个比较奇怪的结果：</p>
<pre><code class="language-c">int main() {
    printf(&quot;%f&quot;, tan(M_PI / 2));   //这里计算tan90°，我们知道tan90° = sin90°/cos90° = 1/0 不存在
}
</code></pre>
<p>当然还有两个比较常用的函数：</p>
<pre><code class="language-c">int main() {
    double x = 3.14;
    printf(&quot;不小于x的最小整数：%f\n&quot;, ceil(x));
    printf(&quot;不大于x的最大整数：%f\n&quot;, floor(x));
}
</code></pre>
<p>当然也有快速求绝对值的函数：</p>
<pre><code class="language-c">int main() {
    double x = -3.14;
    printf(&quot;x的绝对值是：%f&quot;, fabs(x));
}
</code></pre>
<p>我们最后再来介绍一下通用工具库<code>stdlib</code>，这个库里面为我们提供了大量的工具函数：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    int arr[] = {5, 2, 4, 0, 7, 3, 8, 1, 9, 6};
    //工具库已经为我们提供好了快速排序的实现函数，直接用就完事
    //参数有点多，第一个是待排序数组，第二个是待排序的数量（一开始就是数组长度），第三个是元素大小，第四个是排序规则（我们提供函数实现）
    qsort();
}
</code></pre>
<p>当然在开始使用之前我们还要先补充一点知识，我们发现<code>qsort</code>的原型定义，使用的是void类型的指针。</p>
<p>怎么void还有指针呢？void不是空吗？</p>
<blockquote>
<p>void 指针是一种特殊的指针，表示为“无类型指针”，由于 void 指针没有特定的类型，因此它可以指向任何类型的数据。也就是说，任何类型的指针都可以直接赋值给 void 指针，而无需进行其他相关的强制类型转换。</p>
</blockquote>
<p>所以这里之所以需要void指针，其实就是为了可以填入任何类型的数组，而我们发现第三个参数实际上就是因为是void指针不知道具体给进来的类型是什么，所以需要我们来告诉函数我们使用的类型所占大小是多少。</p>
<p>而最后一个参数实际上就是我们前面介绍的函数回调了，因为函数不知道你的比较规则是什么，是从小到大还是从大到小呢？所以我们需要编写一个函数来对两个待比较的元素进行大小判断。</p>
<p>好了，现在了解了之后，我们就可以开始填入参数了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int compare(const void * a, const void * b) {  //参数为两个待比较的元素，返回值负数表示a比b小，正数表示a比b大，0表示相等
    int * x = (int *) a, * y = (int *) b;   //这里因为判断的是int所以需要先强制类型转换为int *指针
    return *x - *y;   //其实直接返回a - b就完事了，因为如果a比b大的话算出来一定是正数，反之同理
}

int main() {
    int arr[] = {5, 2, 4, 0, 7, 3, 8, 1, 9, 6};
    //工具库已经为我们提供好了快速排序的实现函数，直接用就完事
    //参数有点多，第一个是待排序数组，第二个是待排序的数量（一开始就是数组长度），第三个是元素大小，第四个是排序规则（我们提供函数实现）
    qsort(arr, 10, sizeof(int), compare);

    for (int i = 0; i &lt; 10; ++i) {
        printf(&quot;%d &quot;, arr[i]);
    }
}
</code></pre>
<p>这样，我们就可以对数组进行快速排序了。</p>
<p>当然工具库中还提供了<code>exit</code>函数用于终止程序：</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int main() {
    exit(EXIT_SUCCESS);   //直接终止程序，其中参数是传递给父进程的（但是现在我们只是简单程序）
}
</code></pre>
<p>不过乍一看，貌似和我直接在main里面return没啥区别，反正都会结束。</p>
<p>当然还有两个我们会在后续学习数据结构中用的较多的函数：</p>
<pre><code class="language-c">int main() {
    int * p = (int *) malloc(sizeof(int));   //我们可以使用malloc函数来动态申请一段内存空间
    //申请后会返回申请到的内存空间的首地址
    *p = 128;
    printf(&quot;%d&quot;, *p);
}
</code></pre>
<blockquote>
<p>malloc用于向系统申请分配指定size个字节的内存空间，返回类型是 void * 类型，如果申请成功返回首地址，如果失败返回NULL空地址（比如系统内存不足了就可能会申请失败）</p>
</blockquote>
<p>申请到一段内存空间后，这段内存空间我们就可以往上面随便读写数据了，实际上就是和变量一样，只不过这个内存空间是我们自主申请的，并不是通过创建变量得到的，但是使用上其实没啥大的区别。</p>
<p>不过要注意，这段内存使用完之后记得清理，就像函数执行完会自动销毁其中的局部变量一样，如果不清理那么这段内存会被一直占用：</p>
<pre><code class="language-c">int main() {
    int * p = (int *)malloc(sizeof(int));
    *p = 128;
    printf(&quot;%d&quot;, *p);

    free(p);   //使用free函数对内存空间进行释放，归还给系统，这样这段内存又可以被系统分配给别人用了
  	p = NULL;   //指针也不能再指向那个地址了，因为它已经被释放了
}
</code></pre>
<p>内存资源是很宝贵的（不像硬盘几个T随便用，我们的电脑可能32G的内存都算高配了），不能随便浪费，所以一般情况下malloc和free都是一一对应的，这样才能安全合理地使用内存。</p>
<h3 id="宏定义">宏定义</h3>
<p>我们前面认识了<code>#include</code>指令，我们接着来看<code>#define</code>指令，它可以实现宏定义。我语文不好，宏是啥意思？</p>
<figure data-type="image" tabindex="44"><img src="https://s2.loli.net/2022/06/26/3CHdqbsAji78KwN.png" alt="image-20220626164426525" loading="lazy"></figure>
<blockquote>
<p>把参数批量替换到文本中，这种实现通常称为宏（macro）或定义宏 (define macro)</p>
</blockquote>
<p>我们可以通过<code>#define</code>来定义宏，规则如下：</p>
<pre><code>#define    宏名(记号)    内容
</code></pre>
<p>比如现在我们想通过宏定义一个PI：</p>
<pre><code class="language-c">#define PI 3.1415926
</code></pre>
<p>这样就可以了，那么怎么去使用它呢？</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define PI 3.1415926

int main() {
    printf(&quot;π的值为：%f&quot;, PI);   //就像使用变量一样，我们可以直接将PI放到这个位置
}
</code></pre>
<p>在编译时，预处理程序会进行宏替换操作，也就是将程序中所有的<code>PI</code>全部替换为<code>3.1415926</code>，注意这个跟类型无关，是赤裸裸的纯文本替换，也就是相当于把我们的代码修改了，PI那里直接变成<code>3.1415926</code>，当然如果你定义为其他任意的内容，同样会替换到那个位置，但是至于替换之后程序还正不正常就不知道了。</p>
<p>我们通过下面这个例子来加深对文本替换这句话的理解：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define M a + b

int main() {
    int a = 10, b = 20;
    printf(&quot;%d&quot;, M * a);   //各位觉得计算结果会是多少呢？
}
</code></pre>
<p>如果按照我们的正常思维，M是a+b，那么替换上去之后应该就是30了吧？然后30 x 10最后得到的应该是300才对。</p>
<figure data-type="image" tabindex="45"><img src="https://s2.loli.net/2022/06/26/ZOwauBAUCTscXYK.png" alt="image-20220626165518162" loading="lazy"></figure>
<p>不过最后貌似并不是这样的，怎么会算出来是210的呢？</p>
<p>实际上还是那句话，在编译时仅仅是做了文本替换，相当于最后我们的代码是：</p>
<pre><code class="language-c">printf(&quot;%d&quot;, a + b * a);
</code></pre>
<p>所以先计算的是a x b然后再加a，最后结果就是210了。</p>
<p>当然任何地方都可以使用宏替换，包括类型，反正最后都会变成被替换的内容：</p>
<pre><code class="language-c">#define lbwnb long

int main() {
    lbwnb a = 10L;
}
</code></pre>
<p>当然除了这种简单的替换之外我们还可以添加参数，就像函数那样：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define MUL(x) x * x

int main() {
    printf(&quot;%d&quot;, MUL(9));
}
</code></pre>
<p>虽然这里搞得像函数一样，但是最后还是会被替换为x * x，而这个x就是我们填写的参数，所以最后会变成 9 * 9 替换上去，程序运行出来的结果就是81了。</p>
<p>直接调函数肯定也是没问题的，反正就纯替换：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define bb(i) printf(&quot;我是宏替换的：%d&quot;, i);

int main() {
    bb(666);
}
</code></pre>
<p>那要是我想在字符串里面加一个宏定义中的参数呢？</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define bb(str) printf(&quot;我是宏替换的：&quot;#str&quot; &lt;&quot;);  //使用#直接在字符串中进行宏替换，否则默认情况下会被当做一个字符

int main() {
    bb(&quot;你看这不就替换了吗&quot;);
}
</code></pre>
<p>当然还可以替换宏中的部分：</p>
<pre><code class="language-c">#define TEST(n) x ##n   //##会使用参数进行拼接

int main() {
    int TEST(1) = 10;   //这里传入1，那么实际上就是被替换为x1
    x1 = 20;   //所以上面其实是int x1 = 10
}
</code></pre>
<p>宏既然可以定义出来，那么也可以取消定义，我们可以使用<code>#undef</code>来取消已有的宏定义：</p>
<figure data-type="image" tabindex="46"><img src="https://s2.loli.net/2022/06/26/ZA1j7dE2pKMXuVn.png" alt="image-20220626172208060" loading="lazy"></figure>
<p>可以看到在使用<code>#undef</code>之后，直接不认识了。</p>
<p>当然除了我们自己可以去定义之外，系统也为我们提供了一些预定义的宏：</p>
<table>
<thead>
<tr>
<th>宏名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>_ _ DATE _ _</td>
<td>当前的日期，格式为类似 Jun 27 2023 的字符串</td>
</tr>
<tr>
<td>_ _ TIME _ _</td>
<td>当前的时间，格式为类似 10:23:12 的字符串</td>
</tr>
<tr>
<td>_ _ FILE _ _</td>
<td>当前源代码文件的名称（含路径）的字符串</td>
</tr>
<tr>
<td>_ _ LINE _ _</td>
<td>当前所处的行号是多少就替换为多少，整数</td>
</tr>
</tbody>
</table>
<p>这里只列出了一部分。</p>
<h3 id="条件编译">条件编译</h3>
<p>我们来看看条件编译，我们还可以根据条件，选择性地对某些内容进行忽略。</p>
<p>收我们我们来认识一下<code>#ifdef</code>、<code>#else</code>、<code>#endif</code>这三种条件编译指令：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#ifdef PI   //ifdef用于判断是否定义了符号PI，如果没有的话则处理以下的指令
    #define M 666
#else   //如果定义了符号PI，那么就处理这个分支的语句
    #define M 777
#endif   //最后需要以endif指令结束整个判断

int main() {
    printf(&quot;%d&quot;, M);   //最后打印M
}
</code></pre>
<figure data-type="image" tabindex="47"><img src="https://s2.loli.net/2022/06/26/U7r6g5pB21fISVh.png" alt="image-20220626184356031" loading="lazy"></figure>
<p>可以看到，在我们没有定义PI的情况下，执行的是<code>#define M 777</code>，那要是现在定义了呢？我们编写一个新的头文件：</p>
<pre><code class="language-c">#define PI 3.1415
</code></pre>
<p>现在我们引入这个头文件，那么对应的预编译指令也会跟着包含进来：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;test.h&quot;

#ifdef PI
    #define M 666
#else
    #define M 777
#endif

int main() {
    printf(&quot;%d&quot;, M);
}
</code></pre>
<figure data-type="image" tabindex="48"><img src="https://s2.loli.net/2022/06/26/ojZNauDIb4ckylC.png" alt="image-20220626184248768" loading="lazy"></figure>
<p>可以看到此时得到的结果就是666了，因为现在PI在引入的头文件中已经定义了（当然直接在当前源文件中定义也是一样的）</p>
<p>那如果我现在希望判断某个符号没定义呢？没错，还有<code>#ifndef</code>表示判断是否未定义某个符号：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#ifndef PI   //ifndef 就是 if not define，跟ifdef反着的
    #define M 666
#else
    #define M 777
#endif

int main() {
    printf(&quot;%d&quot;, M);
}
</code></pre>
<figure data-type="image" tabindex="49"><img src="https://s2.loli.net/2022/06/26/br2lo1vj5GPIZig.png" alt="image-20220626184747886" loading="lazy"></figure>
<p>当然，除了判断某个符号是否存在之外，我们也可以像条件语句那样直接进行逻辑判断，这里需要使用到<code>#if</code>和<code>#elif</code>指令：</p>
<pre><code class="language-c">#define M 666

#if M == 666   //若M等于666那么定义K = 999
    #define K 999
#elif M == 777   //等同于else if语句
    #define K 888
#else    //else语句
    #define K 000
#endif
</code></pre>
<p>并且这些分支还支持嵌套使用：</p>
<pre><code class="language-c">#define M 666

#if M == 666
    #ifdef L
        #include &quot;test.h&quot;
    #endif
#elif M == 777
    #define K = 888
#else
    #define K = 000
#endif
</code></pre>
<hr>
<h2 id="文件输入输出选学">文件输入/输出（选学）</h2>
<p>**注意：**本小节作为选学内容，不强制要求。</p>
<p>我们的电脑上其实存放了多种多样的文件，比如我们办公经常需要打交道的Word文档、PPT幻灯片、Excel表格等，包括我们的C程序源文件，图片、视频等等，这些都是文件，由于文件需要被长期保存，所以它们被统一存放到我们电脑上的硬盘中。硬盘不像内存，虽然它们都可以存放数据，但是内存中的数据断电即失（在学习完数字电路中的锁存器后，你就知道为什么了）而硬盘却支持长期保存数据，当然也是以二进制的形式进行保存的。</p>
<h3 id="文本读写操作">文本读写操作</h3>
<p>现代计算机使用的硬盘大致分为固态硬盘和机械硬盘两种，其中固态硬盘的读写速度远超机械硬盘，但是寿命（硬盘是有读写次数限制的，如果读写次数超标，那么就无法使用了）不如机械硬盘，所以一般重要数据都是在机械硬盘中存放，而系统文件一般是在固态硬盘中存放，这样电脑的启动速度会很快。</p>
<p>不过文件并不是随便在硬盘中进行保存的，而是根据不同的文件系统按规则进行存放的，比如Windows下采用的就是NTFS文件系统，而MacOS采用的是APFS文件系统。</p>
<blockquote>
<p>文件系统是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。</p>
</blockquote>
<p>其中某些文件是以文本格式存储的，比如我们的C语言源文件、普通的文本文档等；而有些文件是二进制格式，比如图片、视频、应用程序等，但是他们最终都是以二进制的形式存储到硬盘上的。当然，普通的文本文件我们直接打开记事本都可以直接进行编辑，而图片这类二进制文件，需要使用专门读取图片的软件来查看，根据格式的不同（图片有png、jpg等格式）对文件的解读方式也不一样，但是最后都会被专门的图片查看软件展示出来。</p>
<p>通过使用C语言，我们也可以读取硬盘上的文件，这里我们先创建一个简单的文本文件：</p>
<figure data-type="image" tabindex="50"><img src="https://s2.loli.net/2022/06/28/fcwle59DIBt1WUQ.png" alt="image-20220628112153835" loading="lazy"></figure>
<p>接着我们可以使用stdio.h中为我们提供的函数打开一个文件：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    FILE * file = fopen(&quot;hello.txt&quot;, &quot;rw&quot;);  //使用fopen函数来打开一个文件
}
</code></pre>
<p>这里我们先来介绍一下参数：</p>
<ul>
<li>第一个参数：文件的名称，这里我填写的是相对路径，也可以写成绝对路径</li>
<li>第二个参数：打开文件的模式，其中模式有以下这些：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">模式字符串</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">“r”</td>
<td style="text-align:center">以读模式打开文件</td>
</tr>
<tr>
<td style="text-align:center">“w”</td>
<td style="text-align:center">以写模式打开文件，把现有文件的长度截为0，如果文件不存在，则创建一个新文件</td>
</tr>
<tr>
<td style="text-align:center">“a”</td>
<td style="text-align:center">以写模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创建一个新文件</td>
</tr>
<tr>
<td style="text-align:center">“r+”</td>
<td style="text-align:center">以更新模式打开文件（即可以读写文件）该文件必须存在</td>
</tr>
<tr>
<td style="text-align:center">“w+”</td>
<td style="text-align:center">以更新模式打开文件（即可以读写文件），如果文件存在，则将其长度截为0；如果文件不存在，则创建一个新文件</td>
</tr>
<tr>
<td style="text-align:center">“a+”</td>
<td style="text-align:center">以更新模式打开文件（即，读写），在现有文件的末尾添加内容，如果文件不存在则创建一个新文件；可以读整个文件，但是只能从末尾添加内容</td>
</tr>
<tr>
<td style="text-align:center">“rb”,“wb”,“ab”,“ab+”,“a+b”,“wb+”,“w+b”</td>
<td style="text-align:center">与“a+”模式类似，但是以二进制模式打开文件而不是以文本模式打开文件</td>
</tr>
</tbody>
</table>
<p>具体的不同打开模式会影响到后续的操作，我们后面再说。这里我们使用r表示可读。</p>
<p>然后这个函数返回的是一个FILE结构体指针：</p>
<pre><code class="language-c">typedef struct __sFILE {
   unsigned char *_p; /* current position in (some) buffer */
   int    _r;       /* read space left for getc() */
	 ...
} FILE;
</code></pre>
<p>定义非常复杂，这里我们就不详细介绍了，这样我们就成功打开了这个文件，那么如何对文件进行读取操作呢？</p>
<p>我们可以使用<code>getc</code>来快速读取文件中的字符：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    FILE * file = fopen(&quot;hello.txt&quot;, &quot;r&quot;);
    int c;
    while ((c = getc(file)) != EOF) {   //通过一个while循环来不断读取文件，使用getc从文件中读取一个字符，如果到末尾了，那么会返回一个特殊值EOF
        putchar(c);   //使用putchar来快速打印字符到控制台
    }
}
</code></pre>
<p>可以看到成功输出：</p>
<figure data-type="image" tabindex="51"><img src="https://s2.loli.net/2022/06/28/e1QFxCszVM4BX2f.png" alt="image-20220628135052152" loading="lazy"></figure>
<p>当然如果没有这个文件或是文件打开失败的话，可能会返回一个空指针，所以我们需要进一步判断：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    FILE * file = fopen(&quot;hello.txt&quot;, &quot;r&quot;);
    if(file != NULL) {   //如果打开失败会返回NULL
        int c;
        while ((c = getc(file)) != EOF) {
            putchar(c);
        } 
    } else{
        puts(&quot;文件打开失败！&quot;);
    }
}
</code></pre>
<p>最后我们在使用完文件后，记得关闭文件来释放资源，不然一直会被占用：</p>
<pre><code class="language-c">fclose(file);   //fclose用于关闭文件
</code></pre>
<p>那么读取文件我们知道了，写入呢？写入我们同样可以使用<code>putc</code>来完成：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    FILE * file = fopen(&quot;hello.txt&quot;, &quot;w&quot;);   //注意这里需要修改为写模式
    if(file != NULL) {
        for (int i = 0; i &lt; 10; ++i)
            putc('A' + i, file);   //从A开始依次写入10个字符
        fclose(file);
    } else{
        puts(&quot;文件打开失败！&quot;);
    }
}
</code></pre>
<p>可以看到最后我们的文件变成了：</p>
<figure data-type="image" tabindex="52"><img src="https://s2.loli.net/2022/06/28/e2qC9WvzMlIBubA.png" alt="image-20220628135806896" loading="lazy"></figure>
<p>原来的文本被覆盖为了我们输入的新文本，那要是我们现在不想覆盖原来的，而是希望在后面追加输入呢？</p>
<pre><code class="language-c">FILE * file = fopen(&quot;hello.txt&quot;, &quot;a&quot;);   //我们可以将其修改为a表示append追加输入
</code></pre>
<p>这样就不会覆盖原有内容而是追加填写了：</p>
<figure data-type="image" tabindex="53"><img src="https://s2.loli.net/2022/06/28/hkQmsNJxgucpYfl.png" alt="image-20220628135946686" loading="lazy"></figure>
<p>不过这里要补充一下，文件的读写实际上并不是直接对文件进行操作的，在这之间还有一个缓冲区：</p>
<figure data-type="image" tabindex="54"><img src="https://s2.loli.net/2022/06/28/jpu8XIhnsxQScAD.png" alt="image-20220628141209105" loading="lazy"></figure>
<p>我们所有的读操作，首先是从文件读取到缓冲区中，再从缓冲区中读取到程序中的；写操作就是先写入到缓冲区，然后再从缓冲区中写入到文件中。这样做的目的是，因为内存和硬盘的速度差距有点大，为了解决这种速度差异导致的性能问题，所以设定一个缓冲区，这样就算速度不一样，但是内容被放在缓冲区中慢慢消化就没问题了。</p>
<p>虽然缓冲区能够解决这些问题，但是也会带来一些不便之处，比如下面的例子：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    FILE * file = fopen(&quot;hello.txt&quot;, &quot;a+&quot;);   //注意这里需要修改为写模式
    if(file != NULL) {
        while (1) {
            int c = getchar();   //不断从控制台读取字符
            if(c == 'q') break;
            putc(c, file);  //写入到文件中
        }
        fclose(file);
    }
}
</code></pre>
<p>我们发现当我们敲了一个字符之后，可能并不会马上更新到文件中，这就是由于缓冲区没有及时同步到文件中，所以我们需要调用一个函数来刷新缓冲区，将那些缓冲区的没有同步的数据全部同步到文件中：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    FILE * file = fopen(&quot;hello.txt&quot;, &quot;a+&quot;);
    if(file != NULL) {
        while (1) {
            int c = getchar();
            if(c == 'q') break;
            putc(c, file);
            fflush(file);   //使用fflush来刷新缓冲区
        }
        fclose(file);
    }
}
</code></pre>
<p>这样我们就可以看到输入一个字符马上就能同步更新了。当然我们也可以手动设定缓冲区的大小：</p>
<pre><code class="language-c">char buf[3];
setvbuf(file, buf, _IOFBF, 3);
</code></pre>
<p>其中：</p>
<ul>
<li>_IONBF：表示不使用缓冲区</li>
<li>_IOFBF：表示只有缓冲区填满了才会更新到文件</li>
<li>_IOLBF：表示遇到换行就更新到文件</li>
</ul>
<p>除了使用<code>getc</code>之外，标准库中还提供了<code>fprintf</code>和<code>fgets</code>系列函数：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    FILE * file = fopen(&quot;hello.txt&quot;, &quot;a+&quot;);
    if(file != NULL) {
        fprintf(file, &quot;树脂%d&quot;, 666);   //fprintf就像普通的打印一样，但是它并不是打印到控制台，而是文件中
        fclose(file);
    }
}
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    FILE * file = fopen(&quot;hello.txt&quot;, &quot;w&quot;);
    if(file != NULL) {
        fputs(&quot;小黑子苏珊&quot;, file);   //就像使用puts一样，同样是输出到文件中
        fclose(file);
    }
}
</code></pre>
<p>这样，对于文本文件的基础读写操作就讲解到这里。</p>
<h3 id="随机访问">随机访问</h3>
<p>前面我们介绍了文本文件的基础读写操作，我们接着来看随机访问。首先什么是随机访问？</p>
<p>我们在前面读取文件时，实际上是按照顺序，每次读取都会往后移动一个字符继续读取，那么如果现在我希望直接跳到某个位置进行读取是否可以实现呢？</p>
<p>我们可以使用fseek来跳转到指定位置：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    FILE * file = fopen(&quot;hello.txt&quot;, &quot;r&quot;);
    if(file != NULL) {
        fseek(file, -2L, SEEK_SET);   //第二个参数为偏移量，根据后面的参数而定
        putchar(getc(file));
        fclose(file);
    }
}
</code></pre>
<p>这里介绍一下起始点：</p>
<ul>
<li>SEEK_SET：从文件开始处开始</li>
<li>SEEK_CUR：从当前位置开始（就是已经读到哪个位置就是哪个位置）</li>
<li>SEEK_END：从文件末尾开始</li>
</ul>
<p>而上面的使用的是SEEK_SET，那么就是从文件开始，往后偏移2个字符的位置，也就是字符<code>l</code>。</p>
<p>那么我们怎么知道当前已经读取到文件第几个字符了呢？</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    FILE * file = fopen(&quot;hello.txt&quot;, &quot;r&quot;);
    if(file != NULL) {
        fseek(file, 2L, SEEK_SET);
        printf(&quot;%ld&quot;, ftell(file));  //可以使用ftell来直接返回当前位置，返回类型为long
        fclose(file);
    }
}
</code></pre>
<p>当然除了fseek和ftell之外，还有fgetpos和fsetpos这两个函数，它们也可以获取位置和设定位置：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    FILE * file = fopen(&quot;hello.txt&quot;, &quot;r&quot;);
    if(file != NULL) {
        fpos_t pos;   //位置需要使用fpos_t进行存储（主要用于处理大文件）
        fgetpos(file, &amp;pos);   //获取位置，并设定给pos，此时位置为0
        fseek(file, -2L, SEEK_END);   //通过fseek移动到倒数第二个位置
        fsetpos(file, &amp;pos);   //设定位置为pos位置
        printf(&quot;%ld&quot;, ftell(file));   //最后得到的就是经过fsetpos设定的新位置了
        fclose(file);
    }
}
</code></pre>
<p>了解了这些函数，这样我们就可以实现对文件的随机读写了。</p>
<p>前面我都是对文本文件进行操作，我们接着来看如何直接读写二进制文件，比如现在我们想要复制一个文件：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    FILE * file = fopen(&quot;hello.txt&quot;, &quot;r&quot;);
    FILE * target = fopen(&quot;hello2.txt&quot;, &quot;w&quot;);
    if(file != NULL) {
        char buf[1024];   //这里我们使用char类型的数组作为暂存
        size_t s;
        while ((s = fread(buf, sizeof(char), 1024, file)) &gt; 0) {  //使用fread函数进行读取，每次都会从文件中读取指定大小的数据到暂存数组中，返回值为实际读取的值，如果读取的值小于0表示读完了
            fwrite(buf, sizeof(char), s, target);  //使用fwrite将数据写入到指定文件中
        }
        fclose(file);
    }
}
</code></pre>
<figure data-type="image" tabindex="55"><img src="https://s2.loli.net/2022/06/28/sHcBxRUChQAVqL5.png" alt="image-20220628151553683" loading="lazy"></figure>
<p>可以看到我们成功将hello.txt中的内容复制到另一个文本文件中了。当然我们也可以用来拷贝大型文件：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    FILE * file = fopen(&quot;22000.318.211104-1236.co_release_svc_refresh_CLIENTCONSUMER_RET_A64FRE_zh-cn.iso&quot;, &quot;r&quot;);
    FILE * target = fopen(&quot;22000.318.211104-1236.co_release_svc_refresh_CLIENTCONSUMER_RET_A64FRE_zh-cn-2.iso&quot;, &quot;w&quot;);

    if(file != NULL) {
        //计算文件的大小
        fseek(file, 0L, SEEK_END);
        long size = ftell(file);
        fseek(file, 0L, SEEK_SET);

        char buf[1024 * 1024];
        size_t s, all = 0;
        while ((s = fread(buf, sizeof(char), 1024, file)) &gt; 0) {
            fwrite(buf, sizeof(char), s, target);
            all += s;
            printf(&quot;当前进度 %.1f%%\n&quot;, (double) all / (double) size * 100);
        }
        fclose(file);
    }
}
</code></pre>
<p>是不是感觉有内味了：</p>
<figure data-type="image" tabindex="56"><img src="https://s2.loli.net/2022/06/28/Ny4LqHeDlGOQiVd.png" alt="image-20220628152934462" loading="lazy"></figure>
<p>这样我们就实现了文件的拷贝。</p>
<hr>
<h2 id="程序编译和调试选学">程序编译和调试（选学）</h2>
<p>**注意：**本小节作为选学内容，不强制要求。</p>
<p>有关C语言语言层面的教学基本就结束了，最后让我们来了解一下如何不借助IDE，通过最原始的方式手动完成程序的编译。</p>
<h3 id="c语言程序的编译">C语言程序的编译</h3>
<p>在开始之前，我们需要介绍一个编译器：</p>
<blockquote>
<p>GCC原名为GNU C语言编译器（GNU C Compiler），只能处理C语言。但其很快扩展，变得可处理C++，后来又扩展为能够支持更多编程语言，如Fortran、<a href="https://baike.baidu.com/item/Pascal/241171">Pascal</a>、Objective -C、Java、Ada、Go以及各类处理器<a href="https://baike.baidu.com/item/%E6%9E%B6%E6%9E%84/13004195">架构</a>上的<a href="https://baike.baidu.com/item/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/61826">汇编语言</a>等，所以改名GNU编译器套件（GNU Compiler Collection）</p>
</blockquote>
<p>那么gcc编译器是如何将我们的程序一步步编译为可执行文件的呢？</p>
<figure data-type="image" tabindex="57"><img src="https://s2.loli.net/2022/06/27/rLjZ5RQtqEvSlXC.png" alt="image-20220627112630649" loading="lazy"></figure>
<ol>
<li>预处理（Pre-Processing）：首先会经过预处理器将程序中的预编译指令进行处理，然后把源文件中的注释这些没用的东西都给扬了。</li>
<li>编译（Compiling）：处理好之后，就可以正式开始编译，首先会编译为汇编代码。</li>
<li>汇编（Assembling）：接着就该将汇编代码编译为机器可以执行的二进制机器指令了，会得到一个二进制目标文件。</li>
<li>链接（Linking）：最后需要将这个二进制目标文件与系统库和其他库的OBJ文件、库文件链接起来，最终生成了可以在特定平台运行的可执行文件。</li>
</ol>
<p>比如在Windows操作系统下完成这四步，就会生成一个Windows的.exe可执行文件。</p>
<p>我们来一步一步尝试一下，首先我们把CLion自带的GCC工具目录配置到环境变量中（Mac系统直接自带，不需要任何配置）：</p>
<figure data-type="image" tabindex="58"><img src="https://s2.loli.net/2022/06/27/uAR3aQhylOGjBf8.png" alt="image-20220627120949262" loading="lazy"></figure>
<p>位置在你的<code>CLion安装目录/bin/mingw/bin</code>，打开高级系统设置，添加环境变量：</p>
<figure data-type="image" tabindex="59"><img src="https://s2.loli.net/2022/06/27/qKQgJy1C5uetj3N.png" alt="image-20220627121332125" loading="lazy"></figure>
<p>配置完成后，打开CLion，我们随便编写一点内容：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello, World!\n&quot;);
    return 0;
}
</code></pre>
<p>然后我们点击IDE下方的终端面板：</p>
<figure data-type="image" tabindex="60"><img src="https://s2.loli.net/2022/06/27/rhbZTmKvqzYtPgo.png" alt="image-20220627130234208" loading="lazy"></figure>
<p>可以看到这里打开的是Windows自带的PowerShell终端，如果不是的可以在设置中修改：</p>
<figure data-type="image" tabindex="61"><img src="https://s2.loli.net/2022/06/27/5clxwIeSszoUpZ9.png" alt="image-20220627130343946" loading="lazy"></figure>
<p>现在我们就可以手动开始对我们的C源文件进行编译了，首先是第一步，我们需要对源文件进行预处理：</p>
<pre><code class="language-sh">gcc -E main.c -o main.i
</code></pre>
<p>其中 <code>-E</code> 后面的是我们的源文件名称，<code>-o</code> 是我们预处理后生成的文件名称：</p>
<figure data-type="image" tabindex="62"><img src="https://s2.loli.net/2022/06/27/pEC9mZwql5X1JMj.png" alt="image-20220627130740318" loading="lazy"></figure>
<p>生成后，我们可以直接查看这个文件（因为此时依然是普通文本）可以看到，我们的代码在经过预处理之后，<code>#include &lt;stdio.h&gt;</code>中的内容都替换过来了。最下面大约1000行左右的位置就是我们的代码了：</p>
<figure data-type="image" tabindex="63"><img src="https://s2.loli.net/2022/06/27/8vk3rEjcy4XK1tO.png" alt="image-20220627131124121" loading="lazy"></figure>
<p>现在我们已经完成了预处理，接着就可以将其编译为汇编程序了：</p>
<pre><code class="language-sh">gcc -S main.i -o main.s
</code></pre>
<p>这里的<code>-S</code>就是预处理之后的文件，我们可以直接将其编译为汇编代码：</p>
<figure data-type="image" tabindex="64"><img src="https://s2.loli.net/2022/06/27/Y4a6LUSwjKl8IBJ.png" alt="image-20220627131513884" loading="lazy"></figure>
<p>可以看到这里都是汇编代码，各种各样的汇编指令。接着我们就可以将这个汇编代码继续编译为二进制文件了：</p>
<pre><code class="language-sh">gcc -c main.s -o main.o
</code></pre>
<p>这里<code>-c</code>后的就是我们的汇编程序，直接生成为二进制文件：</p>
<figure data-type="image" tabindex="65"><img src="https://s2.loli.net/2022/06/27/vR8NOKBfrPoCjbp.png" alt="image-20220627131829386" loading="lazy"></figure>
<p>不过现在我们还没办法直接运行它，因为还需要进一步链接，变成Windows操作系统可以执行的程序：</p>
<pre><code class="language-sh">gcc main.o -o main
</code></pre>
<p>这里直接将刚刚生成的目标文件编译为可执行文件，我们就可以直接运行了：</p>
<figure data-type="image" tabindex="66"><img src="https://s2.loli.net/2022/06/27/GqwY5r7s6b8pvHd.png" alt="image-20220627132110465" loading="lazy"></figure>
<figure data-type="image" tabindex="67"><img src="https://s2.loli.net/2022/06/27/Yne5hmAvOQkTBMF.png" alt="image-20220627132259302" loading="lazy"></figure>
<p>成功生成.exe文件，我们直接在控制台输入它的名字就可以运行了：</p>
<figure data-type="image" tabindex="68"><img src="https://s2.loli.net/2022/06/27/YU8k3wyMg2WF9VO.png" alt="image-20220627132221190" loading="lazy"></figure>
<p>这样我们就实现了手动编译一个C语言程序。当然如果我们要更快速一点地完成编译，可以直接将源文件进行编译：</p>
<pre><code class="language-sh">gcc main.c -o main
</code></pre>
<p>当然这种只是简单的单源文件下的编译，要是遇到多文件的情况下呢？</p>
<figure data-type="image" tabindex="69"><img src="https://s2.loli.net/2022/06/27/acsCO9gFyNUXh4S.png" alt="image-20220627133429263" loading="lazy"></figure>
<pre><code class="language-c">void swap(int * a, int * b);
</code></pre>
<pre><code class="language-c">#include &quot;test.h&quot;

void swap(int * a, int * b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;test.h&quot;

int main() {
    int arr[] = {4, 2, 1, 9, 5, 0, 3, 8, 7, 6};

    for (int i = 0; i &lt; 9; ++i) {
        for (int j = 0; j &lt; 9 - i; ++j) {
            if(arr[j] &gt; arr[j + 1]) swap(&amp;arr[j], &amp;arr[j + 1]);
        }
    }

    for (int i = 0; i &lt; 10; ++i) {
        printf(&quot;%d &quot;, arr[i]);
    }
}
</code></pre>
<p>我们还是按照刚刚的方式直接进行编译：</p>
<figure data-type="image" tabindex="70"><img src="https://s2.loli.net/2022/06/27/jlK9tZRFgxIw4Qr.png" alt="image-20220627133646126" loading="lazy"></figure>
<p>可以看到，编译错误，无法识别到<code>swap</code>这个函数，说明肯定还需要把引入的其他文件也给一起带上，所以：</p>
<pre><code class="language-sh">gcc main.c test.c -o main
</code></pre>
<p>或是将两个文件单独编译为对应的二进制文件，最后再放到一起编译也是可以的：</p>
<pre><code class="language-sh">gcc main.o test.o -o main
</code></pre>
<p>OK，现在多个文件就可以在一起编译了，最后同样生成了一个可执行文件：</p>
<figure data-type="image" tabindex="71"><img src="https://s2.loli.net/2022/06/27/bQOiG2US6wFDnxy.png" alt="image-20220627134010138" loading="lazy"></figure>
<h3 id="使用make和cmake进行构建">使用Make和CMake进行构建</h3>
<p>我们的项目可能会有很多很多的内容需要去进行编译，如何去进行组织成了一个大问题，比如让谁先编译，谁后编译，这时，我们就需要一个构建工具来帮助我们对程序的构建流程进行组织。</p>
<blockquote>
<p>Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。</p>
</blockquote>
<p>要使用Make对我们的项目进行构建，我们需要先告诉Make我们的程序应该如何去进行构建，这时我们就要编写一下Makefile了：</p>
<figure data-type="image" tabindex="72"><img src="https://s2.loli.net/2022/06/27/3bRneOcMtfZyPw7.png" alt="image-20220627135232863" loading="lazy"></figure>
<p>我们只需要把需要执行的命令按照我们想要的顺序全部写到里面就可以了，但是需要遵循以下格式：</p>
<pre><code class="language-makefile">targets : prerequisites
  command
</code></pre>
<p>一个Makefile中可以有很多个目标，比如我们现在要分别编译main.c和test.c，那么就需要创建两个目标：</p>
<ul>
<li>targets：构建的目标，可以是一个普通的标签、文件名称等</li>
<li>prerequisites：前置条件，可以设定要求完成其他目标才能开始构建当前目标</li>
<li>command：构建需要执行的命令</li>
</ul>
<p>比如现在我们想要分别先编译test.c和main.c，最后将他们变成一个可执行文件，那么makefile可以这样编写：</p>
<pre><code class="language-makefile">main.exe: test.o main.o  #目标1：构建最终的程序，要求完成下面两个目标（注意最终目标需要写在第一个）
	gcc test.o main.o -o main

main.o: main.c  #目标2：构建目标为main.o，前置要求必须有main.c文件
	gcc -E main.c -o main.i
	gcc -S main.i -o main.s
	gcc -c main.s -o main.o

test.o: test.c  #目标3：同样的，要求必须有test.c文件才能开始
	gcc -E test.c -o test.i
	gcc -S test.i -o test.s
	gcc -c test.s -o test.o
</code></pre>
<p>接着我们只需要在控制台输入make命令（CLion自带环境需要输入mingw32-make命令，Mac下直接输入make）就可以进行编译了：</p>
<figure data-type="image" tabindex="73"><img src="https://s2.loli.net/2022/06/27/9nGRvqp8SjUXhN7.png" alt="image-20220627212727506" loading="lazy"></figure>
<p>命令执行的每一步都会详细打印出来，我们可以看到构建确实是按照我们的顺序在进行，并且成功编译出最终目标：</p>
<figure data-type="image" tabindex="74"><img src="https://s2.loli.net/2022/06/27/FTILC5evZ67rEXo.png" alt="image-20220627212822806" loading="lazy"></figure>
<p>当然，如果我们没有做任何的修改，那么再次执行make命令不会做任何事情：</p>
<figure data-type="image" tabindex="75"><img src="https://s2.loli.net/2022/06/27/BQSIXTpvOc9Jukh.png" alt="image-20220627212951245" loading="lazy"></figure>
<p>但是如果我们修改一下源文件的话，执行make将会重新构建目标：</p>
<figure data-type="image" tabindex="76"><img src="https://s2.loli.net/2022/06/27/sfQgxm34vlw8TKi.png" alt="image-20220627213029819" loading="lazy"></figure>
<p>再次执行：</p>
<figure data-type="image" tabindex="77"><img src="https://s2.loli.net/2022/06/27/SrE9FcADYWaywRN.png" alt="image-20220627213051247" loading="lazy"></figure>
<p>通过使用Make，即使没有如此高级的IDE，哪怕我们纯靠记事本写C代码，都可以很方便地完成对一个项目的构建了。当然这只是Make的简单使用，它还支持使用变量、逻辑判断等高级玩法，这里我们就不多做介绍了。</p>
<p>虽然使用Make可以很方便地对项目构建流程进行配置，但是貌似CLion并没有采用这种方式来组织我们的项目进行构建，而是使用了CMake，我们来看看它又是做什么的。</p>
<blockquote>
<p>CMake是一个跨平台的安装（<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91/1258343">编译</a>）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8/8853067">编译器</a>所支持的C++特性,类似<a href="https://baike.baidu.com/item/UNIX/219943">UNIX</a>下的automake。</p>
</blockquote>
<p>简而言之， CMake是一个跨平台的Makefile生成工具!</p>
<p>实际上当我们创建一个项目后，CLion会自动为我们配置CMake，而具体的配置都是写在CMakeList.txt中的：</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.22)
project(untitled C)

set(CMAKE_C_STANDARD 99)

add_executable(untitled main.c test.c test.h)
</code></pre>
<p>我们逐行来进行解读：</p>
<ul>
<li>第一行使用cmake_minimum_required来指定当前项目使用的CMake最低版本，如果使用的CMake程序低于此版本是无法构建的。</li>
<li>第二行project指定项目名称，名称随意，后面的是项目使用的语言，这里是C。</li>
<li>第三行set用于设定一些环境变量等，这里设定的是C 99标准。</li>
<li>第四行add_executable用于指定一个编译出来的可执行文件，这里名称为untitled，后面的都是需要编译的源文件（头文件可以不写）</li>
</ul>
<p>当然除了这些语法之外，还有各种各样的设定，比如设定库目录或是外部动态连接库等，这里就不多说了，感兴趣的可以自行了解。</p>
<p>这里我们来手动执行一下cmake：</p>
<figure data-type="image" tabindex="78"><img src="https://s2.loli.net/2022/06/27/XFpHB1aPbRCA4kL.png" alt="image-20220627215908039" loading="lazy"></figure>
<p>首先还是添加环境变量，添加完成后重启CLion，我们输入cmake命令进行生成：</p>
<pre><code class="language-sh"> cmake -S . -B test -G &quot;MinGW Makefiles&quot;
</code></pre>
<p>其中<code>-S</code>后面的是源文件目录，这里<code>.</code>表示当前目录，<code>-B</code>后面是构建目录，一会构建的文件都在这里面存放，最后<code>-G</code>是选择生成器（生成器有很多，甚至可以直接生成一个VS项目，我们可以直接使用Visual Studio打开），这里我们需要生成Makefile，所以填写&quot;MinGW Makefiles&quot;：</p>
<figure data-type="image" tabindex="79"><img src="https://s2.loli.net/2022/06/27/MUgkvuARteyS2wQ.png" alt="image-20220627221226478" loading="lazy"></figure>
<p>可以看到已经成功在我们的构建目录中生成了：</p>
<figure data-type="image" tabindex="80"><img src="https://s2.loli.net/2022/06/27/uMtaVgILmjFhiR9.png" alt="image-20220627221335557" loading="lazy"></figure>
<p>只不过它这个自动生成的Makefile写的就比较复杂了，我们也不需要去关心，接着我们像之前一样直接使用make就可以编译了：</p>
<p>这里要先进入一下test目录，使用<code>cd test</code>命令修改当前工作目录：</p>
<figure data-type="image" tabindex="81"><img src="https://s2.loli.net/2022/06/27/DNnROjG1eh8V7kA.png" alt="image-20220627221459717" loading="lazy"></figure>
<p>可以看到它生成的Makefile还是挺高级的，还能输出进度，现在我们的程序就构建好了，直接启动把：</p>
<figure data-type="image" tabindex="82"><img src="https://s2.loli.net/2022/06/27/IWPbV8nJ3XFLfEz.png" alt="image-20220627221546242" loading="lazy"></figure>
<p>当然CLion并没有使用Makefile的编译方式，而是Ninja，并且生成的构建文件默认存放在<code>cmake-build-debug</code>中，跟make比较类似，但是速度会更快一些，不过最后都会成功构建出我们的可执行程序。</p>
<p>这下，我们就清楚整个项目中个个文件是干嘛的了。</p>
<h3 id="使用lldb调试工具">使用LLDB调试工具</h3>
<p>最后我们来说一下LLDB调试工具（与之类似的还有GDB），首先还是配置一下环境变量：</p>
<figure data-type="image" tabindex="83"><img src="https://s2.loli.net/2022/06/28/OGg9fnXztEl7Ick.png" alt="image-20220628002518087" loading="lazy"></figure>
<p>LLDB调试工具用于对我们的程序进行逐步调试使用，实际上我们之前也使用调试，只不过是在IDE中的图形化界面中操作的，那么如果没有IDE呢，我们可以使用LLDB调试工具来进行调试：</p>
<pre><code class="language-sh">lldb .\untitled.exe
</code></pre>
<p>注意在编译时需要需要添加-g参数来附带调试信息，这样才可以使用gdb进行调试，否则不能（CLion默认生成的是可以调试的程序，所以直接使用就行了）</p>
<figure data-type="image" tabindex="84"><img src="https://s2.loli.net/2022/06/28/RdNOVElm5G12q8y.png" alt="image-20220628002734741" loading="lazy"></figure>
<p>进入后，可以看到是这样的一个界面，我们需要输入命令来进行逐步调试，输入r就可以开始运行了：</p>
<figure data-type="image" tabindex="85"><img src="https://s2.loli.net/2022/06/28/kQodUtfj7JXZ4B5.png" alt="image-20220628001554755" loading="lazy"></figure>
<p>成功运行出结果，那么具体怎么进行断点调试呢？我们可以使用<code>b 行号</code>的形式在对应的行号打上断点，比如这里对第9行进行断点：</p>
<figure data-type="image" tabindex="86"><img src="https://s2.loli.net/2022/06/28/pRuoPKOL4FYgsj8.png" alt="image-20220628002035160" loading="lazy"></figure>
<p>接着我们再输入r之后，程序会暂时卡在断点位置，此时我们可以通过输入v来查看当前所有的局部变量信息：</p>
<figure data-type="image" tabindex="87"><img src="https://s2.loli.net/2022/06/28/96qVCgjebBWph5w.png" alt="image-20220628003001093" loading="lazy"></figure>
<p>可以看到现在是冒泡排序的第一轮，所以<code>i</code>和<code>j</code>都还是0，并且数组是乱序的，我们输入c可以继续运行：</p>
<figure data-type="image" tabindex="88"><img src="https://s2.loli.net/2022/06/28/JND3ix4vuoEjAaG.png" alt="image-20220628003056092" loading="lazy"></figure>
<p>继续运行一轮后，此时<code>j</code>就变成1了，因为内层循环执行了一次，我们可以通过p来打印变量的值：</p>
<figure data-type="image" tabindex="89"><img src="https://s2.loli.net/2022/06/28/7EvSVtXyLcJikHd.png" alt="image-20220628003230535" loading="lazy"></figure>
<p>当我们不需要再调试时，可以直接结束掉程序：</p>
<figure data-type="image" tabindex="90"><img src="https://s2.loli.net/2022/06/28/z7RlaybGsLV4Bqu.png" alt="image-20220628003631329" loading="lazy"></figure>
<p>当然这仅仅是展示lldb的简单使用，通过使用lldb我们就可以很轻松地在控制台进行调试了。</p>
<p>至此，包括编译、构建、调试的所有操作，我们完全可以脱离IDE纯靠命令行进行操作了（其实在没有图形化界面的年代基本上都是这样写代码的）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言程序设计（二）]]></title>
        <id>https://muouren7.github.io/post/C语言（二）_2/</id>
        <link href="https://muouren7.github.io/post/C语言（二）_2/">
        </link>
        <updated>2022-10-14T08:06:38.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://s2.loli.net/2022/06/17/nzpG5CLfUg927Rr.jpg" alt="" loading="lazy"></figure>
<h1 id="c语言基础">C语言基础</h1>
<p>前面我们已经搭建好了基本的学习环境，现在就让我们开始C语言的学习吧！</p>
<p>C语言的语法层面内容相比其他语言来说，其实算少的了，但是它的难点在于很多概念上的理解，这也是为什么上一章一直在说一些计算机基础相关内容（包括这一章还会继续补一点），这样会有助于各位对于语言的理解，C语言可以说是步入编程领域的分水岭，跨过了这道坎，后续其他编程语言的学习都会无比轻松。</p>
<p>学习编程的过程可能会很枯燥，但是请各位一定不要心急，一步一个脚印，相信大家一定能通关。</p>
<h2 id="c程序基本格式">C程序基本格式</h2>
<p>前面我们在创建项目之后自动生成了一个<code>.c</code>文件，这个就是我们编写的程序代码文件：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello World!&quot;);
  	return 0;
}
</code></pre>
<p>操作系统需要执行我们的程序，但是我们的程序中可能写了很多很多的代码，那么肯定需要知道从哪里开始执行才可以，也就是程序的入口，所以我们需要提供一个入口点，我们的C语言程序入口点就是<code>main</code>函数（不过现在还没有讲到函数，所以各位就理解为固定模式即可）它的写法是：</p>
<pre><code class="language-c">int main() {  //所有的符号一律采用英文的，别用中文
    程序代码...
}
</code></pre>
<p>注意是<code>int</code>后面空格跟上<code>main()</code>，我们的程序代码使用花括号<code>{}</code>进行囊括（有的人为了方便查阅，会把前半个花括号写在下面）</p>
<p>然后我们看到，如果我们需要打印一段话到控制台，那么就需要使用<code>printf(内容)</code>来完成，这其实就是一种函数调用，但是现在我们还没有接触到，我们注意到括号里面的内容就是我们要打印到控制台的内容：</p>
<pre><code class="language-c">printf(&quot;Hello World!&quot;);   //注意最后需要添加;来结束这一行，注意是英文的分号，不是中文的！
</code></pre>
<p>我们要打印的内容需要采用双引号进行囊括，被双引号囊括的这一端话，我们称为字符串，当然我们现在还没有学到，所以各位也是记固定模式就好，当我们需要向控制台打印一段话时，就要用双引号囊括这段话，然后放入<code>printf</code>即可。我们会在后续的学习中逐渐认识<code>printf</code>函数。</p>
<p>最顶上还有一句：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
</code></pre>
<p>这个是引入系统库为我们提供的函数，包括<code>printf</code>在内，所以我们以后编写一个C语言程序，就按照固定模式：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    程序代码
}
</code></pre>
<p>除了程序代码部分我们会进行编写之外，其他的地方采用固定模式就好。</p>
<p>我们在写代码的过程中可以添加一些注释文本，这些文本内容在编译时自动忽略，所以比如我们想边写边记点笔记，就可以添加注释，注释的格式为：</p>
<pre><code class="language-java">#include &lt;stdio.h&gt;   //引入标准库头文件

int main() {   //主函数，程序的入口点
    printf(&quot;Hello World!&quot;);  //向控制台打印字符串
}
</code></pre>
<p>当然我们也可以添加多行注释：</p>
<pre><code class="language-java">#include &lt;stdio.h&gt;

/*
 * 这是由IDE自动生成的测试代码
 * 还是可以的
 */
int main() {
    printf(&quot;Hello World!&quot;);
  	//最后还有一句 return 0; 但是我们可以不用写，编译器会自动添加，所以后面讲到之后我们再来说说这玩意。
}
</code></pre>
<p>OK，基本的一些内容就讲解完毕了。</p>
<h2 id="基本数据类型">基本数据类型</h2>
<p>我们的程序离不开数据，比如我们需要保存一个数字或是字母，这时候这些东西就是作为数据进行保存，不过不同的数据他们的类型可能不同，比如1就是一个整数，0.5就是一个小数，A就是一个字符，C语言提供了多种数据类型供我们使用，我们就可以很轻松的使用这些数据了。</p>
<p>不同的数据类型占据的空间也会不同，这里我们需要先提一个概念，就是字、字节是什么？</p>
<p>我们知道，计算机底层实际上只有0和1能够表示，这时如果我们要存储一个数据，比如十进制的3，那么就需要使用2个二进制位来保存，二进制格式为<code>11</code>，占用两个位置，再比如我们要表示十进制的15，这时转换为二进制就是<code>1111</code>占用四个位置（4个bit位）来保存。一般占用8个bit位表示一个字节（B），2个字节等于1个字，所以一个字表示16个bit位，它们是计量单位。</p>
<p>我们常说的内存大小1G、2G等，实际上就是按照下面的进制进行计算的：</p>
<p>8 bit = 1 B ，1024 B = 1KB，1024 KB = 1 MB，1024 MB = 1GB，1024 GB = 1TB，1024TB = 1PB（基本上是1024一个大进位，但是有些硬盘生产厂商是按照1000来计算的，所以我们买电脑的硬盘容量可能是512G的但是实际容量可能会缩水）</p>
<p>在不同位数的系统下基本数据类型的大小可能会不同，因为现在主流已经是64位系统，本教程统一按照64位系统进行讲解。</p>
<h3 id="原码-反码和补码">原码、反码和补码</h3>
<h4 id="原码">原码</h4>
<p>上面我们说了实际上所有的数字都是使用0和1这样的二进制数来进行表示的，但是这样仅仅只能保存正数，那么负数怎么办呢？</p>
<p>比如现在一共有4个bit位来保存我们的数据，为了表示正负，我们可以让第一个bit位专门来保存符号，这样，我们这4个bit位能够表示的数据范围就是：</p>
<ul>
<li>最小：1111 =&gt; - (2<sup>2+2</sup>1+2^0) =&gt; -7</li>
<li>最大：0111 =&gt; + (2<sup>2+2</sup>1+2^0) =&gt; +7 =&gt; 7</li>
</ul>
<p>虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：</p>
<p>1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道，计算机顶多知道1+1需要进位！）</p>
<p>我们得创造一种更好的表示方式！于是我们引入了反码：</p>
<h4 id="反码">反码</h4>
<p>正数的反码是其本身<br>
负数的反码是在其原码的基础上, 符号位不变，其余各个位取反<br>
经过上面的定义，我们再来进行加减法：</p>
<p>1+(-1) = 0001 + 1110 = 1111 =&gt; -0 （直接相加，这样就简单多了！）</p>
<p>思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？</p>
<p>0既不是正数也不是负数，那么显然这样的表示依然不够合理！</p>
<h4 id="补码">补码</h4>
<p>根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下：</p>
<p>正数的补码就是其本身 （不变！）<br>
负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)<br>
其实现在就已经能够想通了，-0其实已经被消除了！我们再来看上面的运算：</p>
<p>1+(-1) = 0001 + 1111 = (1)0000 =&gt; +0 （现在无论你怎么算，也不会有-0了！）</p>
<p>所以现在，4bit位能够表示的范围是：-8~+7（C使用的就是补码！）</p>
<h3 id="整数类型">整数类型</h3>
<p>我们首先来看看整数类型，整数就是不包含小数点的数据，比如<code>1</code>，<code>99</code>，<code>666</code>等数字，整数包含以下几种类型：</p>
<ul>
<li>int   -    占用 4 个字节，32个bit位，能够表示 -2,147,483,648 到 2,147,483,647 之间的数字，默认一般都是使用这种类型</li>
<li>long   -   占用 8 个字节，64个bit位。</li>
<li>short   -    占用2个字节，16个bit位。</li>
</ul>
<h3 id="浮点类型">浮点类型</h3>
<p>浮点类一般用于保存小数，不过为啥不叫小数类型而是浮点类型呢？因为我们的一个小数分为整数部分和小数部分，我们需要用一部分的bit位去表示整数部分，而另一部分去表示小数部分，至于整数部分和小数部分各自占多少并不是固定的，而是浮动决定的（在计算机组成原理中会深入学习，这里就不多介绍了）</p>
<ul>
<li>float   -   单精度浮点，占用4个字节，32个bit位。</li>
<li>double    -    双精度浮点，占用8个字节，64个bit位。</li>
</ul>
<h3 id="字符类型">字符类型</h3>
<p>除了保存数字之外，C语言还支持字符类型，我们的每一个字符都可以使用字符类型来保存：</p>
<ul>
<li>char   -    占用1个字节（-128~127），可以表示所有的ASCII码字符，每一个数字对应的是编码表中的一个字符：</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://s2.loli.net/2022/06/17/BoaWb5EHOM7wJVy.jpg" alt="image-20220603114358826" loading="lazy"></figure>
<p>编码表中包含了所有我们常见的字符，包括运算符号、数字、大小写字母等（注意只有英文相关的，没有中文和其他语言字符，包括中文的标点符号也没有）</p>
<p>某些无法直接显示的字符（比如换行，换行也算一个字符）需要使用转义字符来进行表示：</p>
<figure data-type="image" tabindex="3"><img src="https://s2.loli.net/2022/06/17/fqnzER2AS4YleTG.jpg" alt="img" loading="lazy"></figure>
<p>有关基本类型的具体使用我们放到下一节进行讲解。</p>
<hr>
<h2 id="变量">变量</h2>
<p>前面我们了解了C语言中的基本类型，那么我们如何使用呢？这时我们就可以创建不同类型的变量了。</p>
<h3 id="变量的使用">变量的使用</h3>
<p>变量就像我们在数学中学习的<code>x</code>，<code>y</code>一样，我们可以直接声明一个变量，并利用这些变量进行基本的运算，声明变量的格式为：</p>
<pre><code class="language-c">数据类型 变量名称 = 初始值;    //其中初始值可以不用在定义变量时设定
// = 是赋值操作，可以将等号后面的值赋值给前面的变量，等号后面可以直接写一个数字（常量）、变量名称、算式
</code></pre>
<p>比如我们现在想要声明一个整数类型的变量：</p>
<pre><code class="language-java">int a = 10;   //变量类型为int（常用），变量名称为a，变量的初始值为10
</code></pre>
<pre><code class="language-c">int a = 10, b = 20;   //多个变量可以另起一行编写，也可以像这样用逗号隔开，注意类型必须是一样的
</code></pre>
<p>其中，变量的名称并不是随便什么都可以的，它有以下规则：</p>
<ul>
<li>不能重复使用其他变量使用过的名字。</li>
<li>只能包含英文字母或是下划线、数字，并且严格区分大小写，比如<code>a</code>和<code>A</code>不算同一个变量。</li>
<li>虽然可以包含数字，但是不能以数字开头。</li>
<li>不能是关键字（比如我们上面提到的所有基本数据类型，当然还有一些关键字我们会在后面认识）</li>
<li>（建议）使用英文单词，不要使用拼音，多个词可以使用驼峰命名法或是通过下划线连接。</li>
</ul>
<p>初始值可以是一个常量数据（比如直接写10、0.5这样的数字）也可以是其他变量，或是运算表达式的结果，这样会将其他变量的值作为初始值。</p>
<p>我们可以使用变量来做一些基本的运算：</p>
<pre><code class="language-java">#include &lt;stdio.h&gt;

int main() {
    int a = 10;  //将10作为a的值
    int b = 20;
    int c = a + b;   //注意变量一定要先声明再使用，这里是计算a + b的结果（算式），并作为c的初始值
}
</code></pre>
<p>这里使用到了<code>+</code>运算符（之后我们还会介绍其他类型的运算符）这个运算符其实就是我们数学中学习的加法运算，会将左右两边的变量值加起来，得到结果，我们可以将运算结果作为其他变量的初始值，还是很好理解的。</p>
<p>但是现在虽然做了运算，我们还不知道运算的具体结果是什么，所以这里我们通过前面认识的<code>printf</code>函数来将结果打印到控制台：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    int b = 20;
    int c = a + b;

    printf(c);   //直接打印变量c
}
</code></pre>
<p>但是我们发现这样似乎运行不出来结果，不对啊，前面你不是说把要打印到控制台的内容写到<code>printf</code>中吗，怎么这里不行呢？实际上<code>printf</code>是用于格式化打印的，我们来看看如何进行格式化打印，输出我们的变量值：</p>
<pre><code class="language-c">printf(&quot;c的结果是：%d&quot;, );   //使用%d来代表一个整数类型的数据（占位符），在打印时会自动将c的值替换上去
</code></pre>
<p>我们来看看效果：</p>
<figure data-type="image" tabindex="4"><img src="https://s2.loli.net/2022/06/17/lb4T2HEXP7jCWIx.jpg" alt="image-20220603131740600" loading="lazy"></figure>
<p>这样，我们就知道该如何打印我们变量的值了，当然，除了使用<code>%d</code>打印有符号整数之外，还有其他的：</p>
<table>
<thead>
<tr>
<th>格式控制符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%c</td>
<td>输出一个单一的字符</td>
</tr>
<tr>
<td>%hd、%d、%ld</td>
<td>以十进制、有符号的形式输出 short、int、long 类型的整数</td>
</tr>
<tr>
<td>%hu、%u、%lu</td>
<td>以十进制、无符号的形式输出 short、int、long 类型的整数</td>
</tr>
<tr>
<td>%ho、%o、%lo</td>
<td>以八进制、不带前缀、无符号的形式输出 short、int、long 类型的整数</td>
</tr>
<tr>
<td>%#ho、%#o、%#lo</td>
<td>以八进制、带前缀、无符号的形式输出 short、int、long 类型的整数</td>
</tr>
<tr>
<td>%hx、%x、%lx %hX、%X、%lX</td>
<td>以十六进制、不带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字也小写；如果 X 大写，那么输出的十六进制数字也大写。</td>
</tr>
<tr>
<td>%#hx、%#x、%#lx %#hX、%#X、%#lX</td>
<td>以十六进制、带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字和前缀都小写；如果 X 大写，那么输出的十六进制数字和前缀都大写。</td>
</tr>
<tr>
<td>%f、%lf</td>
<td>以十进制的形式输出 float、double 类型的小数</td>
</tr>
<tr>
<td>%e、%le %E、%lE</td>
<td>以指数的形式输出 float、double 类型的小数。如果 e 小写，那么输出结果中的 e 也小写；如果 E 大写，那么输出结果中的 E 也大写。</td>
</tr>
<tr>
<td>%g、%lg %G、%lG</td>
<td>以十进制和指数中较短的形式输出 float、double 类型的小数，并且小数部分的最后不会添加多余的 0。如果 g 小写，那么当以指数形式输出时 e 也小写；如果 G 大写，那么当以指数形式输出时 E 也大写。</td>
</tr>
<tr>
<td>%s</td>
<td>输出一个字符串</td>
</tr>
</tbody>
</table>
<p>比如现在我们要进行小数的运算，还记得我们前面介绍的小数类型有哪些吗？</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    double a = 0.5;
    float b = 2.5f;   //注意直接写2.5默认表示的是一个double类型的值，我们需要再后面加一个f或是F表示是flaot类型值

    printf(&quot;a + b的结果是：%f&quot;, a + b);   //根据上表得到，小数类型需要使用%f表示，这里我们可以直接将a + b放入其中
}
</code></pre>
<p>可以看到，结果也是正确的：</p>
<figure data-type="image" tabindex="5"><img src="https://s2.loli.net/2022/06/17/M8ia6jKlW7epwXg.jpg" alt="image-20220603132459810" loading="lazy"></figure>
<p>当然，我们也可以一次性打印多个，只需要填写多个占位符表示即可：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    double a = 0.5;
    float b = 2.5f;   //整数类型默认是int，如果要表示为long类型的值，也是需要在最后添加一个l或L

    printf(&quot;a = %f, b = %f&quot;, a, b);   //后面可以一直添加（逗号隔开），但是注意要和前面的占位符对应
}
</code></pre>
<p>结果也是正常的：</p>
<figure data-type="image" tabindex="6"><img src="https://s2.loli.net/2022/06/17/2n6GfkdlFPX4Bv1.jpg" alt="image-20220603132713970" loading="lazy"></figure>
<p>我们再来看看字符类型：</p>
<pre><code class="language-c">char c = 'A';   //字符需要使用单引号囊括，且只能有一个字符，不能写成'AA'，这就不是单个字符了
//注意这里的A代表的是A这个字符，对应的ASCII码是65，实际上c存储的是65这个数字
</code></pre>
<p>我们也可以通过格式化打印来查看它的值：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 'A';
    printf(&quot;变量c的值为：%c 对应的ASCII码为：%d&quot;, c, c);   //这里我们使用%c来以字符形式输出，%d输出的是变量数据的整数形式，其实就是对应的ASCII码
}
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://s2.loli.net/2022/06/17/VsMorWTd13YLp8Q.jpg" alt="image-20220603133727498" loading="lazy"></figure>
<p>当然，我们也可以直接让char存储一个数字（ASCII码），同样也可以打印出对应的字符：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 66;
    printf(&quot;变量c的值为：%c 对应的ASCII码为：%d&quot;, c, c);
}
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://s2.loli.net/2022/06/17/shjrQKayID9YwVc.jpg" alt="image-20220603133858133" loading="lazy"></figure>
<p>那么现在请各位小伙伴看看下面这段代码会输出什么：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    char c = 'a';
    printf(&quot;变量c的ASCII码为：%d&quot;, c);
}
</code></pre>
<p>没错，这里得到的结果就是字符<code>a</code>的ASCII码值，注意千万不要认为c得到的是变量a的值，这里使用的是字符<code>a</code>，跟上面的变量a半毛钱关系都没有：</p>
<figure data-type="image" tabindex="9"><img src="https://s2.loli.net/2022/06/17/X1f6SzW7aBoFnJh.jpg" alt="image-20220603134234040" loading="lazy"></figure>
<p>但是如果我们去掉引号，就相当于把变量a的值给了c，c现在的ASCII码就是10了，所以这里一定要分清楚。</p>
<p>对于某些无法表示的字符，比如换行这类字符，我们没办法直接敲出来，只能使用转义字符进行表示：</p>
<pre><code class="language-c">char c = '\n';
</code></pre>
<p>详细的转义字符表参见前面的基本数据类型章节。</p>
<p>变量除了有初始值之外，也可以在后续的过程中得到新的值：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    short s = 10;
    s = 20;    //重新赋值为20，注意这里就不要再指定类型了，指定类型只有在声明变量时才需要
    printf(&quot;%d&quot;, s);   //打印结果
}
</code></pre>
<p>可以看到，得到的是我们最后一次对变量修改的结果：</p>
<figure data-type="image" tabindex="10"><img src="https://s2.loli.net/2022/06/17/mIXbe91qu7B5ZKU.jpg" alt="image-20220603135152184" loading="lazy"></figure>
<p>那要是我们不对变量设定初始值呢？那么变量会不会有默认值：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a, b, c, d;
    printf(&quot;%d,%d,%d,%d&quot;, a, b, c, d);
}
</code></pre>
<p>可以看到，虽然定义变量但是我们没有为其设定初始值，那么它的值就是不确定的了（千万注意并不是不设定值默认就是0）：</p>
<figure data-type="image" tabindex="11"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2v11c4z44j212o02mmxa.jpg" alt="image-20220603141341554" loading="lazy"></figure>
<p>所以各位小伙伴以后在使用时一定要注意这个问题，至于为什么不是0，这是因为内存分配机制，我们在下一章高级篇再进行讲解。</p>
<p>我们再来看一个例子：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 127;    //已经到达c的最大值了
    c = c + 1;   //我不管，我就要再加
    printf(&quot;%d&quot;, c);    //这时会得到什么结果？
}
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://s2.loli.net/2022/06/17/N7lGU4n2OkxjLcF.jpg" alt="image-20220603143909688" loading="lazy"></figure>
<p>怎么127加上1还变成-128了呢？这是由于位数不够，导致运算结果值溢出：</p>
<ul>
<li>127  +   1= 01111111   +    1</li>
<li>由于现在是二进制，满2进1，所以最后变成</li>
<li>10000000   =   补码形式的 -128</li>
</ul>
<p>所以，了解上面这些计算机底层原理是很重要的，我们能够很轻松地知道为什么会这样。</p>
<p>在我们的运算中，可能也会存在一些一成不变的值，比如<code>π</code>的值永远都是<code>3.1415....</code>，在我们的程序中，也可以使用这样不可变的变量，我们成为常量。</p>
<p>定义常量和变量比较类似，但是需要在前面添加一个<code>const</code>关键字，表示这是一个常量：</p>
<figure data-type="image" tabindex="13"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2v0s7fdvgj2128052gls.jpg" alt="image-20220603140454728" loading="lazy"></figure>
<p>可以看到，常量在一开始设定初始值后，后续是不允许进行修改的。</p>
<h3 id="无符号数">无符号数</h3>
<p>我们知道，所有的数据底层都是采用二进制来进行保存的，而第一位则是用于保存符号位，但是如果我们不考虑这个符号位，那么所有的数都是按照正数来表示，比如考虑了符号位的<code>char</code>类型：</p>
<ul>
<li>考虑符号表示范围：-128~127</li>
<li>不考虑符号：0~255</li>
</ul>
<p>我们也可以直接使用这些不带符号位的数据类型：</p>
<pre><code class="language-c">int main() {
    unsigned char c = -65;   //数据类型前面添加unsigned关键字表示采用无符号形式
    printf(&quot;%u&quot;, c);    //%u以无符号形式输出十进制数据
}
</code></pre>
<p>可以看到这里给了无符号char类型c一个-65的值，但是现在很明显符号位也是作为数值的表示部分，所以结果肯定不是-65：</p>
<figure data-type="image" tabindex="14"><img src="https://s2.loli.net/2022/06/17/Hkg4MIFcXzKwClp.jpg" alt="image-20220603142210120" loading="lazy"></figure>
<p>结合我们前面学习的基础知识，我们来看看为什么得到的是191这个数字。首先char类型占据一个字节，8个bit位：</p>
<ul>
<li>00000000   -&gt;    现在赋值-65    -&gt;    -65的补码形式   -&gt;     10111111</li>
<li>由于现在没有符号位，一律都是正数，所以，10111111  =  128 + 32 + 16 + 8 + 4 + 2 + 1 = 191</li>
</ul>
<p>我们也可以直接以无符号数形式打印：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int i = -1;
    printf(&quot;%u&quot;, i);    //%u以无符号形式输出十进制数据
}
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://s2.loli.net/2022/06/17/PYNZLCWc6OFVui8.jpg" alt="image-20220603143441616" loading="lazy"></figure>
<p>得到无符号int的最大值。</p>
<h3 id="类型转换">类型转换</h3>
<p>一种类型的数据可以转换为其他类型的数据，这种操作我们称为类型转换，类型转换分为<strong>自动类型转换</strong>和<strong>强制类型转换</strong>，比如我们现在希望将一个short类型的数据转换为int类型的数据：</p>
<pre><code class="language-java">#include &lt;stdio.h&gt;

int main() {
    short s = 10;
    int i = s;   //直接将s的值传递给i即可，但是注意此时s和i的类型不同
}
</code></pre>
<p>这里其实就是一种自动类型转换，自动类型转换就是编译器隐式地进行的数据类型转换，这种转换不需要我们做什么，我们直接写就行，会自动进行转换操作。</p>
<pre><code class="language-c">float a = 3;    //包括这里我们给的明明是一个int整数3但是却可以赋值给float类型，说明也是进行了自动类型转换
</code></pre>
<p>如果我们使用一个比转换的类型最大值都还要大的值进行类型转换，比如：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 511;
    char b = a;   //最大127
    printf(&quot;%d&quot;, b);
}
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://s2.loli.net/2022/06/17/U9rxV53lCzB4ARm.jpg" alt="image-20220606180919318" loading="lazy"></figure>
<p>很明显char类型是无法容纳大于127的数据的，因为只占一个字节，而int占4个字节，如果需要进行转换，那么就只能丢掉前面的就只保留char所需要的那几位了，所以这里得到的就是-1：</p>
<ul>
<li>511 = int  -&gt;  00000000 00000000 00000001 11111111</li>
<li>char   -&gt;   11111111   -&gt;    -1</li>
</ul>
<p>我们也可以将整数和小数类型的数据进行互相转换：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 99;
    double d = a;
    printf(&quot;%f&quot;, d);
}
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2yolhtg3rj215o02iq2z.jpg" alt="image-20220606180529600" loading="lazy"></figure>
<p>不过这里需要注意的是，小数类型在转换回整数类型时，会丢失小数部分（注意，不是四舍五入，是直接丢失小数！）：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    double a = 3.14;
    int b = a;    //这里编译器还提示了黄标，我们可以通过之后讲到的强制类型转换来处理
    printf(&quot;%d&quot;, b);
}
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2yoncxo3gj210o02kmx5.jpg" alt="image-20220606180719070" loading="lazy"></figure>
<p>除了赋值操作可以进行自动类型转换之外，在运算中也会进行自动类型转换，比如：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    float a = 2;
    int b = 3;
    double c = b / a;   //  &quot;/&quot; 是除以的意思，也就是我们数学中的除法运算，这里表示a除以b
    printf(&quot;%f&quot;, c);
}
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://s2.loli.net/2022/06/17/FQpoer6ANgjsIlY.jpg" alt="image-20220606191838425" loading="lazy"></figure>
<p>可以看到，这里得到的结果是小数1.5，但是参与运算的既有整数类型，又有浮点类型，结果为什么就确定为浮点类型了呢？这显然是由于类型转换导致的。那么规则是什么呢？</p>
<figure data-type="image" tabindex="20"><img src="https://s2.loli.net/2022/06/17/39b2LouK8dfnNhv.jpg" alt="image-20220606191412418" loading="lazy"></figure>
<ul>
<li>不同的类型优先级不同（根据长度而定）</li>
<li>char和short类型在参与运算时一律转换为int再进行运算。</li>
<li>浮点类型默认按双精度进行计算，所以就算有float类型，也会转换为double类型参与计算。</li>
<li>当有一个更高优先级的类型和一个低优先级的类型同时参与运算时，统一转换为高优先级运算，比如int和long参与运算，那么int转换为long再算，所以结果也是long类型，int和double参与运算，那么先把int转换为double再算。</li>
</ul>
<p>我们接着来看看强制类型转换，我们可以为手动去指定类型，强制类型转换格式如下：</p>
<pre><code class="language-c">(强制转换类型) 变量、常量或表达式;
</code></pre>
<p>比如：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = (int) 2.5;   //2.5是一个double类型的值，但是我们可以强制转换为int类型赋值给a，强制转换之后小数部分丢失
    printf(&quot;%d&quot;, a);
}
</code></pre>
<p>我们也可以对一个算式的结果进行类型转换：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    double a = 3.14;
    int b = (int) (a + 2.8);   //注意得括起来表示对整个算式的结果进行类型转换（括号跟数学中的挺像，也是提升优先级使用的，我们会在运算符部分详细讲解），不然强制类型转换只对其之后紧跟着的变量生效
    printf(&quot;%d&quot;, b);
}
</code></pre>
<p>在我们需要得到两个int相除之后带小数的结果时，强制类型转换就显得很有用：</p>
<pre><code class="language-java">#include &lt;stdio.h&gt;

int main() {
    int a = 10, b = 4;
    double c = a / b;    //不进行任何的类型转换，int除以int结果仍然是int，导致小数丢失
    double d = (double) a / b;   //对a进行强制类型转换，现在是double和int计算，根据上面自动类型转换规则，后面的int自动转换为double，结果也是double了，这样就是正确的结果了
    printf(&quot;不进行类型转换: %f, 进行类型转换: %f&quot;, c, d);
}
</code></pre>
<p>合理地使用强制类型转换，能够解决我们很多情况下的计算问题。</p>
<hr>
<h2 id="运算符">运算符</h2>
<p>前面我们了解了如何声明变量以及变量的类型转换，那么我们如何去使用这些变量来参与计算呢？这是我们本小节的重点。</p>
<h3 id="基本运算符">基本运算符</h3>
<p>基本运算符包含我们在数学中常用的一些操作，比如加减乘除，分别对应：</p>
<ul>
<li>加法运算符：+</li>
<li>减法运算符：-</li>
<li>乘法运算符：*</li>
<li>除法运算符：/（注意不是“\”，看清楚一点）</li>
</ul>
<p>当然，还有我们之前使用的赋值运算符<code>=</code>，我们先来看看赋值运算符的使用，其实在之前我们已经学习过了：</p>
<pre><code class="language-c">变量 = 值   //其中，值可以直接是一个数字、一个变量、表达式的结果等
</code></pre>
<p>实际上等号左边的内容准确的说应该是一个左值，不过大部分情况下都是变量，这里就不展开左值和右值的话题了（感兴趣的小伙伴可以去详细了解，有助于后面学习C++理解右值引用）</p>
<p>最简单的用法就是我们前面所说的，对一个变量进行赋值操作：</p>
<pre><code class="language-c">int a = 10;
</code></pre>
<p>也可以连续地使用赋值操作，让一连串的变量都等于后面的值：</p>
<pre><code class="language-c">int a, b;
a = b = 20;   //从右往左依次给b和a赋值20
</code></pre>
<p>可以看出，实际上<code>=</code>运算除了赋值之外，和加减乘除运算一样也是有结果的，比如上面的 a = 就是b = 20 运算的结果（可以看着一个整体），只不过运算的结果就是b被赋值的值，也就是20。</p>
<p>我们接着来看加减法，这个就和我们数学中的是一样的了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10, b = 5;
    printf(&quot;%d&quot;, a + b);   //打印 a + b 的结果
}
</code></pre>
<p>当然也可以像数学中那样写在一个数或是变量的最前面，表示是正数：</p>
<pre><code class="language-c">int a = +10, b = +5;
</code></pre>
<p>不过默认情况下就是正数，所以没必要去写一个+号。减法运算符其实也是一样的：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10, b = 5;
    printf(&quot;%d&quot;, a - b);   //打印 a - b 的结果
}
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = -10;   //等于 -10
    printf(&quot;%d&quot;, -a);   //输出 -a 的值，就反着来嘛
}
</code></pre>
<p>接着我们来看看乘法和除法运算：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 20, b = 10;
    printf(&quot;%d, %d&quot;, a * b, a / b);   //使用方式和上面的加减法是差不多的
}
</code></pre>
<p>还有一个比较有意思的取模运算：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 20, b = 8;
    printf(&quot;%d&quot;, a % b);   //取模运算实际上就是计算a除以b的余数
}
</code></pre>
<p>不过很遗憾，在C中没有指数相关的运算符（比如要计算5的10次方），在后面学习了循环语句之后，我们可以尝试来自己实现一个指数运算。</p>
<h3 id="运算符优先级">运算符优先级</h3>
<p>和数学中一样，运算符是有优先级的：</p>
<pre><code class="language-java">#include &lt;stdio.h&gt;

int main() {
    int a = 20, b = 10;
    printf(&quot;%d&quot;, a + a * b);   //如果没有优先级，那么结果应该是400
}
</code></pre>
<p>很明显这里的结果是考虑了优先级的：</p>
<figure data-type="image" tabindex="21"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ytdqy91yj211o02wq2u.jpg" alt="image-20220606205103154" loading="lazy"></figure>
<p>在数学中，加减运算的优先级是没有乘除运算优先级高的，所以我们需要先计算那些乘除法，最后再来进行加减法的计算，而C语言中也是这样，运算符之间存在优先级概念。我们在数学中，如果需要优先计算加减法再计算乘除法，那么就需要使用括号来提升加减法的优先级，C语言也可以：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 20, b = 10;
    printf(&quot;%d&quot;, (a + a) * b);   //优先计算 a + a 的结果，再乘以 b
}
</code></pre>
<p>那要是遇到多重的呢？类似于下面的这种：</p>
<pre><code>数学上的写法：[1 - (3 + 4)] x (-2 ÷ 1) = ?
</code></pre>
<p>那么我们在C中就可以这样编写：</p>
<pre><code class="language-java">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;%d&quot;, (1 - (3 + 4)) * (-2 / 1));   //其实写法基本差不多，只需要一律使用小括号即可
}
</code></pre>
<p>这样，我们就可以通过<code>()</code>运算符，来提升运算优先级了。</p>
<p>我们来总结一下，上面运算符优先级如下，从左往右依次递减：</p>
<ul>
<li><code>()</code>  &gt;   <code>+ - (做符号表示，比如-9)</code>  &gt;  <code>* / %</code>  &gt;  <code>+ - (做加减运算)</code>  &gt;  <code>=</code></li>
</ul>
<p>根据上面的优先级，我们来看看下面<code>a</code>的结果是什么：</p>
<pre><code class="language-c">int c;
int a = (3 + (c = 2)) * 6;
</code></pre>
<pre><code class="language-c">int b, c;
int a = (b = 5, c = b + 8);  //逗号运算符从前往后依次执行，赋值结果是最后边的结果
</code></pre>
<h3 id="自增自减运算符">自增自减运算符</h3>
<p>我们可以快速使用自增运算符来将变量的值<code>+1</code>，正常情况下我们想要让一个变量值自增需要：</p>
<pre><code class="language-c">int a = 10;
a = a + 1;
</code></pre>
<p>现在我们只需要替换为：</p>
<pre><code class="language-c">int a = 10;
++a;   //使用自增运算符，效果等价于 a = a + 1
</code></pre>
<p>并且它也是有结果的，除了做自增运算之外，它的结果是自增之后的值：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    //int b = a = a + 1;  下面效果完全一致
    int b = ++a;
    printf(&quot;%d&quot;, b);
}
</code></pre>
<p>当然我们也可以将自增运算符写到后面，和写在前面的区别是，它是先返回当前变量的结果，再进行自增的，顺序是完全相反的：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    int b = a++;   //写在后面和写在前面是有区别的
    printf(&quot;a = %d, b = %d&quot;, a, b);
}
</code></pre>
<blockquote>
<p>重点内容：自增运算符<code>++</code>在前，那么先自增再出结果；自增运算符<code>++</code>在后，那么先出结果再自增。各位小伙伴可以直接记运算符的位置，来方便记忆。</p>
</blockquote>
<p>那要是现在我们不想自增1而是自增2或是其他的数字呢？我们可以使用复合赋值运算符，正常情况下依然是使用普通的赋值运算符：</p>
<pre><code class="language-c">int a = 10;
a = a + 5;
</code></pre>
<p>但是现在我们可以简写：</p>
<pre><code class="language-c">int a = 10;
a += 5;
</code></pre>
<p>效果和上面是完全一样的，并且得到的结果也是在自增之后的：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    int b = a += 5;
    printf(&quot;a = %d&quot;, b);
}
</code></pre>
<p>复合赋值运算符不仅仅支持加法，还支持各种各样的运算：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    a %= 3;   //可以复合各种运算，比如加减乘除、模运算、包括我们我们还要讲到的位运算等
    printf(&quot;a = %d&quot;, a);
}
</code></pre>
<p>当然，除了自增操作之外，还有自减操作：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    a--;   //--是自减操作，相当于a = a - 1，也可以在前后写，规则和上面的自增是一样的
    printf(&quot;a = %d&quot;, a);
}
</code></pre>
<p>注意自增自减运算符和<code>+</code>、<code>-</code>做符号是的优先级一样，仅次于<code>()</code>运算符，所以在编写时一定要注意：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    int b = 5 * --a;
    printf(&quot;b = %d&quot;, b);
}
</code></pre>
<h3 id="位运算符">位运算符</h3>
<p>前面我们学习了乘法运算符<code>*</code>，当我们想要让一个变量的值变成2倍，只需要做一次乘法运算即可：</p>
<pre><code class="language-c">int a = 10;
a *= 2;  //很明显算完之后a就是20了
</code></pre>
<p>但是我们现在可以利用位运算来快速进行计算：</p>
<pre><code class="language-c">int a = 10;
a = a &lt;&lt; 1;   //也可以写成复合形式 a &lt;&lt;= 1
</code></pre>
<p>我们会发现这样运算之后得到的结果居然也是20，这是咋算出来的呢？实际上<code>&lt;&lt;</code>是让所有的bit位进行左移操作，上面就是左移1位，我们可以来看看：</p>
<ul>
<li>10  =  00001010     现在所以bit位上的数据左移一位    00010100   =   20</li>
</ul>
<p>是不是感觉特别神奇？就像我们在十进制中，做乘以10的操作一样：22乘以10那么就直接左移了一位变成220，而二进制也是一样的，如果让这些二进制数据左移的话，那么相当于在进行乘2的操作。</p>
<p>比如：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 6;
    a = a &lt;&lt; 2;   //让a左移2位，实际上就是 a * 2 * 2，a * 2的平方（类比十进制，其实还是很好理解的）
    printf(&quot;a = %d&quot;, a);
}
</code></pre>
<p>当然能左移那肯定也可以右移：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 6;
    a = a &gt;&gt; 1;   //右移其实就是除以2的操作
    printf(&quot;a = %d&quot;, a);
}
</code></pre>
<p>当然除了移动操作之外，我们也可以进行按位比较操作，先来看看按位与操作：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 6, b = 4;
    int c = a &amp; b;   //按位与操作
    printf(&quot;c = %d&quot;, c);
}
</code></pre>
<p>按位与实际上也是根据每个bit位来进行计算的：</p>
<ul>
<li>4  =  00000100</li>
<li>6  =  00000110</li>
<li>按位与实际上就是让两个数的每一位都进行比较，如果两个数对应的bit位都是1，那么结果的对应bit位上就是1，其他情况一律为0</li>
<li>所以计算结果为：00000100    =    4</li>
</ul>
<p>除了按位与之外，还有按位或运算：</p>
<pre><code class="language-c">int a = 6, b = 4;
int c = a | b;
</code></pre>
<ul>
<li>4  =  00000100</li>
<li>6  =  00000110</li>
<li>按位与实际上也是让两个数的每一位都进行比较，如果两个数对应bit位上其中一个是1，那么结果的对应bit位上就是1，其他情况为0。</li>
<li>所以计算结果为：00000110  =  6</li>
</ul>
<p>还有异或和按位非（按位否定）：</p>
<pre><code class="language-c">int a = 6, b = 4;
int c = a ^ b;    //注意^不是指数运算，表示按位异或运算，让两个数的每一位都进行比较，如果两个数对应bit位上不同时为1或是同时为0，那么结果就是1，否则结果就是0，所以这里的结果就是2
a = ~a;   //按位否定针对某个数进行操作，它会将这个数的每一个bit位都置反，0变成1，1变成0，猜猜会变成几
</code></pre>
<p>按位运算都是操作数据底层的二进制位来进行的。</p>
<h3 id="逻辑运算符">逻辑运算符</h3>
<p>最后我们来看一下逻辑运算符，逻辑运算符主要用到下一节的流程控制语句中。</p>
<p>逻辑运算符用于计算真和假，比如今天要么下雨要么不下雨，现在我们想要在程序中判断一下是否下雨了，这时就需要用到逻辑运算符，我们来举个例子：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    _Bool c = a &lt; 0;    //我们现在想要判断a的值是否小于0，我们可以直接使用小于符号进行判断，最后得到的结果只能是1或0
  	//虽然结果是一个整数，但是这里推荐使用_Bool类型进行接收，它只能表示0和1（更加专业一些）
    printf(&quot;c = %d&quot;, c);  
}
</code></pre>
<p>实际上在C语言中，0一般都表示为假，而非0的所有值（包括正数和负数）都表示为真，上面得到1表示真，0表示假。</p>
<p>除了小于符号可以判断大小之外，还有：<code>&lt;</code>、<code> &lt;=</code>、<code>&gt;=</code>、<code>&gt;</code></p>
<p>比如我们现在想要判断字符C是否为大写字母：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 'D';
    printf(&quot;c是否为大写字母：%d&quot;, c &gt;= 'A');    //由于底层存储的就是ASCII码，这里可以比较ASCII码，也可以写成字符的形式
}
</code></pre>
<p>但是我们发现，现在我们的判断只能判断一个条件，也就是说只能判断c是否是大于等于'A'的，但是不能同时判断c的值是否是小于等于'Z'的，所以这时，我们就需要利用逻辑与和逻辑或来连接两个条件了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 'D';
    printf(&quot;c是否为大写字母：%d&quot;, c &gt;= 'A' &amp;&amp; c &lt;= 'Z');   //使用&amp;&amp;表示逻辑与，逻辑与要求两边都是真，结果才是真
}
</code></pre>
<p>又比如现在我们希望判断c是否不是大写字母：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 'D';
    printf(&quot;c是否不为大写字母：%d&quot;, c &lt; 'A' || c &gt; 'Z');   //使用||表示逻辑或，只要两边其中一个为真或是都为真，结果就是真
}
</code></pre>
<p>当然我们也可以判断c是否为某个字母：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 'D';
    printf(&quot;c是否为字母A：%d&quot;, c == 'A');    //注意判断相等时使用==双等号
}
</code></pre>
<p>判断不相等也可以使用：</p>
<pre><code class="language-c">printf(&quot;c是否不为字母A：%d&quot;, c != 'A');
</code></pre>
<p>我们也可以对某个结果取反：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int i = 20;
    printf(&quot;i是否不小于20：%d&quot;, !(i &lt; 20));   //使用!来对结果取反，注意!优先级很高，一定要括起来，不然会直接对i生效
}
</code></pre>
<p>这里要注意一下<code>!</code>如果直接作用于某个变量或是常量，那么会直接按照上面的规则（0表示假，非0表示真）非0一律转换为0，0一律转换为1。</p>
<p>这里我们可以结合三目运算符来使用这些逻辑运算符：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int i = 0;
    char c = i &gt; 10 ? 'A' : 'B';    //三目运算符格式为：expression ? 值1 : 值2，返回的结果会根据前面判断的结果来的
    //这里是判断i是否大于10，如果大于那么c的值就是A，否则就是B
  	printf(&quot;%d&quot;, c);
}
</code></pre>
<p>最后，我们来总结一下前面认识的所有运算符的优先级，从上往下依次降低：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>解释</th>
<th>结合方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>()</td>
<td>同数学中的括号，直接提升到最高优先级</td>
<td>由左向右</td>
</tr>
<tr>
<td>! ~ ++ -- + -</td>
<td>否定，按位否定，增量，减量，正负号</td>
<td>由右向左</td>
</tr>
<tr>
<td>* / %</td>
<td>乘，除，取模</td>
<td>由左向右</td>
</tr>
<tr>
<td>+ -</td>
<td>加，减</td>
<td>由左向右</td>
</tr>
<tr>
<td>&lt;&lt; &gt;&gt;</td>
<td>左移，右移</td>
<td>由左向右</td>
</tr>
<tr>
<td>&lt; &lt;= &gt;= &gt;</td>
<td>小于，小于等于，大于等于，大于</td>
<td>由左向右</td>
</tr>
<tr>
<td>== !=</td>
<td>等于，不等于</td>
<td>由左向右</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
<td>由左向右</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>由左向右</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>由左向右</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>由左向右</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
<td>由左向右</td>
</tr>
<tr>
<td>? :</td>
<td>条件</td>
<td>由右向左</td>
</tr>
<tr>
<td>= += -= *= /= &amp;= ^= |= &lt;&lt;= &gt;&gt;=</td>
<td>各种赋值</td>
<td>由右向左</td>
</tr>
<tr>
<td>,</td>
<td>逗号（顺序）</td>
<td>由左向右</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="流程控制">流程控制</h2>
<p>前面我们学习了运算符，知道该如何使用运算符来计算我们想要的内容，但是仅仅依靠计算我们的程序还没办法实现丰富多样的功能，我们还得加点额外的控制操作。</p>
<h3 id="分支语句-if">分支语句 - if</h3>
<p>我们可能会有这样的一个需求，就是判断某个条件，当满足此条件时，才执行某些代码，那这个时候该怎么办呢？我们可以使用<code>if</code>语句来实现：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int i = 0;
    if(i &gt; 20) {    //我们只希望i大于20的时候才执行下面的打印语句
        printf(&quot;Hello World!&quot;);
    }
  	printf(&quot;Hello World?&quot;);   //后面的代码在if之外，无论是否满足if条件，都跟后面的代码无关，所以这里的代码任何情况下都会执行
}
</code></pre>
<p>if语句的标准格式如下：</p>
<pre><code class="language-c">if(判断条件) {
    执行的代码
}
</code></pre>
<p>当然如果只需要执行一行代码的话，可以省略花括号：</p>
<pre><code class="language-c">if(判断条件)
  一行执行的代码   //注意这样只有后一行代码生效，其他的算作if之外的代码了
</code></pre>
<p>现在我们需求升级了，我们需要判断某个条件，当满足此条件时，执行某些代码，而不满足时，我们想要执行另一段代码，我们就可以结合else语句来实现：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int i = 0;
    if(i &gt; 20) {
        printf(&quot;Hello World!&quot;);   //满足if条件才执行
    } else {
        printf(&quot;LBWNB&quot;);   //不满足if条件才执行
    }
}
</code></pre>
<p>但是这样可能还是不够用，比如我们现在希望判断学生的成绩，不同分数段打印的等级不一样，比如90以上就是优秀，70以上就是良好，60以上是及格，其他的都是不及格，那么这种我们又该如何判断呢？要像这样进行连续判断，我们需要使用<code>else-if</code>来完成：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int score =  2;
    if(score &gt;= 90) {
        printf(&quot;优秀&quot;);
    } else if (score &gt;= 70) {
        printf(&quot;良好&quot;);
    } else if (score &gt;= 60){
        printf(&quot;及格&quot;);
    } else{
        printf(&quot;不及格&quot;);
    }
}
</code></pre>
<p><code>if</code>这类的语句（包括我们下面还要介绍的三种）都是支持嵌套使用的，比如我们现在希望低于60分的同学需要补习，0-30分需要补Java，30-60分需要补C++，这时我们就需要用到嵌套：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int score =  2;
    if(score &lt; 60) {   //先判断不及格
        if(score &gt; 30) {   //在内层再嵌套一个if语句进行进一步的判断
            printf(&quot;学习C++&quot;);
        } else{
            printf(&quot;学习Java&quot;);
        }
    }
}
</code></pre>
<h3 id="分支语句-switch">分支语句 - switch</h3>
<p>前面我们介绍了if语句，我们可以通过一个if语句轻松地进行条件判断，然后根据对应的条件，来执行不同的逻辑，当然除了这种方式之外，我们也可以使用switch语句来实现，它更适用于多分支的情况：</p>
<pre><code class="language-c">switch (目标) {   //我们需要传入一个目标，比如变量，或是计算表达式等
  case 匹配值:    //如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码
    代码...
    break;    //代码执行结束后需要使用break来结束，否则会继续溜到下一个case继续执行代码
}
</code></pre>
<p>比如现在我们要根据学生的等级进行分班，学生有ABC三个等级：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 'A';
    switch (c) {  //这里目标就是变量c
        case 'A':    //分别指定ABC三个匹配值，并且执行不同的代码
            printf(&quot;去尖子班！准备冲刺985大学！&quot;);
            break;   //执行完之后一定记得break，否则会继续向下执行下一个case中的代码
        case 'B':
            printf(&quot;去平行班！准备冲刺一本！&quot;);
            break;
        case 'C':
            printf(&quot;去职高深造。&quot;);
            break;
    }
}
</code></pre>
<p>switch可以精准匹配某个值，但是它不能进行范围判断，比如我们要判断分数段，这时用switch就很鸡肋了。</p>
<p>当然除了精准匹配之外，其他的情况我们可以用default来表示：</p>
<pre><code class="language-c">switch (目标) {
    case: ...
    default:
    		其他情况下执行的代码
}
</code></pre>
<p>比如：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 'A';
    switch (c) {
        case 'A':
            printf(&quot;去尖子班！&quot;);
            break;
        case 'B':
            printf(&quot;去平行班！&quot;);
            break;
        case 'C':
            printf(&quot;去差生班！&quot;);
            break;
        default:   //其他情况一律就是下面的代码了
            printf(&quot;去读职高，分流&quot;);
    }
}
</code></pre>
<p>当然switch中可以继续嵌套其他的流程控制语句，比如if：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 'A';
    switch (c) {
        case 'A':
            if(c == 'A') {    //嵌套一个if语句
                printf(&quot;去尖子班！&quot;);   
            }
            break;
        case 'B':
            printf(&quot;去平行班！&quot;);
            break;
    }
}
</code></pre>
<h3 id="循环语句-for">循环语句 - for</h3>
<p>通过前面的学习，我们了解了如何使用分支语句来根据不同的条件执行不同的代码，我们接着来看第二种重要的流程控制语句，循环语句。</p>
<p>我们在某些时候，可能需要批量执行某些代码：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;伞兵一号卢本伟准备就绪！&quot;);   //把这句话给我打印三遍
    printf(&quot;伞兵一号卢本伟准备就绪！&quot;);
    printf(&quot;伞兵一号卢本伟准备就绪！&quot;);
}
</code></pre>
<p>遇到这种情况，我们由于还没学习循环语句，那么就只能写N次来实现这样的多次执行。现在我们可以使用for循环语句来多次执行：</p>
<pre><code class="language-c">for (表达式1表达式2;表达式3) {
    循环体
}
</code></pre>
<p>我们来介绍一下：</p>
<ul>
<li>表达式1：在循环开始时仅执行一次。</li>
<li>表达式2：每次循环开始前会执行一次，要求为判断语句，用于判断是否可以结束循环，若结果为真，那么继续循环，否则结束循环。</li>
<li>表达式3：每次循环完成后会执行一次。</li>
<li>循环体：每次循环都会执行循环体里面的内容，直到循环结束。</li>
</ul>
<p>一个标准的for循环语句写法如下：</p>
<pre><code class="language-c">//比如现在我们希望循环4次
for (int i = 0; i &lt; 4; ++i) {
    //首先定义一个变量i用于控制循环结束
  	//表达式2在循环开始之前判断是否小于4
  	//表达式3每次循环结束都让i自增一次，这样当自增4次之后不再满足条件，循环就会结束，正好4次循环
}
</code></pre>
<p>我们来看看按顺序打印的结果：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    //比如现在我们希望循环4次
    for (int i = 0; i &lt; 4; ++i) {
        printf(&quot;%d, &quot;, i);
    }
}
</code></pre>
<figure data-type="image" tabindex="22"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h34bzvoslpj2136030aa3.jpg" alt="image-20220611152257585" loading="lazy"></figure>
<p>这样，利用循环我们就可以批量执行各种操作了。</p>
<p>注意，如果表达式2我们什么都不写，那么会默认判定为真：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    for (int i = 0; ; ++i) {   //表达式2不编写任何内容，默认为真，这样的话循环永远都不会结束
        printf(&quot;%d, &quot;, i);
    }
}
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://s2.loli.net/2022/06/17/AHoTpOIEYu8Jc7R.jpg" alt="image-20220612164349847" loading="lazy"></figure>
<p>所以，如果我们想要编写一个无限循环，其实什么都不用写就行了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    for (;;) {   //什么都不写直接无限循环，但是注意，两个分号还是要写的
        printf(&quot;Hello World!\n&quot;);   //这里用到了\n表示换行
    }
}
</code></pre>
<p>当然，我们也可以在循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字：</p>
<pre><code class="language-c">for (int i = 0; i &lt; 10; ++i) {
    if(i == 5) break;   //比如现在我们希望在满足某个条件下提前终止循环，可以使用break关键字来跳出循环
    printf(&quot;%d&quot;, i);
}
</code></pre>
<figure data-type="image" tabindex="24"><img src="https://s2.loli.net/2022/06/17/vW37gTywX92AI1r.jpg" alt="image-20220613101128788" loading="lazy"></figure>
<p>可以看到，当满足条件时，会直接通过break跳出循环，循环不再继续下去，直接结束掉。</p>
<p>我们也可以加速循环：</p>
<pre><code class="language-c">for (int i = 0; i &lt; 10; ++i) {
    if(i == 5) continue;   //使用continue关键字会加速循环，无论后面有没有未执行完的代码，都会直接开启下一轮循环
    printf(&quot;%d&quot;, i);
}
</code></pre>
<figure data-type="image" tabindex="25"><img src="https://s2.loli.net/2022/06/17/WeHJkqmEfGcn53r.jpg" alt="image-20220613101847762" loading="lazy"></figure>
<p>虽然使用break和continue关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（就近原则）：</p>
<pre><code class="language-c">for (int i = 1; i &lt; 4; ++i) {
    for (int j = 1; j &lt; 4; ++j) {
        if(i == j) continue;    //当i == j时加速循环
        printf(&quot;%d, %d\n&quot;, i, j);
    }
}
</code></pre>
<figure data-type="image" tabindex="26"><img src="https://s2.loli.net/2022/06/17/Kh9U3l7rEqtGuQ1.jpg" alt="image-20220613102100374" loading="lazy"></figure>
<p>可以看到，continue仅仅加速的是内层循环，而对外层循环没有任何效果，同样的，break也只会终结离它最近的：</p>
<pre><code class="language-c">for (int i = 1; i &lt; 4; ++i) {
    for (int j = 1; j &lt; 4; ++j) {
        if(i == j) break;    //当i == j时终止循环
        printf(&quot;%d, %d\n&quot;, i, j);
    }
}
</code></pre>
<figure data-type="image" tabindex="27"><img src="https://s2.loli.net/2022/06/17/6TaNChfX9tI351r.jpg" alt="image-20220613102347086" loading="lazy"></figure>
<h3 id="循环语句-while">循环语句 - while</h3>
<p>前面我们介绍了for循环语句，我们接着来看第二种while循环，for循环要求我们填写三个表达式，而while相当于是一个简化版本，它只需要我们填写循环的维持条件即可，比如：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    while (1) {   //每次循环开始之前都会判断括号内的内容是否为真，如果是就继续循环
        printf(&quot;Hello World!\n&quot;);   //这里会无限循环
    }
}
</code></pre>
<p>相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当<code>i</code>大于10时需要结束循环，但是<code>i</code>在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int i = 100;   //比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确
    while (i &gt; 0) {   //现在唯一知道的是循环条件，只要大于0那么就可以继续除
        printf(&quot;%d, &quot;, i);
        i /= 2;   //每次循环都除以2
    }
}
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://s2.loli.net/2022/06/17/xBE3NKZipVqJwjP.jpg" alt="image-20220612170911315" loading="lazy"></figure>
<p>while也支持使用break和continue来进行循环的控制：</p>
<pre><code class="language-c">int i = 100;
while (i &gt; 0) {
    if(i &lt; 30) break;
    printf(&quot;%d, &quot;, i);
    i /= 2;
}
</code></pre>
<figure data-type="image" tabindex="29"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h36er98fx8j213002u0sy.jpg" alt="image-20220613102935994" loading="lazy"></figure>
<p>我们可以反转循环判断的位置，可以先执行循环内容，然后再做循环条件判断，这里要用到<code>do-while</code>语句：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    do {  //无论满不满足循环条件，先执行循环体里面的内容
        printf(&quot;Hello World!&quot;);
    } while (0);   //再做判断，如果判断成功，开启下一轮循环，否则结束
}
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://s2.loli.net/2022/06/17/clJF7jrBqWAtbZ4.jpg" alt="image-20220613103504978" loading="lazy"></figure>
<h3 id="实战寻找水仙花数">实战：寻找水仙花数</h3>
<blockquote>
<p>“水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指**一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身。**例如：1^3 + 5^3+ 3^3 = 153。”</p>
</blockquote>
<p>现在请你设计一个C语言程序，打印出所有1000以内的水仙花数。</p>
<h3 id="实战打印九九乘法表">实战：打印九九乘法表</h3>
<figure data-type="image" tabindex="31"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h36fd08zh4j21dk0bmq4j.jpg" alt="image-20220613105029975" loading="lazy"></figure>
<p>现在我们要做的是在我们的程序中，也打印出这样的一个乘法表出来，请你设计一个C语言程序来实现它。</p>
<figure data-type="image" tabindex="32"><img src="https://s2.loli.net/2022/06/17/BW7lvFXy4GRb1P5.jpg" alt="image-20220613105519595" loading="lazy"></figure>
<h3 id="实战斐波那契数列解法其一">实战：斐波那契数列解法其一</h3>
<blockquote>
<p>斐波那契数列（Fibonacci sequence），又称<a href="https://baike.baidu.com/item/%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2/115896">黄金分割</a>数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：**1、1、2、3、5、8、13、21、34、……*<em>在数学上，斐波那契数列以如下被以递推的方法定义：<em>F</em>(0)=0，<em>F</em>(1)=1, <em>F</em>(n)=<em>F</em>(n - 1)+<em>F</em>(n - 2)（<em>n</em> ≥ 2，<em>n</em> ∈ N</em>）在现代物理、准<a href="https://baike.baidu.com/item/%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84/10401467">晶体结构</a>、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从 1963 年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p>
</blockquote>
<p>斐波那契数列：1，1，2，3，5，8，13，21，34，55，89...，不难发现一个规律，实际上从第三个数开始，每个数字的值都是前两个数字的和，现在请你设计一个C语言程序，可以获取斐波那契数列上任意一位的数字，比如获取第5个数，那么就是5。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int target = 7, result;  //target是要获取的数，result是结果

    //请在这里实现算法

    printf(&quot;%d&quot;, result);
}
</code></pre>
<hr>
<h2 id="数组">数组</h2>
<p>现在我们有一个新的需求，我们需要存储2022年每个月都天数，那么此时，为了保存这12个月的天数，我们就得创建12个变量：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int january = 31, february = 28, march = 31 ...
}
</code></pre>
<p>这样是不是太累了点？万一我们想保存100个商品的售价，那岂不是得创建100个变量？这肯定不行啊。</p>
<h3 id="数组的创建和使用">数组的创建和使用</h3>
<p>为了解决这种问题，我们可以使用数组，什么是数组呢？简单来说，就是存放数据的一个组，所有的数据都统一存放在这一个组中，一个数组可以同时存放多个数据。比如现在我们想保存12个月的天数，那么我们只需要创建一个int类型的数组就可以了，它可以保存很多个int类型的数据，这些保存在数组中的数据，称为“元素”：</p>
<pre><code class="language-c">int arr[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};  //12个月的数据全部保存在了一起
</code></pre>
<p>可以看到，数组的定义方式也比较简单：</p>
<pre><code class="language-c">类型 数组名称[数组大小] = {数据1, 数据2...};  //后面的数据可以在一开始的时候不赋值，并且数组大小必须是整数
</code></pre>
<p>注意数组只能存放指定类型的数据，一旦确定是不能更改的，因为数组声明后，会在内存中开辟一块连续的区域，来存放这些数据，所以类型和长度必须在一开始就明确。</p>
<figure data-type="image" tabindex="33"><img src="https://s2.loli.net/2022/06/17/ESJ5WmydXrxfwsU.jpg" alt="image-20220613113423268" loading="lazy"></figure>
<p>创建数组的方式有很多种：</p>
<pre><code class="language-c">int a[10];   //直接声明int类型数组，容量为10

int b[10] = {1, 2, 4};   //声明后，可以赋值初始值，使用{}囊括，不一定需要让10个位置都有初始值，比如这里仅仅是为前三个设定了初始值，注意，跟变量一样，如果不设定初始值，数组内的数据并不一定都是0

int c[10] = {1, 2, [4] = 777, [9] = 666}; //我们也可以通过 [下标] = 的形式来指定某一位的初始值，注意下标是从0开始的，第一个元素就是第0个下标位置，比如这里数组容量为10，那么最多到9

int c[] = {1, 2, 3};  //也可以根据后面的赋值来决定数组长度
</code></pre>
<p>基本类型都可以声明数组：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char str[] = {'A', 'B', 'C'};   //多个字符
  
    char str2[] = &quot;ABC&quot;;  //实际上字符串就是多个字符的数组形式，有关字符串我们会在下一节进行讲解
}
</code></pre>
<p>那么数组定义好了，如何去使用它呢？比如我们现在需要打印12个月的天数：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int arr[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    for (int i = 0; i &lt; 12; ++i) {
        int days = arr[i];   //直接通过数组 名称[下标] 来访问对应的元素值，再次提醒，下标是从0开始的，不是1
        printf(&quot;2022年 %d 月的天数是：%d 天\n&quot;, (i + 1), days);
    }
}
</code></pre>
<figure data-type="image" tabindex="34"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h36h0hctkdj21b204w0t5.jpg" alt="image-20220613114739872" loading="lazy"></figure>
<p>当然我们也可以对数组中的值进行修改：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int arr[] = {666, 777, 888};
    arr[1] = 999;   //比如我们现在想要让第二个元素的值变成999
    printf(&quot;%d&quot;, arr[1]);   //打印一下看看是不是变成了999
}
</code></pre>
<figure data-type="image" tabindex="35"><img src="https://s2.loli.net/2022/06/17/Q4bnsaIyz7NXReF.jpg" alt="image-20220613114928435" loading="lazy"></figure>
<p>注意，和变量一样，如果只是创建数组但是不赋初始值的话，因为是在内存中随机申请的一块空间，有可能之前其他地方使用过，保存了一些数据，所以数组内部的元素值并不一定都是0：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int arr[10];
    for (int i = 0; i &lt; 10; ++i) {
        printf(&quot;%d, &quot;, arr[i]);
    }
}
</code></pre>
<figure data-type="image" tabindex="36"><img src="https://s2.loli.net/2022/06/17/63BLiUNexSjJgym.jpg" alt="image-20220613115108971" loading="lazy"></figure>
<p>不要尝试去访问超出数组长度位置的数据，虽然可以编译通过，但是会给警告，这些数据是毫无意义的：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int arr[] = {111, 222, 333};
    printf(&quot;%d&quot;, arr[3]);  //不能去访问超出数组长度的元素，很明显这里根本就没有第四个元素
}
</code></pre>
<h3 id="多维数组">多维数组</h3>
<p>数组不仅仅只可以有一个维度，我们可以创建二维甚至多维的数组，简单来说就是，存放数组的数组（套娃了属于是）：</p>
<pre><code class="language-c">int arr[][2] = {{20, 10}, {18, 9}};   //可以看到，数组里面存放的居然是数组
//存放的内层数组的长度是需要确定的，存放数组的数组和之前一样，可以根据后面的值决定
</code></pre>
<p>比如现在我们要存放2020-2022年每个月的天数，那么此时用一维数组肯定是不方便了，我们就可以使用二维数组来处理：</p>
<pre><code class="language-c">int arr[3][12] = {{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, //2020年是闰年，2月有29天
                  {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
                  {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}};
</code></pre>
<p>这样，我们就通过二维数组将这三年每个月的天数都保存下来了。</p>
<figure data-type="image" tabindex="37"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h36hpql8tpj211s05w3yp.jpg" alt="image-20220613121156024" loading="lazy"></figure>
<p>那么二维数组又该如何去访问呢？</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int arr[3][12] = {{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, //2020年是闰年，2月有29天
                      {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
                      {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}};
    printf(&quot;%d&quot;, arr[0][1]);   //比如现在我们想要获取2020年2月的天数，首先第一个是[0]表示存放的第一个数组，第二个[1]表示数组中的第二个元素
}
</code></pre>
<p>当然除了二维还可以上升到三维、四维：</p>
<pre><code class="language-c">int arr[2][2][2] = {{{1, 2}, {1, 2}}, {{1, 2}, {1, 2}}};
</code></pre>
<p>有关多维数组，暂时先介绍到这里。</p>
<h3 id="实战冒泡排序算法">实战：冒泡排序算法</h3>
<p>现在有一个int数组，但是数组内的数据是打乱的，现在请你通过C语言，实现将数组中的数据按<strong>从小到大</strong>的顺序进行排列：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int arr[10] = {3, 5, 7, 2, 9, 0, 6, 1, 8, 4};  //乱序的
    //请编写代码对以上数组进行排序
}
</code></pre>
<p>这里我们使用冒泡排序算法来实现，此算法的核心思想是：</p>
<ul>
<li>假设数组长度为N</li>
<li>进行N轮循环，每轮循环都选出一个最大的数放到后面。</li>
<li>每次循环中，从第一个数开始，让其与后面的数两两比较，如果更大，就交换位置，如果更小，就不动。</li>
</ul>
<p>动画演示：https://visualgo.net/zh/sorting?slide=2-2</p>
<h3 id="实战斐波那契数列解法其二">实战：斐波那契数列解法其二</h3>
<p>学习了数组，我们来看看如何利用数组来计算斐波那契数列，这里采用动态规划的思想。</p>
<blockquote>
<p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有<a href="https://baike.baidu.com/item/%E6%9C%80%E4%BC%98%E5%80%BC">最优值</a>的解。动态规划算法与<a href="https://baike.baidu.com/item/%E5%88%86%E6%B2%BB%E6%B3%95">分治法</a>类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从<a href="https://baike.baidu.com/item/%E8%BF%99%E4%BA%9B%E5%AD%90">这些子</a>问题的解得到原问题的解。</p>
</blockquote>
<p>我们可以在一开始创建一个数组，然后从最开始的条件不断向后推导，从斐波那契数列的规律我们可以得知：</p>
<ul>
<li><code>fib[i] = fib[i - 1] + fib[i - 2]</code>（这里<code>fib</code>代表斐波那契数列）</li>
</ul>
<p>得到这样的一个关系（递推方程）就好办了，我们要求解数列第<code>i</code>个位置上的数，只需要知道<code>i - 1</code>和<code>i - 2</code>的值即可，这样，一个大问题，就分成了两个小问题，比如现在我们要求解斐波那契数列的第5个元素：</p>
<ul>
<li><code>fib[4] = fib[3] + fib[2]</code>现在我们只需要知道<code>fib[3]</code>和<code>fib[2]</code>即可，那么我们接着来看：</li>
<li><code>fib[3] = fib[2] + fib[1]</code>以及<code>fib[2] = fib[1] + fib[0]</code></li>
<li>由于<code>fib[0]</code>和<code>fib[1]</code>我们已经明确知道是<code>1</code>了，那么现在问题其实已经有结果了，把这些小问题的结果组合起来不就能得到原来大问题的结果了吗？</li>
</ul>
<p>现在请你设计一个C语言程序，利用动态规划的思想解决斐波那契数列问题。</p>
<h3 id="实战打家劫舍">实战：打家劫舍</h3>
<p>我们继续通过一道简单的算法题来强化动态规划思想。</p>
<p><strong>来源：力扣（LeetCode）No.198 打家劫舍</strong>：https://leetcode.cn/problems/house-robber/</p>
<blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：[1,2,3,1]<br>
输出：4<br>
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>
偷窃到的最高金额 = 1 + 3 = 4 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：[2,7,9,3,1]<br>
输出：12<br>
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>
偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
</blockquote>
<figure data-type="image" tabindex="38"><img src="https://s2.loli.net/2022/06/17/WvZltqPwyUEhkJY.jpg" alt="image-20220613124415156" loading="lazy"></figure>
<p>这道题我们也可以很轻松地按照上面的动态规划思路来处理，首先我们可以将问题分为子问题，比如现在有<code>[2,7,9,3,1]</code>五个房屋，这个问题看起来比较复杂，我们不妨先将大问题先简化成小问题，我们来看看只有N个房屋的情况：</p>
<ul>
<li>假设现在只有<code>[2]</code>这一个房屋，那么很明显，我可以直接去偷一号房，得到2块钱，所以当有一个房子时最大能偷到2块钱。</li>
<li>假设现在有<code>[2, 7]</code>这两个房屋，那么很明显，我可以直接去偷二号房，得到7块钱，所以当有两个房子时最大能偷到7块钱。</li>
<li>假设现在只有<code>[2, 7, 9]</code>这三个房屋，我们就要来看看了，是先偷一号房再偷三号房好，还是只偷二号房好，根据前面的结论，如果我们偷了一号房，那么就可以继续偷三号房，并且得到的钱就是从一号房过来的钱+三号房的钱，也就是2+9块钱，但是如果只偷二号房的话，那么就只能得到7块钱，所以，三号房能够偷到的最大金额有以下关系（dp是我们求出的第i个房屋的最大偷钱数量，value表示房屋价值，max表示取括号中取最大的一个）：
<ul>
<li><code>dp[i] = max(dp[i - 1], dp[i - 2] + value[i])</code>  -&gt; <strong>递推方程已得到</strong></li>
</ul>
</li>
<li>这样就不难求出：<code>dp[2] = max(dp[1], dp[0] + value[i])</code> = <code>dp[2] = max(7, 2 + 9)</code> = <code>dp[2] = 11</code>，所以有三个房屋时最大的金额是11块钱。</li>
<li>所以，实际上我们只需要关心前面计算出来的盗窃最大值即可，而不需要关心前面到底是怎么在偷。</li>
<li>我们以同样的方式来计算四个房屋<code>[2, 7, 9, 3]</code>的情况：
<ul>
<li><code>dp[3] = max(dp[2], dp[1] + value[3])</code> = <code>dp[3] = max(11, 7 + 3)</code> = <code>dp[3] = 11</code></li>
</ul>
</li>
<li>所以，当有四个房屋时，我们依然采用先偷一后偷三的方案，不去偷四号，得到最大价值11块钱。</li>
</ul>
<p>好了，现在思路已经出来了，我们直接上算法吧，现在请你实现下面的C语言程序：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int arr[] = {2,7,9,3,1}, size = 5, result;

    //请补充程序

    printf(&quot;%d&quot;, result);
}
</code></pre>
<p>力扣提交，建议各位小伙伴学习了函数和指针之后再回来看看，这里暂时可以跳过。</p>
<figure data-type="image" tabindex="39"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h36jb2k9ldj20yy06kq3h.jpg" alt="image-20220613130702396" loading="lazy"></figure>
<pre><code class="language-c">int max(int a, int b) {
    return a &gt; b ? a : b;
}

int rob(int* nums, int numsSize){
    if(numsSize == 0) return 0;
    if(numsSize == 1) return nums[0];
    if(numsSize == 2) return max(nums[1], nums[0]);

    int dp[numsSize];
    dp[0] = nums[0];
    dp[1] = max(nums[1], nums[0]);

    for (int i = 2; i &lt; numsSize; ++i) {
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
    }

    return dp[numsSize - 1];
}
</code></pre>
<hr>
<h2 id="字符串">字符串</h2>
<p>前面我们学习了数组，而对于字符类型的数组，比较特殊，它实际上可以作为一个字符串（String）表示，字符串就是一个或多个字符的序列，比如我们在一开始认识的<code>&quot;Hello World!&quot;</code>，像这样的多个字符形成的一连串数据，就是一个字符串，而<code>printf</code>函数接受的第一个参数也是字符串。</p>
<p>那么，我们就来认识一下字符串。</p>
<h3 id="字符串的创建和使用">字符串的创建和使用</h3>
<p>在C语言中并没有直接提供存储字符串的类型，我们熟知的能够存储字符的只有char类型，但是它只能存储单个字符，而一连串的字符想要通过变量进行保存，那么就只能依靠数组了，char类型的数组允许我们存放多个字符，这样的话就可以表示字符串了。</p>
<p>比如我们现在想要存储<code>Hello</code>这一连串字符：</p>
<pre><code class="language-c">char str[] = {'H', 'e', 'l', 'l', 'o', '\0'};  //直接保存单个字符，但是注意，无论内容是什么，字符串末尾必须添加一个‘\0’字符（ASCII码为0）表示结束。
printf(&quot;%s&quot;, str);   //用%s来作为一个字符串输出
</code></pre>
<p>不过这样写起来实在是太麻烦了，我们可以使用更加简便的写法：</p>
<pre><code class="language-c">char str[] = &quot;Hello&quot;;   //直接使用双引号将所有的内容囊括起来，并且也不需要补充\0（但是本质上是和上面一样的字符数组）
//也可以添加 const char str[] = &quot;Hello World!&quot;; 双引号囊括的字符串实际上就是一个const char数组类型的值
printf(&quot;%s&quot;, str);
</code></pre>
<p>这下终于明白了，原来我们一直在写的双引号，其实表示的就是一个字符串。</p>
<p>那么现在请各位小伙伴看看下面的写法有什么不同：</p>
<pre><code class="language-c">&quot;c&quot;
'c'
</code></pre>
<p>我们发现一个问题，char类型只能保存ASCII编码表中的字符，但是我们发现实际上中文也是可以正常打印的：</p>
<pre><code class="language-c">printf(&quot;你这瓜保熟吗&quot;);
</code></pre>
<figure data-type="image" tabindex="40"><img src="https://s2.loli.net/2022/06/17/jC9Vn4MbgOzt7LB.jpg" alt="image-20220616114344138" loading="lazy"></figure>
<p>这是什么情况？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文。这时，我们就需要扩展字符集了。</p>
<blockquote>
<p>我们可以使用两个甚至多个字节来表示一个中文字符，这样我们能够表示的数量就大大增加了，GB2132方案规定当连续出现两个大于127的字节时（注意不考虑符号位，此时相当于是第一个bit位一直为1了），表示这是一个中文字符（所以为什么常常有人说一个英文字符占一字节，一个中文字符占两个字节），这样我们就可以表示出超过7000种字符了，不仅仅是中文，甚至中文标点、数学符号等，都可以被正确的表示出来。</p>
<pre><code class="language-c">10000011 10000110   //这就是一个连续出现都大于127的字节（注意这里是不考虑符号位的）
</code></pre>
<p>不过这样能够表示的内容还是不太够，除了那些常见的汉字之外，还有很多的生僻字，比如龘、錕、釿、拷这类的汉字，后来干脆直接只要第一个字节大于127，就表示这是一个汉字的开始，无论下一个字节是什么内容（甚至原来的128个字符也被编到新的表中），这就是Windows至今一直在使用的默认GBK编码格式。</p>
<p>虽然这种编码方式能够很好的解决中文无法表示的问题，但是由于全球还有很多很多的国家以及很多很多种语言，所以我们的最终目标是能够创造一种可以表示全球所有字符的编码方式，整个世界都使用同一种编码格式，这样就可以同时表示全球的语言了。所以这时就出现了一个叫做ISO的（国际标准化组织）组织，来定义一套编码方案来解决所有国家的编码问题，这个新的编码方案就叫做Unicode，规定每个字符必须使用俩个字节，即用16个bit位来表示所有的字符（也就是说原来的那128个字符也要强行用两位来表示）</p>
<p>但是这样的话实际上是很浪费资源的，因为这样很多字符都不会用到两字节来保存，但是又得这样去表示，这就导致某些字符浪费了很多空间。所以最后就有了UTF-8编码格式，区分每个字符的开始是根据字符的高位字节来区分的，比如用一个字节表示的字符，第一个字节高位以“0”开头；用两个字节表示的字符，第一个字节的高位为以“110”开头，后面一个字节以“10开头”；用三个字节表示的字符，第一个字节以“1110”开头，后面俩字节以“10”开头；用四个字节表示的字符，第一个字节以“11110”开头，后面的三个字节以“10”开头：</p>
<table>
<thead>
<tr>
<th>Unicode符号范围（十六进制）</th>
<th>UTF-8编码方式(二进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000 0000 ~ 0000 007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0000 0080 ~ 0000 07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0000 0800 ~ 0000 FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0001 0000 ~ 0010 FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>所以如果我们的程序需要表示多种语言，最好采用UTF-8编码格式。</p>
</blockquote>
<p>简而言之，我们的中文实际上是依靠多个char来进行表示的。</p>
<figure data-type="image" tabindex="41"><img src="https://s2.loli.net/2022/06/17/yJjkVABhZCa5Dx2.jpg" alt="image-20220616134302528" loading="lazy"></figure>
<figure data-type="image" tabindex="42"><img src="https://s2.loli.net/2022/06/17/ckD2LWU7MlfSTtb.jpg" alt="image-20220616134330805" loading="lazy"></figure>
<p>这样，我们就了解了字符串的使用。</p>
<h3 id="scanf-gets-puts函数">scanf、gets、puts函数</h3>
<p>函数我们会在下一章详细介绍，不过这里还是要再提到一个比较重要的函数。</p>
<p>前面我们认识了<code>printf</code>函数，实际上这个函数就是用于打印字符串到控制台，我们只需要填入一个字符串和后续的参数即可。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    const char str[] = &quot;Hello World!&quot;;   //注意printf需要填写一个const char数组进去，也就是字符串
    printf(str);
}
</code></pre>
<p>现在我们知道该如何输出，那么输入该如何实现呢，比如我们现在希望将我们想要说的话告诉程序，让程序从控制台读取我们输入的内容，这时我们就需要使用到<code>scanf</code>函数了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char str[10];
    scanf(&quot;%s&quot;, str);   //使用scanf函数来接受控制台输入，并将输入的结果按照格式，分配给后续的变量
  	//比如这里我们想要输入一个字符串，那么依然是使用%s（和输出是一样的占位符），后面跟上我们要赋值的数组（存放输入的内容）
    printf(&quot;输入的内容为：%s&quot;, str);
}
</code></pre>
<p>可以看到，成功接收到用户输入：</p>
<figure data-type="image" tabindex="43"><img src="https://s2.loli.net/2022/06/17/RoEjaFVL4P9fWil.jpg" alt="image-20220616141313060" loading="lazy"></figure>
<p>当然除了能够扫描成字符串之外，我们也可以直接扫描为一个数字：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a, b;
    scanf(&quot;%d&quot;, &amp;a);   //连续扫描两个int数字
    scanf(&quot;%d&quot;, &amp;b);   //注意，如果不是数组类型，那么这里在填写变量时一定要在前面添加一个&amp;符号（至于为什么，下一章在指针小节中会详细介绍）这里的&amp;不是做与运算，而是取地址操作。

    printf(&quot;a + b = %d&quot;, a + b);   //扫描成功后，我们来计算a + b的结果
}
</code></pre>
<p>除了使用<code>scanf</code>之外，我们也可以使用字符串专用的函数来接受字符串类型的输入和输出：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char str[10];
    gets(str);   //gets也是接收控制台输入，然后将结果丢给str数组中
    puts(str);   //puts其实就是直接打印字符串到控制台
}
</code></pre>
<p>当然也有专门用于字符输入输出的函数：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int c = getchar();
    putchar(c);
}
</code></pre>
<p>由于我们目前还没有学习函数，所以这里稍微提及一下即可。</p>
<h3 id="实战回文串判断">实战：回文串判断</h3>
<p>“回文串”是一个正读和反读都一样的字符串，请你实现一个C语言程序，判断用户输入的字符串（仅出现英文字符）是否为“回文”串。</p>
<blockquote>
<p>ABCBA    就是一个回文串，因为正读反读都是一样的</p>
<p>ABCA    就不是一个回文串，因为反着读不一样</p>
</blockquote>
<h3 id="实战字符串匹配kmp算法">实战：字符串匹配KMP算法</h3>
<p>现在有两个字符串：</p>
<blockquote>
<p>str1 = &quot;abcdabbc&quot;</p>
<p>str2 = &quot;cda&quot;</p>
</blockquote>
<p>现在请你设计一个C语言程序，判断第一个字符串中是否包含了第二个字符串，比如上面的例子中，很明显第一个字符串包含了第二个字符串。</p>
<ul>
<li>暴力解法</li>
<li>KMP算法</li>
</ul>
<p>我们着重来看一下KMP算法，实际上我们发现，暴力解法虽然很好理解，但是可能会做一些毫无意义的比较：</p>
<figure data-type="image" tabindex="44"><img src="https://s2.loli.net/2022/06/24/RgP7i1dYsxNGTnb.png" alt="image-20220624105606429" loading="lazy"></figure>
<p>当发生不匹配时，又会重新开始比较下一个：</p>
<figure data-type="image" tabindex="45"><img src="https://s2.loli.net/2022/06/24/NZ8sEG9Q2bCAMlv.png" alt="image-20220624105650078" loading="lazy"></figure>
<p>但是我们不难发现，因为不匹配的位置发生在第三个字符，而前面是<code>a,b</code>两个字符都匹配，显然完全没有必要再继续挨着去比较<code>a</code>和<code>b</code>了，因为很明显不可能匹配。</p>
<figure data-type="image" tabindex="46"><img src="https://s2.loli.net/2022/06/24/tB9KHhYXZN6g2bz.png" alt="image-20220624142802170" loading="lazy"></figure>
<p>实际上我们可以直接跳过<code>b</code>，因为我们一眼就能看出肯定不匹配，所以直接跳过从后面继续判断，能节省不少的时间。我相信如果让你通过自己的人脑去进行匹配，也是按照这样的方式去比较的吧？</p>
<p>不过关键点就在于怎么在程序中得知该不该跳过呢，又该跳过多少个字符不判断呢？所以我们在拿到子串的时候，就需要根据子串来计算一个叫做<code>next</code>的数组，与子串的长度相同，它存储了<strong>当不匹配发生在对应的位置上时，应该在哪一个位置开始继续比较。</strong></p>
<p>这里说一下怎么去求（计算机领域大佬总结出来的算法）：</p>
<blockquote>
<p>从第一位开始依次推导。</p>
<p>next数组的第一位一定是0。</p>
<p>从第二位开始（用<code>i</code>表示），将第<code>i-1</code>个字符（也就是前一个）与其对应的<code>next[i - 1] - 1</code>位上的字符进行比较。</p>
<p>如果相等，那么<code>next[i]</code>位置的值就是<code>next[i - 1] + 1</code></p>
<p>如果不相等，则继续向前计算一次<code>next[next[i-1] - 1] - 1</code>位置上的字符和第<code>i-1</code>个字符是否相同，直到找到相等的为止，并且这个位置对应的值加上<code>1</code>就是<code>next[i]</code>的值了，要是都已经到头了都没遇到相等的，那么<code>next[i]</code>直接等于<code>1</code>。</p>
</blockquote>
<p>比如：</p>
<figure data-type="image" tabindex="47"><img src="https://s2.loli.net/2022/06/24/cvFlTtLy2QhDbo6.png" alt="image-20220624113812730" loading="lazy"></figure>
<p>首先一二位明确是0和1，这里我们从第三位开始计算，根据我们前面的规则：</p>
<ol>
<li>首先判断<code>str[next[1] - 1] == str[1]</code>，显然不相等。</li>
<li>此时无法继续向前走了，<code>next[2]</code>直接等于<code>1</code>即可。</li>
</ol>
<figure data-type="image" tabindex="48"><img src="https://s2.loli.net/2022/06/24/iEmjYkhTdz8CqfV.png" alt="image-20220624114135711" loading="lazy"></figure>
<p>我们接着来看第四位：</p>
<ol>
<li>首先判断<code>str[next[2] - 1] == str[2]</code>，发现相等。</li>
<li>此时<code>next[2]</code>直接等于<code>next[2 - 1] + 1</code>即可。</li>
</ol>
<figure data-type="image" tabindex="49"><img src="https://s2.loli.net/2022/06/24/ZDPF5BMtqpiAO9f.png" alt="image-20220624114743673" loading="lazy"></figure>
<p>最后一位也是一样的判断方式：</p>
<ol>
<li>首先判断<code>str[next[3] - 1] == str[3]</code>，发现相等。</li>
<li>此时<code>next[3]</code>直接等于<code>next[3 - 1] + 1</code>即可。</li>
</ol>
<figure data-type="image" tabindex="50"><img src="https://s2.loli.net/2022/06/24/u21aR6hZVT3P7OA.png" alt="image-20220624115015885" loading="lazy"></figure>
<p>至此，next数组求解完毕，之后比较只需要多考虑一下next数组即可：</p>
<figure data-type="image" tabindex="51"><img src="https://s2.loli.net/2022/06/24/8jLzZVOmgQHUcwW.png" alt="image-20220624115417358" loading="lazy"></figure>
<p>当不匹配发生在第三位时，此时<code>next[2] = 1</code>， 所以我们将第一个元素移动到c的位置重新开始比较：</p>
<figure data-type="image" tabindex="52"><img src="https://s2.loli.net/2022/06/24/gAY6DCnV2FOKSlo.png" alt="image-20220624142642394" loading="lazy"></figure>
<p>发现不匹配，直接继续向后比较，重复上述操作，像这样这样跳着去比较就大大节省了时间。</p>
<p>OK，理论差不多结束了，上代码。</p>
<p>有关C语言的基础部分内容，我们就讲解到这里，从下一章开始，难度将会有一定的提升，所以请各位小伙伴务必将本章知识点梳理清楚，牢记心中。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker容器技术]]></title>
        <id>https://muouren7.github.io/post/Docker容器技术/</id>
        <link href="https://muouren7.github.io/post/Docker容器技术/">
        </link>
        <updated>2022-10-14T08:06:38.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://s2.loli.net/2022/06/29/bnXgrjtzkx7YaLo.png" alt="image-20220629215534772" loading="lazy"></figure>
<h1 id="docker容器技术">Docker容器技术</h1>
<p>Docker是一门平台级别的技术，涉及的范围很广，所以，在开始之前，请确保你完成：<strong>Java SpringBoot 篇</strong>（推荐完成SpringCloud篇再来）视频教程及之前全部路线，否则学习会非常吃力，另外推荐额外掌握：《计算机网络》、《操作系统》相关知识。学一样东西不能完全靠记忆来完成，而是需要结合自己所学的基础知识加以理解，一般来说，单凭记忆能够掌握的东西往往是最廉价的。</p>
<p>**Docker官网：**https://www.docker.com</p>
<p>**课前准备：**配置2C2G以上Linux服务器一台，云服务器、虚拟机均可。</p>
<h2 id="容器技术入门">容器技术入门</h2>
<p>随着时代的发展，Docker也逐渐走上了历史舞台，曾经我们想要安装一套环境，需要花费一下午甚至一整天来配置和安装各个部分（比如运行我们自己的SpringBoot应用程序，可能需要安装数据库、安装Redis、安装MQ等，各种各样的环境光是安装就要花费很多时间，真的是搞得心态爆炸），而有了Docker之后，我们的程序和环境部署就变得非常简单了，我们只需要将这些环境一起打包成一个镜像。而到服务器上部署时，可以直接下载镜像实现一键部署，是不是很方便？</p>
<p>包括我们在学习SpringCloud需要配置的各种组件，可能在自己电脑的环境中运行会遇到各种各样的问题（可能由于电脑上各种环境没配置，导致无法运行），而现在只需要下载镜像就能直接运行，所有的环境全部在镜像中配置完成，开箱即用。</p>
<p>真的有这么神奇吗？我们来试试看。</p>
<h3 id="环境安装和部署">环境安装和部署</h3>
<p>首先我们还是先将Docker环境搭建好（建议和我同一个环境，不然出了问题只能自己想办法了），这里我们使用：</p>
<ul>
<li>Ubuntu 22.04 操作系统</li>
</ul>
<p>Docker分为免费的CE（Community Edition）社区版本和EE（Enterprise Edition）企业级付费版本，所以我们这里选择docker-ce进行安装。官方安装文档：https://docs.docker.com/engine/install/ubuntu/</p>
<p>首先安装一些工具：</p>
<pre><code class="language-sh">sudo apt-get install ca-certificates curl gnupg lsb-release
</code></pre>
<p>不过在Ubuntu22.04已经默认安装好了。接着安装官方的GPG key：</p>
<pre><code class="language-sh">sudo mkdir -p /etc/apt/keyrings

curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
</code></pre>
<p>最后将Docker的库添加到apt资源列表中：</p>
<pre><code class="language-sh">echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null
</code></pre>
<p>接着我们更新一次apt：</p>
<pre><code class="language-sh"> sudo apt update
</code></pre>
<p>最后安装Docker CE版本：</p>
<pre><code class="language-sh"> sudo apt install docker-ce
</code></pre>
<p>等待安装完成就可以了：</p>
<figure data-type="image" tabindex="2"><img src="https://s2.loli.net/2022/06/30/D1GXAQdUsgmTawq.png" alt="image-20220630161240162" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://s2.loli.net/2022/06/30/oI26yQiqhABN3UP.png" alt="image-20220630161341541" loading="lazy"></figure>
<p>可以看到安装成功后版本是20.10.17，当然可能你们安装的时候就是更新的版本了。最后我们将当前用户添加到docker用户组中，不然每次使用docker命令都需要sudo执行，很麻烦：</p>
<pre><code class="language-sh">sudo usermod -aG docker &lt;用户名&gt;
</code></pre>
<p>配置好后，我们先退出SSH终端，然后重新连接就可以生效了。</p>
<p>这样我们Docker 的学习环境就配置好了，现在我们就尝试通过Docker来部署一个Nginx服务器试试看，使用很简单，只需要一个命令就可以了（当然现在看不懂没关系，我们后面会细嗦）：</p>
<pre><code class="language-sh">sudo docker run -d -p 80:80 nginx
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://s2.loli.net/2022/06/30/sPVpLI9bXlzdKeO.png" alt="image-20220630165259663" loading="lazy"></figure>
<p>首选它会从镜像仓库中下载对应的镜像，国内访问速度还行，不需要单独配置镜像源。接着下载完成后，就会在后台运行了，我们可以使用浏览器访问试试看：</p>
<figure data-type="image" tabindex="5"><img src="https://s2.loli.net/2022/06/30/fP5TsQnqUbmXoaA.png" alt="image-20220630165430159" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://s2.loli.net/2022/06/30/lPZYrUn2D1gNjx8.png" alt="image-20220630165440751" loading="lazy"></figure>
<p>可以看到，Nginx服务器已经成功部署了，但是实际上我们并没有在Ubuntu中安装Nginx，而是通过Docker运行的镜像来进行服务器搭建的，是不是感觉玩法挺新奇的。除了Nginx这种简单的应用之外，我们还可以通过Docker来部署复杂应用，之后我们都会一一进行讲解的。</p>
<h3 id="从虚拟机到容器">从虚拟机到容器</h3>
<p>前面我们成功安装了Docker学习环境，以及浅尝了一下Docker为我们带来的应用快速部署。在正式进入学习之前，我们就先从Docker的发展开始说起。</p>
<p>在Docker出现之前，虚拟化技术可以说是占据了主导地位。首先我们来谈谈为什么会出现虚拟化技术，我们知道在企业中服务器可以说是必不可少的一种硬件设施了，服务器也是电脑，但是不像我们的家用电脑，服务器的配置是非常高的，我们家用电脑的CPU可能最高配也就20核了，内存很少有超过128G的电脑，64G内存的家用电脑可以算奢侈了。而服务器不一样，服务器级别的CPU动辄12核，甚至服务器还能同时安装多块CPU，能直接堆到好几十核：</p>
<figure data-type="image" tabindex="7"><img src="https://s2.loli.net/2022/06/30/DPxA9MsZ3WGl62X.png" alt="image-20220630171220207" loading="lazy"></figure>
<p>我们家用级CPU一般是AMD的锐龙系列和Intel的酷睿系列（比如i3 i5 i7 i9），而服务器CPU一般是Intel的志强（Xeno）系列，这种CPU的特点就是核心数非常多：</p>
<figure data-type="image" tabindex="8"><img src="https://s2.loli.net/2022/06/30/cKlhRZ9Sw1Q4uEX.png" alt="image-20220630172135408" loading="lazy"></figure>
<p>并且服务器CPU相比家用CPU的功耗也会更大，因此服务器CPU的发热量非常高，如果你有幸去过机房，你会听见散热风扇猛烈转动的声音（但是服务器CPU的频率没有家用级CPU高，一般大型游戏要求的是高频率而不是核心数，而且功耗也比较大，所以并不适合做家用电脑，所以以后在网上买台式机，看到什么“i9级”CPU千万别买，是这些黑心商家把国外服务器上淘汰下来的服务器CPU（洋垃圾）装成电脑卖给你，所以会很便宜，同时核心数又能媲美i9，所以还是一分钱一分货实在）</p>
<p>服务器无论是CPU资源还是内存资源都远超家用电脑，而我们编写的Java后端项目，最后都会运行在这些服务器上，不过有一个问题，服务器既然有这么丰富的硬件资源，就跑咱们这一个小Java后端，是不是有点核弹炸蚊子的感觉了？可能顶多就用了服务器5%的硬件资源，服务器这么牛就运行个这也太浪费了吧。</p>
<p>所以，为了解决这种资源利用率只有5%-15%的情况，咱们能不能想个办法，把这一台服务器分成多个小服务器使用，每个小服务器只分配一部分的资源，比如分一个小服务器出去，只给2个CPU核心和4G内存。但是由于设计上的问题，我们的电脑只能同时运行一个操作系统，那么怎么办呢？此时虚拟化技术就开始兴起了。</p>
<p>虚拟化使用软件来模拟硬件并创建虚拟计算机系统。这样一来，企业便可以在单台服务器上运行多个虚拟系统，也就是运行多个操作系统和应用，而这可以实现规模经济以及提高效益。比如我们电脑上经常使用的VMware就是一种民用级虚拟化软件：</p>
<figure data-type="image" tabindex="9"><img src="https://s2.loli.net/2022/06/30/St3hfELQHNdRZmA.png" alt="image-20220630173915254" loading="lazy"></figure>
<p>我们可以使用VMware来创建虚拟机，这些虚拟机实际上都是基于我们当前系统上的VMware软件来运行的，当然VMware也有服务器专用的虚拟化软件，有了虚拟化之后，我们的服务器就像这样：</p>
<figure data-type="image" tabindex="10"><img src="https://s2.loli.net/2022/06/30/BmnC1xETQM4uRHO.png" alt="image-20220630174945749" loading="lazy"></figure>
<p>相当于通过虚拟机模拟了很多来电脑出来，这样我们就可以在划分出来的多台虚拟机上分别安装系统和部署我们的应用程序了，并且我们可以自由分配硬件资源，合理地使用。一般在企业中，不同的应用程序可能会被分别部署到各个服务器上，隔离开来，此时使用虚拟机就非常适合。</p>
<p>实际上我们在什么腾讯云、阿里云租的云服务器，都是经过虚拟化技术划分出来的虚拟机而已。</p>
<p>那么，既然虚拟机都这么方便了，容器又是怎么杀出一条血路的呢？我们先来看看什么是容器。</p>
<p>容器和虚拟机比较类似，都可以为应用提供封装和隔离，都是软件，但是容器中的应用运行是寄托于宿主操作系统的，实际上依然是在直接使用操作系统的资源，当然应用程序之间环境依然是隔离的，而虚拟机则是完全模拟一台真正的电脑出来，直接就是两台不同的电脑。</p>
<figure data-type="image" tabindex="11"><img src="https://s2.loli.net/2022/06/30/31GZSh5DE9Vilet.png" alt="image-20220630181037698" loading="lazy"></figure>
<p>因此容器相比虚拟机就简单多了，并且启动速度也会快很多，开销小了不少。</p>
<p>不过容器火的根本原因还是它的集装箱思想，我们知道，如果我们要写一个比如论坛、电商这类的Java项目，那么数据库、消息队列、缓存这类中间件是必不可少的，因此我们如果想要将一个服务部署到服务器，那么实际上还要提前准备好各种各样的环境，先安装好MySQL、Redis、RabbitMQ等应用，配置好了环境，再将我们的Java应用程序启动，整个流程下来，光是配置环境就要浪费大量的时间，如果是大型的分布式项目，可能要部署很多台机器，那岂不是我们得一个一个来？项目上个线就要花几天时间，显然是很荒唐的。</p>
<p>而容器可以打包整个环境，比较MySQL、Redis等以及我们的Java应用程序，可以被一起打包为一个镜像，当我们需要部署服务时，只需要像我们之前那样，直接下载镜像运行即可，不需要再进行额外的配置了，整个镜像中环境是已经配置好的状态，开箱即用。</p>
<figure data-type="image" tabindex="12"><img src="https://s2.loli.net/2022/06/30/NTnU8iSj51CspFw.png" alt="image-20220630182136717" loading="lazy"></figure>
<p>而我们要重点介绍的就是Docker了，可以看到它的图标就是一只鲸鱼，鲸鱼的上面是很多个集装箱，每个集装箱就是我们的整个环境+应用程序，Docker可以将任何应用及其依赖打包为一个轻量级，可移植，自包含的容器，容器可以运行在几乎所有的操作系统上。</p>
<h3 id="容器工作机制简述">容器工作机制简述</h3>
<p>我们先来看看Docker的整体架构：</p>
<figure data-type="image" tabindex="13"><img src="https://s2.loli.net/2022/06/30/PeaxwNQXkiYSlUv.png" alt="image-20220630184857540" loading="lazy"></figure>
<p>实际上分为三个部分：</p>
<ul>
<li>Docker 客户端：也就是我们之前使用的docker命令，都是在客户端上执行的，操作会发送到服务端上处理。</li>
<li>Docker 服务端：服务端就是启动容器的主体了，一般是作为服务在后台运行，支持远程连接。</li>
<li>Registry：是存放Docker镜像的仓库，跟Maven一样，也可以分公有和私有仓库，镜像可以从仓库下载到本地存放。</li>
</ul>
<p>当我们需要在服务器上部署一个已经打包好的应用和环境，我们只需要下载打包好的镜像就可以了，我们前面执行了：</p>
<pre><code class="language-sh">sudo docker run -d -p 80:80 nginx
</code></pre>
<p>实际上这个命令输入之后：</p>
<ol>
<li>Docker客户端将操作发送给服务端，告诉服务端我们要运行nginx这个镜像。</li>
<li>Docker服务端先看看本地有没有这个镜像，发现没有。</li>
<li>接着只能从公共仓库Docker Hub去查找下载镜像了。</li>
<li>下载完成，镜像成功保存到本地。</li>
<li>Docker服务端加载Nginx镜像，启动容器开始正常运行（注意容器和其他容器之间，和外部之间，都是隔离的，互不影响）</li>
</ol>
<p>所以，整个流程中，Docker就像是一搜运输船，镜像就像是集装箱，通过运输船将世界各地的货物送往我们的港口，货物到达港口后，Docker并不关心集装箱里面的是什么，只需要创建容器开箱即用就可以了。相比我们传统的手动安装配置环境，不知道方便了几个层次。</p>
<p>不过容器依然是寄托于宿主主机的运行的，所以一般在生产环境下，都是通过虚拟化先创建多台主机，然后再到各个虚拟机中部署Docker，这样的话，运维效率就大大提升了。</p>
<p>从下一章开始，我们就正式地来学习一下Docker的各种操作。</p>
<hr>
<h2 id="容器与镜像">容器与镜像</h2>
<p>要启动容器最关键的就是镜像，我们来看看镜像相关的介绍。</p>
<h3 id="初识容器镜像">初识容器镜像</h3>
<p>首先我们来了解一下镜像的相关操作，比如现在我们希望把某个镜像从仓库下载到本地，这里使用官方的hello-world镜像：</p>
<pre><code class="language-sh">docker pull hello-world
</code></pre>
<p>只需要输入<code>pull</code>命令，就可以直接下载到指定的镜像了：</p>
<figure data-type="image" tabindex="14"><img src="https://s2.loli.net/2022/07/01/tZ4S2HYvNKr7qiD.png" alt="image-20220701111043417" loading="lazy"></figure>
<p>可以看到对上面一行有一句Using default tag，实际上一个镜像的名称是由两部分组成的，一个是<code>repository</code>，还有一个是<code>tag</code>，一般情况下约定<code>repository</code>就是镜像名称，<code>tag</code>作为版本，默认为latest，表示最新版本。所以指定版本运行的话：</p>
<pre><code class="language-sh">docker pull 名称:版本
</code></pre>
<p>之后为了教学方便，我们就直接使用默认的tag，不去指定版本了。</p>
<p>镜像下载之后会存放在本地，要启动这个镜像的容器，实际上就像我们之前那样，输入<code>run</code>命令就可以了：</p>
<pre><code class="language-sh">docker run hello-world
</code></pre>
<p>当然如果仅仅是只想创建而不想马上运行的话，可以使用<code>create</code>命令：</p>
<pre><code class="language-sh">docker create hello-world
</code></pre>
<p>可以看到成功启动了：</p>
<figure data-type="image" tabindex="15"><img src="https://s2.loli.net/2022/07/01/Brl4cnK8WsjP7LV.png" alt="image-20220701111314331" loading="lazy"></figure>
<p>启动之后，会使用当前镜像自动创建一个容器，我们可以输入<code>ps</code>命令来查看当前容器的容器列表：</p>
<pre><code>docker ps -a
</code></pre>
<p>注意后面要加一个<code>-a</code>表示查看所有容器（其他选项可以使用-h查看），如果不加的话，只会显示当前正在运行的容器，而HelloWorld是一次性的不是Nginx那样的常驻程序，所以容器启动打印了上面的内容之后，容器就停止运行了：</p>
<figure data-type="image" tabindex="16"><img src="https://s2.loli.net/2022/07/01/zMN3TPR7aHu5YGb.png" alt="image-20220701111840091" loading="lazy"></figure>
<p>可以看到容器列表中有我们刚刚创建的hello-world以及我们之前创建的nginx（注意同一个镜像可以创建多个容器），每个容器都有一个随机生成的容器ID写在最前面，后面是容器的创建时间以及当前的运行状态，最后一列是容器的名称，在创建容器时，名称可以由我们指定也可以自动生成，这里就是自动生成的。</p>
<p>我们可以手动指定名称启动，在使用<code>run</code>命令时，添加<code>--name</code>参数即可：</p>
<pre><code class="language-sh">docker run --name=lbwnb hello-world
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://s2.loli.net/2022/07/01/qOblnhr5CJiIBG6.png" alt="image-20220701125951980" loading="lazy"></figure>
<p>我们可以手动开启处于停止状态的容器：</p>
<pre><code class="language-sh"> docker start &lt;容器名称/容器ID&gt;
</code></pre>
<p>注意启动的对象我们要填写容器的ID或是容器的名称才可以，容器ID比较长，可以不写全只写一半，但是你要保证你输入的不完全容器ID是唯一的。</p>
<figure data-type="image" tabindex="18"><img src="https://s2.loli.net/2022/07/01/XfFORtqhK9lcBi7.png" alt="image-20220701124845982" loading="lazy"></figure>
<p>如果想要停止容器直接输入<code>stop</code>命令就可以了：</p>
<pre><code class="language-sh"> docker stop &lt;容器名称/容器ID&gt;
</code></pre>
<p>或是重启：</p>
<pre><code class="language-sh"> docker restart &lt;容器名称/容器ID&gt;
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://s2.loli.net/2022/07/01/Q2tor6KRIeUEhO4.png" alt="image-20220701125025173" loading="lazy"></figure>
<p>如果我们不需要使用容器了，那么可以将容器删除，但是注意只有容器处于非运行状态时才可以删除：</p>
<pre><code class="language-sh">docker rm &lt;容器名称/容器ID&gt;
</code></pre>
<p>当然如果我们希望容器在停止后自动删除，我们可以在运行时添加<code>--rm</code>参数：</p>
<pre><code class="language-sh">docker run --rm 镜像名称
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://s2.loli.net/2022/07/01/3MlPUpjoV1Qg8DX.png" alt="image-20220701125108834" loading="lazy"></figure>
<p>删除后，容器将不复存在，当没有任何关于nginx的容器之后，我们可以删除nginx的本地镜像：</p>
<figure data-type="image" tabindex="21"><img src="https://s2.loli.net/2022/07/01/bmHqND36yCUBPVj.png" alt="image-20220701125204728" loading="lazy"></figure>
<p>我们可以使用<code>images</code>命令来检查一下当前本地有那些镜像：</p>
<pre><code class="language-sh">docker images
</code></pre>
<figure data-type="image" tabindex="22"><img src="https://s2.loli.net/2022/07/01/fEscbGJXw4e7YFK.png" alt="image-20220701125514145" loading="lazy"></figure>
<p>至此，我们已经了解了Docker的简单使用，在后面的学习中，我们还会继续认识更多的玩法。</p>
<h3 id="镜像结构介绍">镜像结构介绍</h3>
<p>前面我们了解了Docker的相关基本操作，实际上容器的基石就是镜像，有了镜像才能创建对应的容器实例，那么我们就先从镜像的基本结构开始说起，我们来看看镜像到底是个什么样的存在。</p>
<p>我们在打包项目时，实际上往往需要一个基本的操作系统环境，这样我们才可以在这个操作系统上安装各种依赖软件，比如数据库、缓存等，像这种基本的系统镜像，我们称为base镜像，我们的项目之后都会基于base镜像进行打包，当然也可以不需要base镜像，仅仅是基于当前操作系统去执行简单的命令，比如我们之前使用的hello-world就是。</p>
<p>一般base镜像就是各个Linux操作系统的发行版，比如我们正在使用的Ubuntu，还有CentOS、Kali等等。这里我们就下载一下CentOS的base镜像：</p>
<pre><code class="language-sh">docker pull centos
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://s2.loli.net/2022/07/01/oFKxiMzA3fs2aIl.png" alt="image-20220701132622893" loading="lazy"></figure>
<p>可以看到，CentOS的base镜像就已经下载完成，不像我们使用完整系统一样，base镜像的CentOS省去了内核，所以大小只有272M，这里需要解释一下base镜像的机制：</p>
<figure data-type="image" tabindex="24"><img src="https://s2.loli.net/2022/07/01/dvmqAjKHkucbLFh.png" alt="image-20220701133111829" loading="lazy"></figure>
<p>Linux操作体系由内核空间和用户空间组成，其中内核空间就是整个Linux系统的核心，Linux启动后首先会加<code>bootfs</code>文件系统，加载完成后会自动卸载掉，之后会加载用户空间的文件系统，这一层是我们自己可以进行操作的部分：</p>
<ul>
<li>bootfs包含了BootLoader和Linux内核，用户是不能对这层作任何修改的，在内核启动之后，bootfs会自动卸载。</li>
<li>rootfs则包含了系统上的常见的目录结构，包括<code>/dev</code>、<code> /proc</code>、 <code>/bin</code>等等以及一些基本的文件和命令，也就是我们进入系统之后能够操作的整个文件系统，包括我们在Ubuntu下使用的apt和CentOS下使用的yum，都是用户空间上的。</li>
</ul>
<p>base镜像底层会直接使用宿主主机的内核，也就是说你的Ubuntu内核版本是多少，那么base镜像中的CentOS内核版本就是多少，而rootfs则可以在不同的容器中运行多种不同的版本。所以，base镜像实际上只有CentOS的rootfs，因此只有300M大小左右，当然，CentOS里面包含多种基础的软件，还是比较臃肿的，而某些操作系统的base镜像甚至都不到10M。</p>
<p>使用<code>uname</code>命令可以查看当前内核版本：</p>
<figure data-type="image" tabindex="25"><img src="https://s2.loli.net/2022/07/01/mZjupCUktL7Ab2R.png" alt="image-20220701135056123" loading="lazy"></figure>
<p>因此，Docker能够同时模拟多种Linux操作系统环境，就不足为奇了，我们可以尝试启动一下刚刚下载的base镜像：</p>
<pre><code class="language-sh">docker run -it centos
</code></pre>
<p>注意这里需要添加<code>-it</code>参数进行启动，其中<code>-i</code>表示在容器上打开一个标准的输入接口，<code>-t</code>表示分配一个伪tty设备，可以支持终端登录，一般这两个是一起使用，否则base容器启动后就自动停止了。</p>
<figure data-type="image" tabindex="26"><img src="https://s2.loli.net/2022/07/01/13BYcCWHsDMrwvq.png" alt="image-20220701135834325" loading="lazy"></figure>
<p>可以看到使用ls命令能够查看所有根目录下的文件，不过很多命令都没有，连clear都没有，我们来看看内核版本：</p>
<figure data-type="image" tabindex="27"><img src="https://s2.loli.net/2022/07/01/PtGwRWfXlTh67qm.png" alt="image-20220701140018095" loading="lazy"></figure>
<p>可以看到内核版本是一样的（这也是缺点所在，如果软件对内核版本有要求的话，那么此时使用Docker就直接寄了），我们输入<code>exit</code>就可以退出容器终端了，可以看到退出后容器也停止了：</p>
<figure data-type="image" tabindex="28"><img src="https://s2.loli.net/2022/07/01/u5MQnWVihlbkyx1.png" alt="image-20220701140225415" loading="lazy"></figure>
<p>当然我们也可以再次启动，注意启动的时候要加上<code>-i</code>才能进入到容器进行交互，否则会在后台运行：</p>
<figure data-type="image" tabindex="29"><img src="https://s2.loli.net/2022/07/01/QCsY5EyGSja6Khl.png" alt="image-20220701140706977" loading="lazy"></figure>
<p>基于base镜像，我们就可以在这基础上安装各种各样的软件的了，几乎所有的镜像都是通过在base镜像的基础上安装和配置需要的软件构建出来的：</p>
<figure data-type="image" tabindex="30"><img src="https://s2.loli.net/2022/07/01/SDwEqz2b7lA9nJa.png" alt="image-20220701143105247" loading="lazy"></figure>
<p>每安装一个软件，就在base镜像上一层层叠加上去，采用的是一种分层的结构，这样多个容器都可以将这些不同的层次自由拼装，比如现在好几个容器都需要使用CentOS的base镜像，而上面运行的软件不同，此时分层结构就很爽了，我们只需要在本地保存一份base镜像，就可以给多个不同的容器拼装使用，是不是感觉很灵活？</p>
<p>我们看到除了这些软件之外，最上层还有一个可写容器层，这个是干嘛的呢，为什么要放在最上面？</p>
<p>我们知道，所有的镜像会叠起来组成一个统一的文件系统，如果不同层中存在相同位置的文件，那么上层的会覆盖掉下层的文件，最终我们看到的是一个叠加之后的文件系统。当我们需要修改容器中的文件时，实际上并不会对镜像进行直接修改，而是在最顶上的容器层（最上面一般称为容器层，下面都是镜像层）进行修改，不会影响到下面的镜像，否则镜像就很难实现多个容器共享了。所以各个操作如下：</p>
<ul>
<li>文件读取：要读取一个文件，Docker会最上层往下依次寻找，找到后则打开文件。</li>
<li>文件创建和修改：创建新文件会直接添加到容器层中，修改文件会从上往下依次寻找各个镜像中的文件，如果找到，则将其复制到容器层，再进行修改。</li>
<li>删除文件：删除文件也会从上往下依次寻找各个镜像中的文件，一旦找到，并不会直接删除镜像中的文件，而是在容器层标记这个删除操作。</li>
</ul>
<p>也就是说，我们对整个容器内的文件进行的操作，几乎都是在最上面的容器层进行的，我们是无法干涉到下面所有的镜像层文件的，这样就很好地保护了镜像的完整性，才能实现多个容器共享使用。</p>
<h3 id="构建镜像">构建镜像</h3>
<p>前面我们已经了解了Docker镜像的结构，实际上所有常用的应用程序都有对应的镜像，我们只需要下载这些镜像然后就可以使用了，而不需要自己去手动安装，顶多需要进行一些特别的配置。当然要是遇到某些冷门的应用，可能没有提供镜像，这时就要我们手动去安装，接着我们就来看看如何构建我们自己的Docker镜像。构建镜像有两种方式，一种是使用<code>commit</code>命令来完成，还有一种是使用Dockerfile来完成，我们先来看第一种。</p>
<p>这里我们就做一个简单的例子，比如我们现在想要在Ubuntu的base镜像中安装Java环境，并将其打包为新的镜像（这个新的镜像就是一个包含Java环境的Ubuntu系统镜像）</p>
<p>咱们先启动Ubuntu镜像，然后使用<code>yum</code>命令（跟apt比较类似）来安装Java环境，首先是<code>run</code>命令：</p>
<pre><code class="language-sh">docker pull ubuntu
</code></pre>
<figure data-type="image" tabindex="31"><img src="https://s2.loli.net/2022/07/01/tP5rhQuqfpxcRHL.png" alt="image-20220701151405640" loading="lazy"></figure>
<p>接着启动：</p>
<figure data-type="image" tabindex="32"><img src="https://s2.loli.net/2022/07/01/l86G4dK71UwcZPi.png" alt="image-20220701151433520" loading="lazy"></figure>
<p>直接使用apt命令来安装Java环境，在这之前先更新一下，因为是最小安装所以本地没有任何软件包：</p>
<figure data-type="image" tabindex="33"><img src="https://s2.loli.net/2022/07/01/RAzQr7P8C9aJwxK.png" alt="image-20220701151600847" loading="lazy"></figure>
<p>接着输入：</p>
<pre><code class="language-sh">apt install openjdk-8-jdk
</code></pre>
<p>等待安装完成：</p>
<figure data-type="image" tabindex="34"><img src="https://s2.loli.net/2022/07/01/Fezitl7PDb19BL4.png" alt="image-20220701152018041" loading="lazy"></figure>
<p>这样，我们就完成了对Java环境的安装了，接着我们就可以退出这个镜像然后将其构建为新的镜像：</p>
<figure data-type="image" tabindex="35"><img src="https://s2.loli.net/2022/07/01/LAIx5GYCJhsbmSo.png" alt="image-20220701152130041" loading="lazy"></figure>
<p>使用<code>commit</code>命令可以将容器保存为新的镜像：</p>
<pre><code class="language-sh">docker commit 容器名称/ID 新的镜像名称
</code></pre>
<figure data-type="image" tabindex="36"><img src="https://s2.loli.net/2022/07/01/sbWLlEoMj2ZPcUV.png" alt="image-20220701152302171" loading="lazy"></figure>
<figure data-type="image" tabindex="37"><img src="https://s2.loli.net/2022/07/01/3q4juA8vOJew9W6.png" alt="image-20220701152418060" loading="lazy"></figure>
<p>可以看到安装了软件之后的镜像大小比我们原有的大小大得多，这样我们就可以通过这个镜像来直接启动一个带Java环境的Ubuntu操作系统容器了。不过这种方式虽然自定义度很高，但是Docker官方并不推荐，这样的话使用者并不知道镜像是如何构建出来的，是否里面带了后门都不知道，并且这样去构建效率太低了，如果要同时构建多种操作系统的镜像岂不是要一个一个去敲？我们作为普通用户实际上采用Dokcerfile的方式会更好一些。</p>
<p>我们来看看如何使用Dockerfile的形式创建一个带Java环境的Ubuntu系统镜像。首先直接新建一个名为<code>Dockerfile</code>的文件：</p>
<pre><code class="language-sh">touch Dockerfile
</code></pre>
<p>接着我们来进行编辑，<code>Dockerfile</code>内部需要我们编写多种指令来告诉Docker我们的镜像的相关信息：</p>
<pre><code class="language-dockerfile">FROM &lt;基础镜像&gt;
</code></pre>
<p>首先我们需要使用FROM指令来选择当前镜像的基础镜像（必须以这个指令开始），这里我们直接使用<code>ubuntu</code>作为基础镜像即可，当然如果不需要任何基础镜像的话，直接使用<code>scratch</code>表示从零开始构建，这里就不演示了。</p>
<p>基础镜像设定完成之后，我们就需要在容器中运行命令来安装Java环境了，这里需要使用<code>RUN</code>指令：</p>
<pre><code class="language-dockerfile">RUN apt update
RUN apt install -y openjdk-8-jdk
</code></pre>
<p>每条指令执行之后，都会生成一个新的镜像层。</p>
<p>OK，现在我们的Dockerfile就编写完成了，只需要完成一次构建即可：</p>
<pre><code class="language-sh">docker build -t &lt;镜像名称&gt; &lt;构建目录&gt;
</code></pre>
<p>执行后，Docker会在构建目录中寻找Dockerfile文件，然后开始依次执行Dockerfile中的指令：</p>
<figure data-type="image" tabindex="38"><img src="https://s2.loli.net/2022/07/01/g6RFwA5t4EsdvnY.png" alt="image-20220701155443170" loading="lazy"></figure>
<p>构建过程的每一步都非常清晰地列出来了，一共三条指令对应三步依次进行，我们稍微等待一段时间进行安装，安装过程中所以的日志信息会直接打印到控制台（注意Docker镜像构建有缓存机制，就算你现在中途退出了，然后重新进行构建，也会直接将之前已经构建好的每一层镜像，直接拿来用，除非修改了Dockerfile文件重新构建，只要某一层发生变化其上层的构建缓存都会失效，当然包括<code>pull</code>时也会有类似的机制）</p>
<figure data-type="image" tabindex="39"><img src="https://s2.loli.net/2022/07/01/foLHIZScQ1KVbvC.png" alt="image-20220701155812315" loading="lazy"></figure>
<p>最后成功安装，会出现在本地：</p>
<figure data-type="image" tabindex="40"><img src="https://s2.loli.net/2022/07/01/95ueUgyaTcrz6Mi.png" alt="image-20220701155847721" loading="lazy"></figure>
<p>可以看到安装出来的大小跟我们之前的是一样的，因为做的事情是一模一样的。我们可以使用<code>history</code>命令来查看构建历史：</p>
<figure data-type="image" tabindex="41"><img src="https://s2.loli.net/2022/07/01/GYyHFcjSKJwvWi6.png" alt="image-20220701160128689" loading="lazy"></figure>
<p>可以看到最上面两层是我们通过使用apt命令生成的内容，就直接作为当前镜像中的两层镜像，每层镜像都有一个自己的ID，不同的镜像大小也不一样。而我们手动通过<code>commit</code>命令来生成的镜像没有这个记录：</p>
<figure data-type="image" tabindex="42"><img src="https://s2.loli.net/2022/07/01/qWUeSF3aKrvwJ8p.png" alt="image-20220701160406891" loading="lazy"></figure>
<p>如果遇到镜像ID为missing的一般是从Docker Hub中下载的镜像会有这个问题，但是问题不大。用我们自己构建的镜像来创建容器就可以直接体验带Java环境的容器了：</p>
<figure data-type="image" tabindex="43"><img src="https://s2.loli.net/2022/07/01/STmdFvBIbN4VAl1.png" alt="image-20220701161546279" loading="lazy"></figure>
<p>有关Dockerfile的其他命令，我们还会在后续的学习中逐步认识。</p>
<h3 id="发布镜像到远程仓库">发布镜像到远程仓库</h3>
<p>前面我们学习了如何构建一个Docker镜像，我们可以将自己的镜像发布到Docker Hub中，就像Git远程仓库一样，我们可以将自己的镜像上传到这里：https://hub.docker.com/repositories，没有账号的先去进行注册。</p>
<figure data-type="image" tabindex="44"><img src="https://s2.loli.net/2022/07/01/3T8xJLgER4cWuQq.png" alt="image-20220701164609666" loading="lazy"></figure>
<p>点击右上角的创建仓库，然后填写信息：</p>
<figure data-type="image" tabindex="45"><img src="https://s2.loli.net/2022/07/01/SkCKJmU6Rw2lfzP.png" alt="image-20220701164939268" loading="lazy"></figure>
<p>创建完成后，我们就有了一个公共的镜像仓库，我们可以将本地的镜像上传了，上传之前我们需要将镜像名称修改得规范一点，这里使用<code>tag</code>命令来重新打标签：</p>
<pre><code class="language-sh">docker tag ubuntu-java-file:latest 用户名/仓库名称:版本
</code></pre>
<p>这里我们将版本改成1.0版本吧，不用默认的latest了。</p>
<figure data-type="image" tabindex="46"><img src="https://s2.loli.net/2022/07/01/chAPS2DFW5q7GkE.png" alt="image-20220701165231001" loading="lazy"></figure>
<p>修改完成后，会创建一个新的本地镜像，名称就是我们自己定义的了。接着我们需在本地登录一下：</p>
<figure data-type="image" tabindex="47"><img src="https://s2.loli.net/2022/07/01/T3YC4pfaLEo85Oz.png" alt="image-20220701165446859" loading="lazy"></figure>
<p>登录成功后我们就可以上传了：</p>
<pre><code class="language-sh">docker push nagocoler/ubuntu-java:1.0
</code></pre>
<figure data-type="image" tabindex="48"><img src="https://s2.loli.net/2022/07/01/CXoBhpZUl79aDRQ.png" alt="image-20220701165744647" loading="lazy"></figure>
<p>哈哈，500M的东西传上去，还是有点压力的，如果实在太慢各位可以重新做一个简单点的镜像。上传完成后，打开仓库，可以看到已经有一个1.0版本了：</p>
<figure data-type="image" tabindex="49"><img src="https://s2.loli.net/2022/07/01/3UD9y8frEIX1JY6.png" alt="image-20220701165920060" loading="lazy"></figure>
<figure data-type="image" tabindex="50"><img src="https://s2.loli.net/2022/07/01/9sVSjcGCo5mTu61.png" alt="image-20220701170053250" loading="lazy"></figure>
<p>注意公共仓库是可以被搜索和下载的，所以我们这里把本地的镜像全部删掉，去下载我们刚刚上传好的镜像。这里我们先搜索一下，搜索使用<code>search</code>命令即可：</p>
<pre><code class="language-sh">docker search nagocoler/ubuntu-java
</code></pre>
<figure data-type="image" tabindex="51"><img src="https://s2.loli.net/2022/07/01/SIUpBOzN5vsiydn.png" alt="image-20220701170253126" loading="lazy"></figure>
<p>我们可以使用pull命令将其下载下来：</p>
<pre><code class="language-sh">docker pull nagocoler/ubuntu-java:1.0
</code></pre>
<figure data-type="image" tabindex="52"><img src="https://s2.loli.net/2022/07/01/uXBk3WPsDM4aZKo.png" alt="image-20220701171148334" loading="lazy"></figure>
<p>上传之后的镜像是被压缩过的，所以下载的内容就比较少一些。运行试试看：</p>
<figure data-type="image" tabindex="53"><img src="https://s2.loli.net/2022/07/01/RJVdstMnxjSYFoW.png" alt="image-20220701171253440" loading="lazy"></figure>
<p>当然各位也可以让自己的同学或是在其他机器上尝试下载自己的镜像，看看是不是都可以正常运行。</p>
<p>Docker Hub也可以自行搭建私服，但是这里就不多做介绍了，至此，有关容器和镜像的一些基本操作就讲解得差不多了。</p>
<h3 id="实战使用idea构建springboot程序镜像">实战：使用IDEA构建SpringBoot程序镜像</h3>
<p>这里我们创建一个新的SpringBoot项目，现在我们希望能够使用Docker快速地将我们的SpringBoot项目部署到安装了Docker的服务器上，我们就可以将其打包为一个Docker镜像。</p>
<figure data-type="image" tabindex="54"><img src="https://s2.loli.net/2022/07/01/QObHMsxAtej6lPq.png" alt="image-20220701173902376" loading="lazy"></figure>
<p>先创建好一个项目让它跑起来，可以正常运行就没问题了，接着我们需要将其打包为Docker镜像，这里创建一个新的Dockerfile：</p>
<pre><code class="language-dockerfile">FROM ubuntu
RUN apt update &amp;&amp; apt install -y openjdk-8-jdk
</code></pre>
<p>首先还是基于ubuntu构建一个带Java环境的系统镜像，接着我们先将其连接到我们的Docker服务器进行构建，由于IDEA自带了Docker插件，所以我们直接点击左上角的运行按钮，选择第二项 <strong>“为Dockerfile构建镜像”</strong>：</p>
<figure data-type="image" tabindex="55"><img src="https://s2.loli.net/2022/07/01/xB5vEw1QHojWZ8p.png" alt="image-20220701203741495" loading="lazy"></figure>
<figure data-type="image" tabindex="56"><img src="https://s2.loli.net/2022/07/01/FAcME5yxZPD1aoz.png" alt="image-20220701202537650" loading="lazy"></figure>
<p>这里需要配置Docker的服务器，也就是我们在Ubuntu服务器安装的Docker，这里我们填写服务器相关信息，我们首选需要去修改一下Docker的一些配置，开启远程客户端访问：</p>
<pre><code class="language-sh">sudo vim /etc/systemd/system/multi-user.target.wants/docker.service 
</code></pre>
<p>打开后，添加高亮部分：</p>
<figure data-type="image" tabindex="57"><img src="https://s2.loli.net/2022/07/01/OVMDGqiYWU9E7fA.png" alt="image-20220701202846707" loading="lazy"></figure>
<p>修改完成后，重启Docker服务，如果是云服务器，记得开启2375 TCP连接端口：</p>
<pre><code class="language-sh">sudo systemctl daemon-reload
sudo systemctl restart docker.service 
</code></pre>
<p>现在接着在IDEA中进行配置：</p>
<figure data-type="image" tabindex="58"><img src="https://s2.loli.net/2022/07/01/bDn3vHFw1XYdusU.png" alt="image-20220701203318098" loading="lazy"></figure>
<p>在引擎API URL处填写我们Docker服务器的IP地址：</p>
<pre><code>tcp://IP:2375
</code></pre>
<p>显示连接成功后，表示配置正确，点击保存即可，接着就开始在我们的Docker服务器上进行构建了：</p>
<figure data-type="image" tabindex="59"><img src="https://s2.loli.net/2022/07/01/nPFSa4Wcep31jXG.png" alt="image-20220701203518930" loading="lazy"></figure>
<p>最后成功构建：</p>
<figure data-type="image" tabindex="60"><img src="https://s2.loli.net/2022/07/01/1qtCFZKbg6fJsok.png" alt="image-20220701204815069" loading="lazy"></figure>
<p>可以看到，Docker服务器上已经有了我们刚刚构建好的镜像：</p>
<figure data-type="image" tabindex="61"><img src="https://s2.loli.net/2022/07/01/a6J43UW5biwTyVo.png" alt="image-20220701204900943" loading="lazy"></figure>
<p>不过名称没有指定，这里我们重新配置一下：</p>
<figure data-type="image" tabindex="62"><img src="https://s2.loli.net/2022/07/01/edPVg4oyrDiqmk6.png" alt="image-20220701204955570" loading="lazy"></figure>
<figure data-type="image" tabindex="63"><img src="https://s2.loli.net/2022/07/01/1QrHVB4zC9iFTG7.png" alt="image-20220701205053642" loading="lazy"></figure>
<p>重新进行构建，就是我们自定义的名称了：</p>
<figure data-type="image" tabindex="64"><img src="https://s2.loli.net/2022/07/01/qrWDZEKHklSU8OT.png" alt="image-20220701205402607" loading="lazy"></figure>
<figure data-type="image" tabindex="65"><img src="https://s2.loli.net/2022/07/01/6JKXLHEz25QGvMk.png" alt="image-20220701205350004" loading="lazy"></figure>
<p>我们来创建一个容器试试看：</p>
<figure data-type="image" tabindex="66"><img src="https://s2.loli.net/2022/07/01/8xPUg7qmVzXF9nN.png" alt="image-20220701205500494" loading="lazy"></figure>
<p>好了，现在基本环境搭建好了，我们接着就需要将我们的SpringBoot项目打包然后再容器启动时运行了，打开Maven执行打包命令：</p>
<figure data-type="image" tabindex="67"><img src="https://s2.loli.net/2022/07/01/CRLi2uJcXhzqPHF.png" alt="image-20220701205630885" loading="lazy"></figure>
<p>接着我们需要编辑Dockerfile，将我们构建好的jar包放进去：</p>
<pre><code class="language-dockerfile">COPY target/DockerTest-0.0.1-SNAPSHOT.jar app.jar
</code></pre>
<p>这里需要使用COPY命令来将文件拷贝到镜像中，第一个参数是我们要拷贝的本地文件，第二个参数是存放在Docker镜像中的文件位置，由于还没有学习存储管理，这里我们直接输入<code>app.jar</code>直接保存在默认路径即可。</p>
<p>接着我们就需要指定在启动时运行我们的Java程序，这里使用CMD命令来完成：</p>
<pre><code class="language-dockerfile">FROM ubuntu
RUN apt update &amp;&amp; apt install -y openjdk-8-jdk
COPY target/DockerTest-0.0.1-SNAPSHOT.jar app.jar
CMD java -jar app.jar
# EXPOSE 8080
</code></pre>
<p>CMD命令可以设定容器启动后执行的命令，EXPOSE可以指定容器需要暴露的端口，但是现在我们还没有学习网络相关的知识，所以暂时不使用，这里指定为我们启动Java项目的命令。配置完成后，重新构建：</p>
<figure data-type="image" tabindex="68"><img src="https://s2.loli.net/2022/07/01/NgCLJbRQc1lMqna.png" alt="image-20220701210438145" loading="lazy"></figure>
<p>可以看到历史中已经出现新的步骤了：</p>
<figure data-type="image" tabindex="69"><img src="https://s2.loli.net/2022/07/01/gpfn4EqjMbZh1Nd.png" alt="image-20220701213513862" loading="lazy"></figure>
<p>接着启动我们的镜像，我们可以直接在IDEA中进行操作，不用再去敲命令了，有点累：</p>
<figure data-type="image" tabindex="70"><img src="https://s2.loli.net/2022/07/01/t2MV3Tu6IcrK8Dl.png" alt="image-20220701210845768" loading="lazy"></figure>
<figure data-type="image" tabindex="71"><img src="https://s2.loli.net/2022/07/01/JqajY8EdVbGNhiF.png" alt="image-20220701210908997" loading="lazy"></figure>
<p>启动后可以在右侧看到容器启动的日志信息：</p>
<figure data-type="image" tabindex="72"><img src="https://s2.loli.net/2022/07/01/jreyMHzcX8LTh3k.png" alt="image-20220701210946261" loading="lazy"></figure>
<figure data-type="image" tabindex="73"><img src="https://s2.loli.net/2022/07/01/OGAj3Rr59iVLqfe.png" alt="image-20220701211029119" loading="lazy"></figure>
<p>但是我们发现启动之后并不能直接访问，这是为什么呢？这是因为容器内部的网络和外部网络是隔离的，我们如果想要访问容器内的服务器，需要将对应端口绑定到宿主机上，让宿主主机也开启这个端口，这样才能连接到容器内：</p>
<pre><code class="language-sh">docker run -p 8080:8080 -d springboot-test:1.0
</code></pre>
<p>这里<code>-p</code>表示端口绑定，将Docker容器内的端口绑定到宿主机的端口上，这样就可以通过宿主的8080端口访问到容器的8080端口了（有关容器网络管理我们还会在后面进行详细介绍），<code>-d</code>参数表示后台运行，当然直接在IDEA中配置也是可以的：</p>
<figure data-type="image" tabindex="74"><img src="https://s2.loli.net/2022/07/01/dXQlEBIDzU6YTLG.png" alt="image-20220701211536598" loading="lazy"></figure>
<p>配置好后，点击重新创建容器：</p>
<figure data-type="image" tabindex="75"><img src="https://s2.loli.net/2022/07/01/6G7hbmW81uBsKFc.png" alt="image-20220701211701640" loading="lazy"></figure>
<p>重新运行后，我们就可以成功访问到容器中运行的SpringBoot项目了：</p>
<figure data-type="image" tabindex="76"><img src="https://s2.loli.net/2022/07/01/7xNrfWcvC58hQ4q.png" alt="image-20220701211753962" loading="lazy"></figure>
<p>当然，为了以后方便使用，我们可以直接将其推送到Docker Hub中，这里我们还是创建一个新的公开仓库：</p>
<figure data-type="image" tabindex="77"><img src="https://s2.loli.net/2022/07/01/oTXBtlPV7j3C6a9.png" alt="image-20220701212330425" loading="lazy"></figure>
<p>这次我们就使用IDEA来演示直接进行镜像的上传，直接点击：</p>
<figure data-type="image" tabindex="78"><img src="https://s2.loli.net/2022/07/01/91tKnXDWaeFqcrx.png" alt="image-20220701212458851" loading="lazy"></figure>
<p>接着我们需要配置一下我们的Docker Hub相关信息：</p>
<figure data-type="image" tabindex="79"><img src="https://s2.loli.net/2022/07/01/tMcD2kzNwW9J7d3.png" alt="image-20220701212637581" loading="lazy"></figure>
<figure data-type="image" tabindex="80"><img src="https://s2.loli.net/2022/07/01/kgTlz3m61ZrHx5s.png" alt="image-20220701212731276" loading="lazy"></figure>
<p>OK，远程镜像仓库配置完成，直接推送即可，等待推送完成。</p>
<figure data-type="image" tabindex="81"><img src="https://s2.loli.net/2022/07/01/H5UfWXC2nKVeray.png" alt="image-20220701212902977" loading="lazy"></figure>
<p>可以看到远程仓库中已经出现了我们的镜像，然后IDEA中也可以同步看到：</p>
<figure data-type="image" tabindex="82"><img src="https://s2.loli.net/2022/07/01/mgRKV2SWb9YxBGr.png" alt="image-20220701213026214" loading="lazy"></figure>
<p>这样，我们就完成了使用IDEA将SpringBoot项目打包为Docker镜像。</p>
<hr>
<h2 id="容器网络管理">容器网络管理</h2>
<p>**注意：**本小节学习需要掌握部分《计算机网络》课程中的知识。</p>
<p>前面我们学习了容器和镜像的一些基本操作，了解了如何通过镜像创建容器、然后自己构建容器，以及远程仓库推送等，这一部分我们接着来讨论容器的网络管理。</p>
<h3 id="容器网络类型">容器网络类型</h3>
<p>Docker在安装后，会在我们的主机上创建三个网络，使用<code>network ls</code>命令来查看：</p>
<pre><code class="language-sh">docker network ls
</code></pre>
<figure data-type="image" tabindex="83"><img src="https://s2.loli.net/2022/07/02/7KEumyqriRY2QU5.png" alt="image-20220702161742741" loading="lazy"></figure>
<p>可以看到默认情况下有<code>bridge</code>、<code>host</code>、<code>none</code>这三种网络类型（其实有点像虚拟机的网络配置，也是分桥接、共享网络之类的），我们先来依次介绍一下，在开始之前我们先构建一个镜像，默认的ubuntu镜像由于啥软件都没有，所以我们把一会网络要用到的先提前装好：</p>
<pre><code class="language-sh">docker run -it ubuntu
</code></pre>
<pre><code class="language-sh">apt update
apt install net-tools iputils-ping curl
</code></pre>
<p>这样就安装好了，我们直接退出然后将其构建为新的镜像：</p>
<pre><code class="language-sh">docker commit lucid_sammet ubuntu-net
</code></pre>
<figure data-type="image" tabindex="84"><img src="https://s2.loli.net/2022/07/02/NIGfx25Un83EV7Q.png" alt="image-20220702170441267" loading="lazy"></figure>
<p>OK，一会我们就可以使用了。</p>
<ul>
<li>
<p>**none网络：**这个网络除了有一个本地环回网络之外，就没有其他的网络了，我们可以在创建容器时指定这个网络。</p>
<p>这里使用<code>--network</code>参数来指定网络：</p>
<pre><code class="language-sh">docker run -it --network=none ubuntu-net
</code></pre>
<p>进入之后，我们可以直接查看一下当前的网络：</p>
<pre><code class="language-sh">ifconfig
</code></pre>
<p>可以看到只有一个本地环回<code>lo</code>网络设备：</p>
<figure data-type="image" tabindex="85"><img src="https://s2.loli.net/2022/07/02/qL1oAkOCcIYRwZj.png" alt="image-20220702170000617" loading="lazy"></figure>
<p>所以这个容器是无法连接到互联网的：</p>
<figure data-type="image" tabindex="86"><img src="https://s2.loli.net/2022/07/02/xzSp4hTBkeFqCd3.png" alt="image-20220702170531312" loading="lazy"></figure>
<p>“真”单机运行，可以说是绝对的安全，没人能访问进去，存点密码这些还是不错的。</p>
</li>
<li>
<p>**bridge网络：**容器默认使用的网络类型，这是桥接网络，也是应用最广泛的网络类型：</p>
<p>实际上我们在宿主主机上查看网络信息，会发现有一个名为docker0的网络设备：</p>
<figure data-type="image" tabindex="87"><img src="https://s2.loli.net/2022/07/02/jDKSIriXec96uhy.png" alt="image-20220702172102410" loading="lazy"></figure>
<p>这个网络设备是Docker安装时自动创建的虚拟设备，它有什么用呢？我们可以来看一下默认创建的容器内部的情况：</p>
<pre><code class="language-sh">docker run -it ubuntu-net
</code></pre>
<figure data-type="image" tabindex="88"><img src="https://s2.loli.net/2022/07/02/5JdimQWMaCx7hy2.png" alt="image-20220702172532004" loading="lazy"></figure>
<p>可以看到容器的网络接口地址为172.17.0.2，实际上这是Docker创建的虚拟网络，就像容器单独插了一根虚拟的网线，连接到Docker创建的虚拟网络上，而docker0网络实际上作为一个桥接的角色，一头是自己的虚拟子网，另一头是宿主主机的网络。</p>
<p>网络拓扑类似于下面这样：</p>
<figure data-type="image" tabindex="89"><img src="https://s2.loli.net/2022/07/02/xCKMIBwjq7gWOko.png" alt="image-20220702173005750" loading="lazy"></figure>
<p>通过添加这样的网桥，我们就可以对容器的网络进行管理和控制，我们可以使用<code>network inspect</code>命令来查看docker0网桥的配置信息：</p>
<pre><code class="language-sh">docker network inspect bridge
</code></pre>
<figure data-type="image" tabindex="90"><img src="https://s2.loli.net/2022/07/02/86XdZUejEuk1P3i.png" alt="image-20220702173431530" loading="lazy"></figure>
<p>这里的配置的子网是172.17.0.0，子网掩码是255.255.0.0，网关是172.17.0.1，也就是docker0这个虚拟网络设备，所以我们上面创建的容器就是这个子网内分配的地址172.17.0.2了。</p>
<p>之后我们还会讲解如何管理和控制容器网络。</p>
</li>
<li>
<p>**host网络：**当容器连接到此网络后，会共享宿主主机的网络，网络配置也是完全一样的：</p>
<pre><code class="language-sh">docker run -it --network=host ubuntu-net
</code></pre>
<p>可以看到网络列表和宿主主机的列表是一样的，不知道各位有没有注意到，连hostname都是和外面一模一样的：</p>
<figure data-type="image" tabindex="91"><img src="https://s2.loli.net/2022/07/02/cRAQtIxV4D9byCu.png" alt="image-20220702170754656" loading="lazy"></figure>
<p>只要宿主主机能连接到互联网，容器内部也是可以直接使用的：</p>
<figure data-type="image" tabindex="92"><img src="https://s2.loli.net/2022/07/02/lVsc1mpihq54Pue.png" alt="image-20220702171041631" loading="lazy"></figure>
<p>这样的话，直接使用宿主的网络，传输性能基本没有什么折损，而且我们可以直接开放端口等，不需要进行任何的桥接：</p>
<pre><code class="language-sh"> apt install -y systemctl nginx
 systemctl start nginx
</code></pre>
<p>安装Nginx之后直接就可以访问了，不需要开放什么端口：</p>
<figure data-type="image" tabindex="93"><img src="https://s2.loli.net/2022/07/02/1JnY6KyVpXOwbtl.png" alt="image-20220702171550979" loading="lazy"></figure>
<p>相比桥接网络就方便得多了。</p>
</li>
</ul>
<p>我们可以根据实际情况，来合理地选择这三种网络使用。</p>
<h3 id="用户自定义网络">用户自定义网络</h3>
<p>除了前面我们介绍的三种网络之外，我们也可以自定义自己的网络，让容器连接到这个网络。</p>
<p>Docker默认提供三种网络驱动：<code>bridge</code>、<code>overlay</code>、<code>macvlan</code>，不同的驱动对应着不同的网络设备驱动，实现的功能也不一样，比如bridge类型的，其实就和我们前面介绍的桥接网络是一样的。</p>
<p>我们可以使用<code>network create</code>来试试看：</p>
<pre><code class="language-sh">docker network create --driver bridge test
</code></pre>
<p>这里我们创建了一个桥接网络，名称为test：</p>
<figure data-type="image" tabindex="94"><img src="https://s2.loli.net/2022/07/02/piCtK8kdRALHSIu.png" alt="image-20220702180837819" loading="lazy"></figure>
<p>可以看到新增了一个网络设备，这个就是一会负责我们容器网络的网关了，和之前的docker0是一样的：</p>
<pre><code class="language-sh">docker network inspect test
</code></pre>
<figure data-type="image" tabindex="95"><img src="https://s2.loli.net/2022/07/02/uLwAD4YC3UFXQt7.png" alt="image-20220702181150667" loading="lazy"></figure>
<p>这里我们创建一个新的容器，使用此网络：</p>
<pre><code class="language-sh"> docker run -it --network=test ubuntu-net
</code></pre>
<figure data-type="image" tabindex="96"><img src="https://s2.loli.net/2022/07/02/Iy2BwDoZsLMO8gJ.png" alt="image-20220702181252137" loading="lazy"></figure>
<p>成功得到分配的IP地址，是在这个网络内的，注意不同的网络之间是隔离的，我们可以再创建一个容器试试看：</p>
<figure data-type="image" tabindex="97"><img src="https://s2.loli.net/2022/07/02/b14dflKGMunULQI.png" alt="image-20220702181808792" loading="lazy"></figure>
<p>可以看到不同的网络是相互隔离的，无法进行通信，当然我们也为此容器连接到另一个容器所属的网络下：</p>
<pre><code class="language-sh">docker network connect test 容器ID/名称
</code></pre>
<figure data-type="image" tabindex="98"><img src="https://s2.loli.net/2022/07/02/WzvhI63ydfeJStA.png" alt="image-20220702182050204" loading="lazy"></figure>
<p>这样就连接了一个新的网络：</p>
<figure data-type="image" tabindex="99"><img src="https://s2.loli.net/2022/07/02/lxqrz36sVUjNdI4.png" alt="image-20220702182146049" loading="lazy"></figure>
<p>可以看到容器中新增了一个网络设备连接到我们自己定义的网络中，现在这两个容器在同一个网络下，就可以相互ping了：<br>
<img src="https://s2.loli.net/2022/07/02/WBlC9PheETO64xq.png" alt="image-20220702182310008" loading="lazy"></p>
<p>这里就不介绍另外两种类型的网络了，他们是用于多主机通信的，目前我们只学习单机使用。</p>
<h3 id="容器间网络">容器间网络</h3>
<p>我们首先来看看容器和容器之间的网络通信，实际上我们之前已经演示过ping的情况了，现在我们创建两个ubuntu容器：</p>
<pre><code class="language-sh">docker run -it ubuntu-net
</code></pre>
<p>先获取其中一个容器的网络信息：</p>
<figure data-type="image" tabindex="100"><img src="https://s2.loli.net/2022/07/02/yTEcg4l2kASBnQu.png" alt="image-20220702175353454" loading="lazy"></figure>
<p>我们可以直接在另一个容器中ping这个容器：</p>
<p>![image-20220702175444713](/Users/nagocoler/Library/Application Support/typora-user-images/image-20220702175444713.png)</p>
<p>可以看到能够直接ping通，因为这两个容器都是使用的bridge网络，在同一个子网中，所以可以互相访问。</p>
<p>我们可以直接通过容器的IP地址在容器间进行通信，只要保证两个容器处于同一个网络下即可，虽然这样比较方便，但是大部分情况下，容器部署之后的IP地址是自动分配的（当然也可以使用<code>--ip</code>来手动指定，但是还是不方便），我们无法提前得知IP地址，那么有没有一直方法能够更灵活一些呢？</p>
<p>我们可以借助Docker提供的DNS服务器，它就像是一个真的DNS服务器一样，能够对域名进行解析，使用很简单，我们只需要在容器启动时给个名字就行了，我们可以直接访问这个名称，最后会被解析为对应容器的IP地址，但是注意只会在我们用户自定义的网络下生效，默认的网络是不行的：</p>
<pre><code class="language-sh">docker run -it --name=test01 --network=test ubuntu-net
docker run -it --name=test02 --network=test ubuntu-net
</code></pre>
<p>接着直接ping对方的名字就可以了：</p>
<figure data-type="image" tabindex="101"><img src="https://s2.loli.net/2022/07/02/lKCFY6ec17N4b5y.png" alt="image-20220702192457354" loading="lazy"></figure>
<p>可以看到名称会自动解析为对应的IP地址，这样的话就不用担心IP不确定的问题了。</p>
<p>当然我们也可以让两个容器同时共享同一个网络，注意这里的共享是直接共享同一个网络设备，两个容器共同使用一个IP地址，只需要在创建时指定：</p>
<pre><code class="language-sh">docker run -it --name=test01 --network=container:test02 ubuntu-net
</code></pre>
<p>这里将网络指定为一个容器的网络，这样两个容器使用的就是同一个网络了：</p>
<figure data-type="image" tabindex="102"><img src="https://s2.loli.net/2022/07/02/Wb6jODxFP3r1mE7.png" alt="image-20220702200711351" loading="lazy"></figure>
<p>可以看到两个容器的IP地址和网卡的Mac地址是完全一样的，它们的网络现在是共享状态，此时在容器中访问，localhost，既是自己也是别人。</p>
<p>我们可以在容器1中，安装Nginx，然后再容器2中访问：</p>
<pre><code class="language-sh"> apt install -y systemctl nginx
 systemctl start nginx
</code></pre>
<figure data-type="image" tabindex="103"><img src="https://s2.loli.net/2022/07/02/WTn9OMYmLZJXtBz.png" alt="image-20220702201348722" loading="lazy"></figure>
<p>成功访问到另一个容器中的Nginx服务器。</p>
<h3 id="容器外部网络">容器外部网络</h3>
<p>前面我们介绍了容器之间的网络通信，我们接着来看容器与外部网络的通信。</p>
<p>首先我们来看容器是如何访问到互联网的，在默认的三种的网络下，只有共享模式和桥接模式可以连接到外网，共享模式实际上就是直接使用宿主主机的网络设备连接到互联网，这里我们主要来看一下桥接模式。</p>
<p>通过前面的学习，我们了解到桥接模式实际上就是创建一个单独的虚拟网络，让容器在这个虚拟网络中，然后通过桥接器来与外界相连，那么数据包是如何从容器内部的网络到达宿主主机再发送到互联网的呢？实际上整个过程中最关键的就是依靠NAT（Network Address Translation）将地址进行转换，再利用宿主主机的IP地址发送数据包出去。</p>
<p>这里我们就来补充一下《计算机网络》课程中学习的NAT：</p>
<p>实际上NAT在我们生活中也是经常见到的，比如我们要访问互联网上的某个资源，要和服务器进行通信，那么就需要将数据包发送出去，同时服务器也要将数据包发送回来，我们可以知道服务器的IP地址，也可以直接去连接，因为服务器的IP地址是暴露在互联网上的，但是我们的局域网就不一样了，它仅仅局限在我们的家里，比如我们连接了家里的路由器，可以得到一个IP地址，但是你会发现，这个IP公网是无法直接访问到我们的，因为这个IP地址仅仅是一个局域网的IP地址，俗称内网IP，既然公网无法访问到我们，那服务器是如何将数据包发送给我们的呢？</p>
<figure data-type="image" tabindex="104"><img src="https://s2.loli.net/2022/07/02/LxtQ68HzEVYKdjW.png" alt="image-20220702230700124" loading="lazy"></figure>
<p>实际上这里就借助了NAT在帮助我们与互联网上的服务器进行通信，通过NAT，可以实现将局域网的IP地址，映射为对应的公网IP地址，而NAT设备一端连接外网，另一端连接内网的所有设备，当我们想要与外网进行通信时，就可以将数据包发送给NAT设备，由它来将数据包的源地址映射为它在外网上的地址，这样服务器就能够发现它了，能够直接与它建立通信。当服务器发送数据回来时，也是直接交给NAT设备，然后再根据地址映射，转发给对应的内网设备（当然由于公网IP地址有限，所以一般采用IP+端口结合使用的形式ANPT）</p>
<p>所以你打开百度直接搜IP，会发现这个IP地址并不是你本地的，而是NAT设备的公网地址：</p>
<figure data-type="image" tabindex="105"><img src="https://s2.loli.net/2022/07/02/uAW9GH1b6xkDB3T.png" alt="image-20220702231458928" loading="lazy"></figure>
<p>实际上我们家里的路由器一般都带有NAT功能，默认开启NAT模式，包括我们的小区也是有一个NAT设备在进行转换的，这样你的电脑才能在互联网的世界中遨游。当然NAT也可以保护内网的设备不会直接暴露在公网，这样也会更加的安全，只有当我们主动发起连接时，别人才能知道我们。</p>
<p>当然，我们的Docker也是这样的，实际上内网的数据包想要发送到互联网上去，那么就需要经过这样的一套流程：</p>
<figure data-type="image" tabindex="106"><img src="https://s2.loli.net/2022/07/02/ktEA5O9BrmxXbPz.png" alt="image-20220702232449520" loading="lazy"></figure>
<p>这样，Docker容器使用的内网就可以和外网进行通信了。</p>
<p>但是这样有一个问题，单纯依靠NAT的话，只有我们主动与外界联系时，外界才能知道我们，但是现在我们的容器中可能会部署一些服务，需要外界来主动连接我们，此时该怎么办呢？</p>
<p>我们可以直接在容器时配置端口映射，还记得我们在第一节课部署Nginx服务器吗？</p>
<pre><code class="language-sh">docker run -d -p 80:80 nginx
</code></pre>
<p>这里的<code>-p</code>参数实际上是进行端口映射配置，端口映射可以将容器需要对外提供服务的端口映射到宿主主机的端口上，这样，当外部访问到宿主主机的对应端口时，就会直接转发给容器内映射的端口了。规则为<code>宿主端口:容器端口</code>，这里配置的是将容器的80端口映射到宿主主机的80端口上。</p>
<figure data-type="image" tabindex="107"><img src="https://s2.loli.net/2022/07/02/WQzEVTwePNaHYgG.png" alt="image-20220702233420287" loading="lazy"></figure>
<p>一旦监听到宿主主机的80端口收到了数据包，那么会直接转发给对应的容器。所以配置了端口映射之后，我们才可以从外部正常访问到容器内的服务：</p>
<figure data-type="image" tabindex="108"><img src="https://s2.loli.net/2022/07/02/VY5imqeG9jlAz8d.png" alt="image-20220630165440751" loading="lazy"></figure>
<p>我们也可以直接输入<code>docker ps</code>查看端口映射情况：</p>
<figure data-type="image" tabindex="109"><img src="https://s2.loli.net/2022/07/02/dyDhNRvQ7Bzixka.png" alt="image-20220702233831651" loading="lazy"></figure>
<p>至此，有关容器的网络部分，就到此为止，当然这仅仅是单机下的容器网络操作，在以后的课程中，我们还会进一步学习多主机下的网络配置。</p>
<hr>
<h2 id="容器存储管理">容器存储管理</h2>
<p>前面我们介绍了容器的网络管理，我们现在已经了解了如何配置容器的网络，以及相关的一些原理。还有一个比较重要的部分就是容器的存储，在这一小节我们将深入了解容器的存储管理。</p>
<h3 id="容器持久化存储">容器持久化存储</h3>
<p>我们知道，容器在创建之后，实际上我们在容器中创建和修改的文件，实际上是被容器的分层机制保存在最顶层的容器层进行操作的，为了保护下面每一层的镜像不被修改，所以才有了这样的CopyOnWrite特性。但是这样也会导致容器在销毁时数据的丢失，当我们销毁容器重新创建一个新的容器时，所有的数据全部丢失，直接回到梦开始的地方。</p>
<p>在某些情况下，我们可能希望对容器内的某些文件进行持久化存储，而不是一次性的，这里就要用到数据卷（Data Volume）了。</p>
<p>在开始之前我们先准备一下实验要用到的镜像：</p>
<pre><code class="language-sh">docker run -it ubuntu
apt update &amp;&amp; apt install -y vim
</code></pre>
<p>然后打包为我们一会要使用的镜像：</p>
<pre><code>docker commit 
</code></pre>
<p>我们可以让容器将文件保存到宿主主机上，这样就算容器销毁，文件也会在宿主主机上保留，下次创建容器时，依然可以从宿主主机上读取到对应的文件。如何做到呢？只需要在容器启动时指定即可：</p>
<pre><code class="language-sh">mkdir test
</code></pre>
<p>我们现在用户目录下创建一个新的<code>test</code>目录，然后在里面随便创建一个文件，再写点内容：</p>
<pre><code class="language-sh">vim test/hello.txt
</code></pre>
<p>接着我们就可以将宿主主机上的目录或文件挂载到容器的某个目录上：</p>
<pre><code class="language-sh">docker run -it -v ~/test:/root/test ubuntu-volume
</code></pre>
<p>这里用到了一个新的参数<code>-v</code>，用于指定文件挂载，这里是将我们刚刚创建好的test目录挂在到容器的/root/test路径上。</p>
<figure data-type="image" tabindex="110"><img src="https://s2.loli.net/2022/07/03/ztEJDC4PTVAyZF2.png" alt="image-20220703105256049" loading="lazy"></figure>
<p>这样我们就可以直接在容器中访问宿主主机上的文件了，当然如果我们对挂载目录中的文件进行编辑，那么相当于编辑的是宿主主机的数据：</p>
<pre><code class="language-sh">vim /root/test/test.txt  
</code></pre>
<figure data-type="image" tabindex="111"><img src="https://s2.loli.net/2022/07/03/YqUHkJiTG3Q9pAM.png" alt="image-20220703105626105" loading="lazy"></figure>
<p>在宿主主机的对应目录下，可以直接访问到我们刚刚创建好的文件。</p>
<p>接着我们来将容器销毁，看看当容器不复存在时，挂载的数据时候还能保留：</p>
<figure data-type="image" tabindex="112"><img src="https://s2.loli.net/2022/07/03/B5M6Wy8AxIoqJtC.png" alt="image-20220703105847329" loading="lazy"></figure>
<p>可以看到，即使我们销毁了容器，在宿主主机上的文件依然存在，并不会受到影响，这样的话，当我们下次创建新的镜像时，依然可以使用这些保存在外面的文件。</p>
<p>比如我们现在想要部署一个Nginx服务器来代理我们的前端，就可以直接将前端页面保存到宿主主机上，然后通过挂载的形式让容器中的Nginx访问，这样就算之后Nginx镜像有升级，需要重新创建，也不会影响到我们的前端页面。这里我们来测试一下，我们先将前端模板上传到服务器：</p>
<pre><code class="language-sh">scp Downloads/moban5676.zip 192.168.10.10:~/
</code></pre>
<p>然后在服务器上解压一下：</p>
<pre><code class="language-sh">unzip moban5676.zip
</code></pre>
<p>接着我们就可以启动容器了：</p>
<pre><code class="language-sh">docker run -it -v ~/moban5676:/usr/share/nginx/html/ -p 80:80 -d nginx
</code></pre>
<p>这里我们将解压出来的目录，挂载到容器中Nginx的默认站点目录<code>/usr/share/nginx/html/</code>（由于挂在后位于顶层，会替代镜像层原有的文件），这样Nginx就直接代理了我们存放在宿主主机上的前端页面，当然别忘了把端口映射到宿主主机上，这里我们使用的镜像是官方的nginx镜像。</p>
<p>现在我们进入容器将Nginx服务启动：</p>
<pre><code class="language-sh">systemctl start nginx
</code></pre>
<p>然后通过浏览器访问看看是否代理成功：</p>
<figure data-type="image" tabindex="113"><img src="https://s2.loli.net/2022/07/03/YtgXWizh765qFxr.png" alt="image-20220703111937254" loading="lazy"></figure>
<p>可以看到我们的前端页面直接被代理了，当然如果我们要编写自定义的配置，也是使用同样的方法操作即可。</p>
<p>注意如果我们在使用<code>-v</code>参数时不指定宿主主机上的目录进行挂载的话，那么就由Docker来自动创建一个目录，并且会将容器中对应路径下的内容拷贝到这个自动创建的目录中，最后挂在到容器中，这种就是由Docker管理的数据卷了（docker managed volume）我们来试试看：</p>
<pre><code class="language-sh">docker run -it -v /root/abc ubuntu-volume
</code></pre>
<p>注意这里我们仅仅指定了挂载路径，没有指定宿主主机的对应目录，继续创建：</p>
<figure data-type="image" tabindex="114"><img src="https://s2.loli.net/2022/07/03/fXCl7IRqKBvYwxj.png" alt="image-20220703112702067" loading="lazy"></figure>
<p>创建后可以看到<code>root</code>目录下有一个新的<code>abc</code>目录，那么它具体是在宿主主机的哪个位置呢？这里我们依然可以使用<code>inspect</code>命令：</p>
<pre><code class="language-sh">docker inspect bold_banzai 
</code></pre>
<figure data-type="image" tabindex="115"><img src="https://s2.loli.net/2022/07/03/zFotAfeBpcRjKWN.png" alt="image-20220703113507320" loading="lazy"></figure>
<p>可以看到Sorce指向的是<code>/var/lib</code>中的某个目录，我们可以进入这个目录来创建一个新的文件，进入之前记得提升一下权限，权限低了还进不去：</p>
<figure data-type="image" tabindex="116"><img src="https://s2.loli.net/2022/07/03/2bfokiMTmdGZcUE.png" alt="image-20220703114333446" loading="lazy"></figure>
<p>我们来创一个新的文本文档：</p>
<figure data-type="image" tabindex="117"><img src="https://s2.loli.net/2022/07/03/yi1hSPC3bAndMXm.png" alt="image-20220703114429831" loading="lazy"></figure>
<p>实际上和我们之前是一样的，也是可以在容器中看到的，当然删除容器之后，数据依然是保留的。当我们不需要使用数据卷时，可以进行删除：</p>
<figure data-type="image" tabindex="118"><img src="https://s2.loli.net/2022/07/03/f8NPDWmhLtvw3SV.png" alt="image-20220703145011638" loading="lazy"></figure>
<p>当然有时候为了方便，可能并不需要直接挂载一个目录上去，仅仅是从宿主主机传递一些文件到容器中，这里我们可以使用<code>cp</code>命令来完成：</p>
<figure data-type="image" tabindex="119"><img src="https://s2.loli.net/2022/07/03/uw7S5PobAUWBtCI.png" alt="image-20220703115648195" loading="lazy"></figure>
<p>这个命令支持从宿主主机复制文件到容器，或是从容器复制文件到宿主主机，使用方式类似于Linux自带的<code>cp</code>命令。</p>
<h3 id="容器数据共享">容器数据共享</h3>
<p>前面我们通过挂载的形式，将宿主主机上的文件直接挂载到容器中，这样容器就可以直接访问到宿主主机上的文件了，并且在容器删除时也不会清理宿主主机上的文件。</p>
<p>我们接着来看看如何实现容器与容器之间的数据共享，实际上按照我们之前的思路，我们可以在宿主主机创建一个公共的目录，让这些需要实现共享的容器，都挂载这个公共目录：</p>
<pre><code class="language-sh">docker run -it -v ~/test:/root/test ubuntu-volume
</code></pre>
<figure data-type="image" tabindex="120"><img src="https://s2.loli.net/2022/07/03/soxdKyY4MIXBOin.png" alt="image-20220703141840532" loading="lazy"></figure>
<p>由于挂载的是宿主主机上的同一块区域，所以内容可以直接在两个容器中都能访问。当然我们也可以将另一个容器挂载的目录，直接在启动容器时指定使用此容器挂载的目录：</p>
<pre><code class="language-sh">docker run -it -v ~/test:/root/test --name=data_test ubuntu-volume
docker run -it --volumes-from data_test ubuntu-volume
</code></pre>
<p>这里使用<code>--volumes-from</code>指定另一个容器（这种用于给其他容器提供数据卷的容器，我们一般称为数据卷容器）</p>
<figure data-type="image" tabindex="121"><img src="https://s2.loli.net/2022/07/03/Uu4CjSZifv1Oyr7.png" alt="image-20220703142849845" loading="lazy"></figure>
<p>可以看到，数据卷容器中挂载的内容，在当前容器中也是存在的，当然就算此时数据卷容器被删除，那么也不会影响到这边，因为这边相当于是继承了数据卷容器提供的数据卷，所以本质上还是让两个容器挂载了同样的目录实现数据共享。</p>
<p>虽然通过上面的方式，可以在容器之间实现数据传递，但是这样并不方便，可能某些时候我们仅仅是希望容器之间共享，而不希望有宿主主机这个角色直接参与到共享之中，此时我们就需要寻找一种更好的办法了。其实我们可以将数据完全放入到容器中，通过构建一个容器，来直接将容器中打包好的数据分享给其他容器，当然本质上依然是一个Docker管理的数据卷，虽然还是没有完全脱离主机，但是移植性就高得多了。</p>
<p>我们来编写一个Dockerfile：</p>
<pre><code class="language-dockerfile">FROM ubuntu
ADD moban5676.tar.gz /usr/share/nginx/html/
VOLUME /usr/share/nginx/html/
</code></pre>
<p>这里我们使用了一个新的指令ADD，它跟COPY命令类似，也可以复制文件到容器中，但是它可以自动对压缩文件进行解压，这里只需要将压缩好的文件填入即可，后面的VOLUME指令就像我们使用<code>-v</code>参数一样，会创建一个挂载点在容器中：</p>
<pre><code class="language-sh">cd test
tar -zcvf moban5676.tar.gz *
mv moban5676.tar.gz ..
cd ..
</code></pre>
<p>接着我们直接构建：</p>
<pre><code class="language-sh">docker build -t data .
</code></pre>
<figure data-type="image" tabindex="122"><img src="https://s2.loli.net/2022/07/03/M7jxBUsApKtgzku.png" alt="image-20220703153109650" loading="lazy"></figure>
<p>现在我们运行一个容器看看：</p>
<figure data-type="image" tabindex="123"><img src="https://s2.loli.net/2022/07/03/SUg32jlwMcY7Btp.png" alt="image-20220703153343461" loading="lazy"></figure>
<p>可以看到所有的文件都自动解压出来了（除了中文文件名称乱码了之外，不过无关紧要）我们退出容器，可以看到数据卷列表中新增了我们这个容器需要使用的：</p>
<figure data-type="image" tabindex="124"><img src="https://s2.loli.net/2022/07/03/m6VCIbXyMxt3ilT.png" alt="image-20220703153514730" loading="lazy"></figure>
<figure data-type="image" tabindex="125"><img src="https://s2.loli.net/2022/07/03/KyLUic5r6oW4HDx.png" alt="image-20220703153542739" loading="lazy"></figure>
<p>这个位置实际上就是数据存放在当前主机上的位置了，不过是由Docker进行管理而不是我们自定义的。现在我们就可以创建一个新的容器直接继承了：</p>
<pre><code class="language-sh">docker run -p 80:80 --volumes-from=data_test -d nginx
</code></pre>
<p>访问一下Nginx服务器，可以看到成功代理：</p>
<figure data-type="image" tabindex="126"><img src="https://s2.loli.net/2022/07/03/YtgXWizh765qFxr.png" alt="image-20220703111937254" loading="lazy"></figure>
<p>这样我们就实现了将数据放在容器中进行共享，我们不需要刻意去指定宿主主机的挂载点，而是Docker自行管理，这样就算迁移主机依然可以快速部署。</p>
<hr>
<h2 id="容器资源管理">容器资源管理</h2>
<p>前面我们已经完成Docker的几个主要模块的学习，最后我们来看看如何对容器的资源进行管理。</p>
<h3 id="容器控制操作">容器控制操作</h3>
<p>在开始之前，我们还是要先补充一些我们前面没有提到的其他容器命令。</p>
<p>首先我们的SpringBoot项目在运行是，怎么查看输出的日志信息呢？</p>
<pre><code class="language-sh">docker logs test
</code></pre>
<p>这里使用<code>log</code>命令来打印容器中的日志信息：</p>
<figure data-type="image" tabindex="127"><img src="https://s2.loli.net/2022/07/01/scNgb1uheEpiKL8.png" alt="image-20220701221210083" loading="lazy"></figure>
<p>当然也可以添加<code>-f</code>参数来持续打印日志信息。</p>
<figure data-type="image" tabindex="128"><img src="https://s2.loli.net/2022/07/01/QTDeKASvHW1rXlw.png" alt="image-20220701215617022" loading="lazy"></figure>
<p>现在我们的容器已经启动了，但是我们想要进入到容器监控容器的情况怎么办呢？我们可以是<code>attach</code>命令来附加到容器启动命令的终端上：</p>
<pre><code class="language-sh">docker attach 容器ID/名称
</code></pre>
<figure data-type="image" tabindex="129"><img src="https://s2.loli.net/2022/07/01/QjHJsCt3DzqP6kZ.png" alt="image-20220701215829492" loading="lazy"></figure>
<p>注意现在就切换为了容器内的终端，如果想要退出的话，需要先按Ctrl+P然后再按Ctrl+Q来退出终端，不能直接使用Ctrl+C来终止，这样会直接终止掉Docker中运行的Java程序的。</p>
<figure data-type="image" tabindex="130"><img src="https://s2.loli.net/2022/07/01/XkFKtxq3Epua5ib.png" alt="image-20220701220018207" loading="lazy"></figure>
<p>退出后，容器依然是处于运行状态的。</p>
<p>我们也可以使用<code>exec</code>命令在容器中启动一个新的终端或是在容器中执行命令：</p>
<pre><code class="language-sh">docker exec -it test bash
</code></pre>
<p><code>-it</code>和<code>run</code>命令的操作是一样的，这里执行后，会创建一个新的终端（当然原本的程序还是在正常运行）我们会在一个新的终端中进行交互：</p>
<figure data-type="image" tabindex="131"><img src="https://s2.loli.net/2022/07/01/lMc2JueBLIFz9bf.png" alt="image-20220701220601732" loading="lazy"></figure>
<p>当然也可以仅仅在容器中执行一条命令：</p>
<figure data-type="image" tabindex="132"><img src="https://s2.loli.net/2022/07/01/aVvzjuEM56JmGd7.png" alt="image-20220701220909626" loading="lazy"></figure>
<p>执行后会在容器中打开一个新的终端执行命令，并输出结果。</p>
<p>前面我们还学习了容器的停止操作，通过输入<code>stop</code>命令来停止容器，但是此操作并不会立即停止，而是会等待容器处理善后，那么怎么样才能强制终止容器呢？我们可以直接使用<code>kill</code>命令，相当于给进程发送SIGKILL信号，强制结束。</p>
<pre><code class="language-sh">docker kill test
</code></pre>
<p>相比<code>stop</code>命令，<code>kill</code>就没那么温柔了。</p>
<p>有时候可能只是希望容器暂时停止运行，而不是直接终止运行，我们希望在未来的某个时间点，恢复容器的运行，此时就可以使用<code>pause</code>命令来暂停容器：</p>
<pre><code class="language-sh">docker pause test
</code></pre>
<p>暂停容器后，程序暂时停止运行，无法响应浏览器发送的请求：</p>
<figure data-type="image" tabindex="133"><img src="https://s2.loli.net/2022/07/01/1yBYnGmuXVbNFKO.png" alt="image-20220701222537737" loading="lazy"></figure>
<figure data-type="image" tabindex="134"><img src="https://s2.loli.net/2022/07/01/ovbqk7xS3LKhmOH.png" alt="image-20220701222243900" loading="lazy"></figure>
<p>此时处于爱的魔力转圈圈状态，我们可以将其恢复运行，使用<code>unpause</code>命令：</p>
<pre><code class="language-sh">docker unpause test
</code></pre>
<p>恢复运行后，瞬间就响应成功了。</p>
<figure data-type="image" tabindex="135"><img src="https://s2.loli.net/2022/07/01/g2b8mxVz1i7WJop.png" alt="image-20220701222323948" loading="lazy"></figure>
<h3 id="物理资源管理">物理资源管理</h3>
<p>对于一个容器，在某些情况下我们可能并不希望它占据所有的系统资源来运行，我们只希望分配一部分资源给容器，比如只分配给容器2G内存，最大只允许使用2G，不允许再占用更多的内存，此时我们就需要对容器的资源进行限制。</p>
<pre><code class="language-sh">docker run -m 内存限制 --memory-swap=内存和交换分区总共的内存限制 镜像名称
</code></pre>
<p>其中<code>-m</code>参数是对容器的物理内存的使用限制，而<code>--memory-swap</code>是对内存和交换分区总和的限制，它们默认都是<code>-1</code>，也就是说没有任何的限制（如果在一开始仅指定<code>-m</code>参数，那么交换内存的限制与其保持一致，内存+交换等于<code>-m</code>的两倍大小）默认情况下跟宿主主机一样，都是2G内存，现在我们可以将容器的内存限制到100M试试看，其中物理内存50M，交换内存50M，尝试启动一下SpringBoot程序：</p>
<pre><code class="language-sh">docker run -it -m 50M --memory-swap=100M nagocoler/springboot-test:1.0
</code></pre>
<p>可以看到，上来就因为内存不足无法启动了：</p>
<figure data-type="image" tabindex="136"><img src="https://s2.loli.net/2022/07/02/MrBWZKIzgxE94Ck.png" alt="image-20220702104653971" loading="lazy"></figure>
<p>当然除了对内存的限制之外，我们也可以对CPU资源进行限额，默认情况下所有的容器都可以平等地使用CPU资源，我们可以调整不同的容器的CPU权重（默认为1024），来按需分配资源，这里需要使用到<code>-c</code>选项，也可以输入全名<code>--cpu-share</code>：</p>
<pre><code class="language-sh">docker run -c 1024 ubuntu
docker run -c 512 ubuntu
</code></pre>
<p>这里容器的CPU权重比例为16比8，也就是2比1（注意多个容器时才会生效），那么当CPU资源紧张时，会按照此权重来分配资源，当然如果CPU资源并不紧张的情况下，依然是有机会使用到全部的CPU资源的。</p>
<p>这里我们使用一个压力测试工具来进行验证：</p>
<pre><code class="language-sh">docker run -c 1024 --name=cpu1024 -it ubuntu
docker run -c 512 --name=cpu512 -it ubuntu
</code></pre>
<p>接着我们分别进入容器安装<code>stress</code>压力测试工具：</p>
<pre><code class="language-sh">apt update &amp;&amp; apt install -y stress
</code></pre>
<p>接着我们分别在两个容器中都启动压力测试工具，产生4个进程不断计算随机数的平方根：</p>
<pre><code class="language-sh">stress -c 4
</code></pre>
<p>接着我们进入top来看看CPU状态（看完之后记得赶紧去kill掉容器，不然CPU拉满很卡的）：</p>
<figure data-type="image" tabindex="137"><img src="https://s2.loli.net/2022/07/02/3dHkMWnq1ZxCyKm.png" alt="image-20220702114126128" loading="lazy"></figure>
<p>可以看到权重高的容器中，分配到了更多的CPU资源，而权重低的容器中，只分配到一半的CPU资源。</p>
<p>当然我们也可以直接限制容器使用的CPU数量：</p>
<pre><code class="language-sh">docker run -it --cpuset-cpus=1 ubuntu
</code></pre>
<p><code>--cpuset-cpus</code>选项可以直接限制在指定的CPU上运行，比如现在我们的宿主机是2核的CPU，那么就可以分0和1这两个CPU给Docker使用，限制后，只会使用CPU 1的资源了：</p>
<figure data-type="image" tabindex="138"><img src="https://s2.loli.net/2022/07/02/erovkRBi7hSOuAt.png" alt="image-20220702115538699" loading="lazy"></figure>
<p>可以看到，4个进程只各自使用了25%的CPU，加在一起就是100%，也就是只能占满一个CPU的使用率。如果要分配多个CPU，则使用逗号隔开：</p>
<pre><code class="language-sh">docker run -it --cpuset-cpus=0,1 ubuntu
</code></pre>
<p>这样就会使用这两个CPU了：</p>
<figure data-type="image" tabindex="139"><img src="https://s2.loli.net/2022/07/02/rdAPYlfsgeLOZa9.png" alt="image-20220702115818344" loading="lazy"></figure>
<p>当然也可以直接使用<code>--cpus</code>来限制使用的CPU资源数：</p>
<pre><code class="language-sh">docker run -it --cpus=1 ubuntu
</code></pre>
<figure data-type="image" tabindex="140"><img src="https://s2.loli.net/2022/07/02/pUGCjlsQbEM2Ika.png" alt="image-20220702120329140" loading="lazy"></figure>
<p>限制为1后，只能使用一个CPU提供的资源，所以这里加载一起只有一个CPU的资源了。当然还有更精细的<code>--cpu-period </code>和<code>--cpu-quota</code>，这里就不做介绍了。</p>
<p>最后我们来看一下对磁盘IO读写性能的限制，我们首先使用<code>dd</code>命令来测试磁盘读写速度：</p>
<pre><code class="language-sh">dd if=/dev/zero of=/tmp/1G bs=4k count=256000 oflag=direct
</code></pre>
<p>可以不用等待跑完，中途Ctrl+C结束就行：</p>
<figure data-type="image" tabindex="141"><img src="https://s2.loli.net/2022/07/02/1y3O2qbaMsxDFUJ.png" alt="image-20220702121839871" loading="lazy"></figure>
<p>可以看到当前的读写速度为86.4 MB/s，我们可以通过<code>--device-read/write-bps</code>和<code>--device-read/write-iops</code>参数对其进行限制。</p>
<p>这里要先说一下区别：</p>
<ul>
<li>bps：每秒读写的数据量。</li>
<li>iops：每秒IO的次数。</li>
</ul>
<p>为了直观，这里我们直接使用BPS作为限制条件：</p>
<pre><code class="language-sh">docker run -it --device-write-bps=/dev/sda:10MB ubuntu
</code></pre>
<p>因为容器的文件系统是在<code>/dev/sda</code>上的，所以这我们就<code>/dev/sda:10MB</code>来限制对/dev/sda的写入速度只有10MB/s，我们来测试一下看看：</p>
<figure data-type="image" tabindex="142"><img src="https://s2.loli.net/2022/07/02/EczxDAmUCvlwT5u.png" alt="image-20220702122557288" loading="lazy"></figure>
<p>可以看到现在的速度就只有10MB左右了。</p>
<h3 id="容器监控">容器监控</h3>
<p>最后我们来看看如何对容器的运行状态进行实时监控，我们现在希望能够对容器的资源占用情况进行监控，该怎么办呢？</p>
<p>我们可以使用<code>stats</code>命令来进行监控：</p>
<pre><code class="language-sh">docker stats
</code></pre>
<figure data-type="image" tabindex="143"><img src="https://s2.loli.net/2022/07/02/hl6qw7sXuavA4pY.png" alt="image-20220702153236692" loading="lazy"></figure>
<p>可以实时对容器的各项状态进行监控，包括内存使用、CPU占用、网络I/O、磁盘I/O等信息，当然如果我们限制内存的使用的话：</p>
<pre><code class="language-sh">docker run -d -m 200M nagocoler/springboot-test:1.0
</code></pre>
<p>可以很清楚地看到限制情况：</p>
<figure data-type="image" tabindex="144"><img src="https://s2.loli.net/2022/07/02/CGc6T4iYyN7PD51.png" alt="image-20220702153704729" loading="lazy"></figure>
<p>除了使用<code>stats</code>命令来实时监控情况之外，还可以使用<code>top</code>命令来查看容器中的进程：</p>
<pre><code class="language-sh">docker top 容器ID/名称
</code></pre>
<figure data-type="image" tabindex="145"><img src="https://s2.loli.net/2022/07/02/ytMjZXK9aivTAWD.png" alt="image-20220702153957780" loading="lazy"></figure>
<p>当然也可以携带一些参数，具体的参数与Linux中<code>ps</code>命令参数一致，这里就不多做介绍了。</p>
<p>但是这样的监控是不是太原始了一点？有没有那种网页面板可以进行实时监控和管理的呢？有的。</p>
<p>我们需要单独部署一个Docker网页管理面板应用，一般比较常见的有：Portainer，我们这里可以直接通过Docker镜像的方式去部署这个应用程序，搜索一下，发现最新版维护的地址为：https://hub.docker.com/r/portainer/portainer-ce</p>
<p>CE为免费的社区版本，当然也有BE商业版本，这里我们就直接安装社区版就行了，官方Linux安装教程：https://docs.portainer.io/start/install/server/docker/linux，包含一些安装前需要的准备。</p>
<p>首先我们需要创建一个数据卷供Portainer使用：</p>
<pre><code class="language-sh">docker volume create portainer_data
</code></pre>
<p>接着通过官方命令安装启动：</p>
<pre><code class="language-sh">docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest
</code></pre>
<p>注意这里需要开放两个端口，一个是8000端口，还有一个是9443端口。</p>
<figure data-type="image" tabindex="146"><img src="https://s2.loli.net/2022/07/02/m71ha8YWsUzPFJ4.png" alt="image-20220702155450772" loading="lazy"></figure>
<p>OK，开启成功，我们可以直接登录后台面板：https://IP:9443/，这里需要HTTPS访问，浏览器可能会提示不安全，无视就行：</p>
<figure data-type="image" tabindex="147"><img src="https://s2.loli.net/2022/07/02/mukzgvnWZyrxeaM.png" alt="image-20220702155637366" loading="lazy"></figure>
<figure data-type="image" tabindex="148"><img src="https://s2.loli.net/2022/07/02/E3vy1MKPAr5OJtW.png" alt="image-20220702155703962" loading="lazy"></figure>
<p>进入后就需要我们进行注册了，这里我们只需输入两次密码即可，默认用户名就是admin，填写完成后，我们就可以开始使用了：</p>
<figure data-type="image" tabindex="149"><img src="https://s2.loli.net/2022/07/02/P1JIKaMCl7guYoz.png" alt="image-20220702160124676" loading="lazy"></figure>
<p>点击Get Started即可进入到管理页面，我们可以看到目前有一个本地的Docker服务器正在运行：</p>
<figure data-type="image" tabindex="150"><img src="https://s2.loli.net/2022/07/02/OUTrAEmwsNoSG8Y.png" alt="image-20220702160328972" loading="lazy"></figure>
<p>我们可以点击进入，进行详细地管理，不过唯一缺点就是没中文，挺难受的，也可以使用非官方的汉化版本：https://hub.docker.com/r/6053537/portainer-ce。</p>
<hr>
<h2 id="单机容器编排">单机容器编排</h2>
<p>最后我们来讲解一下Docker-Compose，它能够对我们的容器进行编排。比如现在我们要在一台主机上部署很多种类型的服务，包括数据库、消息队列、SpringBoot应用程序若干，或是想要搭建一个MySQL集群，这时我们就需要创建多个容器来完成来，但是我们希望能够实现一键部署，这时该怎么办呢？我们就要用到容器编排了，让多个容器按照我们自己的编排进行部署。</p>
<p>**官方文档：**https://docs.docker.com/get-started/08_using_compose/，视频教程肯定不可能把所有的配置全部介绍完，所以如果各位小伙伴想要了解更多的配置，有更多需求的话，可以直接查阅官方文档。</p>
<h3 id="快速开始">快速开始</h3>
<p>在Linux环境下我们需要先安装一下插件：</p>
<pre><code class="language-sh">sudo apt install docker-compose-plugin
</code></pre>
<p>接着输入<code>docker compose version</code>来验证一下是否安装成功。</p>
<figure data-type="image" tabindex="151"><img src="https://s2.loli.net/2022/07/03/5XDiAMpgW9aqUGJ.png" alt="image-20220703163126221" loading="lazy"></figure>
<p>这里我们就以部署SpringBoot项目为例，我们继续使用之前打包好的SpringBoot项目，现在我们希望部署这个SpringBoot项目的同时，部署一个MySQL服务器，一个Redis服务器，这时我们SpringBoot项目要运行的整个完整环境，先获取到对应的镜像：</p>
<pre><code class="language-sh">docker pull mysql/mysql-server
docker pull redis
</code></pre>
<p>接着，我们需要在自己的本地安装一下DockerCompose，下载地址：https://github.com/docker/compose/releases，下载自己电脑对应的版本，然后在IDEA中配置：</p>
<figure data-type="image" tabindex="152"><img src="https://s2.loli.net/2022/07/03/GmcqXEV3tsPQYd9.png" alt="image-20220703175103531" loading="lazy"></figure>
<p>下载完成后，将Docker Compose可执行文件路径修改为你存放刚刚下载的可执行文件的路径，Windows直接设置路径就行，MacOS下载之后需要进行下面的操作：</p>
<pre><code class="language-sh">mv 下载的文件名称 docker-compose
sudo chmod 777 docker-compose
sudo mv docker-compose /usr/local/bin
</code></pre>
<p>配置完成后就可以正常使用了，否则会无法运行，接着我们就可以开始在IDEA中编写docker-compose.yml文件了。</p>
<figure data-type="image" tabindex="153"><img src="https://s2.loli.net/2022/07/03/M1gcJFUfQtnEpmB.png" alt="image-20220703180206437" loading="lazy"></figure>
<p>这里点击右上角的“与服务工具窗口同步”按钮，这样一会就可以在下面查看情况了。</p>
<p>我们现在就从头开始配置这个文件，现在我们要创建三个服务，一个是MySQL服务器，一个是Redis服务器，还有一个是SpringBoot服务器，需要三个容器来分别运行，首先我们先写上这三个服务：</p>
<pre><code class="language-yaml">version: &quot;3.9&quot;  #首先是版本号，别乱写，这个是和Docker版本有对应的
services:   #services里面就是我们所有需要进行编排的服务了
  spring:   #服务名称，随便起
    container_name: app_springboot  #一会要创建的容器名称
  mysql:
    container_name: app_mysql
  redis:
    container_name: app_redis
</code></pre>
<p>这样我们就配置好了一会要创建的三个服务和对应的容器名称，接着我们需要指定一下这些容器对应的镜像了，首先是我们的SpringBoot应用程序，可能我们后续还会对应用程序进行更新和修改，所以这里我们部署需要先由Dockerfile构建出镜像后，再进行部署：</p>
<pre><code class="language-yaml">spring:
  container_name: app_springboot
  build: .  #build表示使用构建的镜像，.表示使用当前目录下的Dockerfile进行构建
</code></pre>
<p>我们这里修改一下Dockerfile，将基础镜像修改为已经打包好JDK环境的镜像：</p>
<pre><code class="language-dockerfile">FROM adoptopenjdk/openjdk8
COPY target/DockerTest-0.0.1-SNAPSHOT.jar app.jar
CMD java -jar app.jar
</code></pre>
<p>接着是另外两个服务，另外两个服务需要使用对应的镜像来启动容器：</p>
<pre><code class="language-yml">mysql:
  container_name: app_mysql
  image: mysql/mysql-server:latest  #image表示使用对应的镜像，这里会自动从仓库下载，然后启动容器
redis:
  container_name: app_redis
  image: redis:latest
</code></pre>
<p>还没有结束，我们还需要将SpringBoot项目的端口进行映射，最后一个简单的docker-compose配置文件就编写完成了：</p>
<pre><code class="language-yaml">version: &quot;3.9&quot;  #首先是版本号，别乱写，这个是和Docker版本有对应的
services:   #services里面就是我们所有需要进行编排的服务了
  spring:   #服务名称，随便起
    container_name: app_springboot  #一会要创建的容器名称
    build: .
    ports:
    - &quot;8080:8080&quot;
  mysql:
    container_name: app_mysql
    image: mysql/mysql-server:latest
  redis:
    container_name: app_redis
    image: redis:latest
</code></pre>
<p>现在我们就可以直接一键部署了，我们点击下方部署按钮：</p>
<figure data-type="image" tabindex="154"><img src="https://s2.loli.net/2022/07/03/bTWZkQidsqfNc9w.png" alt="image-20220703182541976" loading="lazy"></figure>
<figure data-type="image" tabindex="155"><img src="https://s2.loli.net/2022/07/03/YHzOEhS5giBVql2.png" alt="image-20220703182559020" loading="lazy"></figure>
<p>看到 Running 4/4 就表示已经部署成功了，我们现在到服务器这边来看看情况：</p>
<figure data-type="image" tabindex="156"><img src="https://s2.loli.net/2022/07/03/ZAsg3KM8r19malT.png" alt="image-20220703182657205" loading="lazy"></figure>
<p>可以看到，这里确实是按照我们的配置，创建了3个容器，并且都是处于运行中，可以正常访问：</p>
<figure data-type="image" tabindex="157"><img src="https://s2.loli.net/2022/07/03/GqbV1SWMRY8jnEc.png" alt="image-20220703182958392" loading="lazy"></figure>
<p>如果想要结束的话，我们只需要点击停止就行了：</p>
<figure data-type="image" tabindex="158"><img src="https://s2.loli.net/2022/07/03/ZNRB1XegVFJEaQ7.png" alt="image-20220703183240400" loading="lazy"></figure>
<p>当然如果我们不再需要这套环境的话，可以直接点击下方的按钮，将整套编排给down掉，这样的话相对应的容器也会被清理的：</p>
<figure data-type="image" tabindex="159"><img src="https://s2.loli.net/2022/07/03/IOVsb3tGpqAnHk9.png" alt="image-20220703183730693" loading="lazy"></figure>
<figure data-type="image" tabindex="160"><img src="https://s2.loli.net/2022/07/03/ZWbxDKTCimdo6Mr.png" alt="image-20220703183807157" loading="lazy"></figure>
<p>注意在使用docker-compose部署时，会自动创建一个新的自定义网络，并且所有的容器都是连接到这个自定义的网络里面：</p>
<figure data-type="image" tabindex="161"><img src="https://s2.loli.net/2022/07/03/NB2MfgA5GZuCSnd.png" alt="image-20220703210431690" loading="lazy"></figure>
<p>这个网络默认也是使用bridge作为驱动：</p>
<figure data-type="image" tabindex="162"><img src="https://s2.loli.net/2022/07/03/jEazItdPKxuRcCQ.png" alt="image-20220703210531073" loading="lazy"></figure>
<p>这样，我们就完成了一个简单的配置，去部署我们的整套环境。</p>
<h3 id="部署完整项目">部署完整项目</h3>
<p>前面我们学习了使用<code>docker-compose</code>进行简单部署，但是仅仅只是简单启动了服务，我们现在来将这些服务给连起来。首先是SpringBoot项目，我们先引入依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
   &lt;groupId&gt;mysql&lt;/groupId&gt;
   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>接着配置一下数据源，等等，我们怎么知道数据库的默认密码是多少呢？所以我们先配置一下MySQL服务：</p>
<pre><code class="language-yaml">mysql:
  container_name: app_mysql
  image: mysql/mysql-server:latest
  environment:   #这里我们通过环境变量配置MySQL的root账号和密码
    MYSQL_ROOT_HOST: '%'   #登陆的主机，这里直接配置为'%'
    MYSQL_ROOT_PASSWORD: '123456.root'    #MySQL root账号的密码，别设定得太简单了
    MYSQL_DATABASE: 'study'    #在启动时自动创建的数据库
    TZ: 'Asia/Shanghai'    #时区
  ports:
  - &quot;3306:3306&quot;    #把端口暴露出来，当然也可以不暴露，因为默认所有容器使用的是同一个网络
</code></pre>
<p>有关MySQL的详细配置请查阅：https://registry.hub.docker.com/_/mysql</p>
<p>接着我们将数据源配置完成：</p>
<pre><code class="language-yaml">spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://app_mysql:3306/study   #地址直接输入容器名称，会自动进行解析，前面已经讲过了
    username: root
    password: 123456.root
</code></pre>
<p>然后我们来写点测试的代码吧，这里我们使用JPA进行交互：</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
   &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
   &lt;artifactId&gt;lombok&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = &quot;db_account&quot;)
public class Account {

    @Column(name = &quot;id&quot;)
    @Id
    long id;

    @Column(name = &quot;name&quot;)
    String name;

    @Column(name = &quot;password&quot;)
    String password;
}
</code></pre>
<pre><code class="language-java">@Repository
public interface AccountRepository extends JpaRepository&lt;Account, Long&gt; {

}
</code></pre>
<pre><code class="language-java">@RestController
public class MainController {

    @Resource
    AccountRepository repository;

    @RequestMapping(&quot;/&quot;)
    public String hello(){
        return &quot;Hello World!&quot;;
    }

    @GetMapping(&quot;/get&quot;)
    public Account get(@RequestParam(&quot;id&quot;) long id){
        return repository.findById(id).orElse(null);
    }

    @PostMapping(&quot;/post&quot;)
    public Account get(@RequestParam(&quot;id&quot;) long id,
                       @RequestParam(&quot;name&quot;) String name,
                       @RequestParam(&quot;password&quot;) String password){
        return repository.save(new Account(id, name, password));
    }
}
</code></pre>
<p>接着我们来修改一下配置文件：</p>
<pre><code class="language-yaml">spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://app_mysql:3306/study
    username: root
    password: 123456.root
  jpa:
    database: mysql
    show-sql: true
    hibernate:
      ddl-auto: update   #这里自动执行DDL创建表，全程自动化，尽可能做到开箱即用
</code></pre>
<p>现在代码编写完成后，我们可以将项目打包了，注意执行我们下面的打包命令，不要进行测试，因为连不上数据库：</p>
<pre><code class="language-sh">mvn package -DskipTests
</code></pre>
<p>重新生成jar包后，我们修改一下docker-compose配置，因为MySQL的启动速度比较慢，我们要一点时间等待其启动完成，如果连接不上数据库导致SpringBoot项目启动失败，我们就重启：</p>
<pre><code class="language-yaml">spring:   #服务名称，随便起
  container_name: app_springboot  #一会要创建的容器名称
  build: .
  ports:
  - &quot;8080:8080&quot;
  depends_on:  #这里设置一下依赖，需要等待mysql启动后才运行，但是没啥用，这个并不是等到启动完成后，而是进程建立就停止等待
  - mysql
  restart: always  #这里配置容器停止后自动重启
</code></pre>
<p>然后我们将之前自动构建的镜像删除，等待重新构建：</p>
<figure data-type="image" tabindex="163"><img src="https://s2.loli.net/2022/07/03/frdTCPDGIuqwAWH.png" alt="image-20220703215050497" loading="lazy"></figure>
<p>现在我们重新部署docker-compos吧：</p>
<figure data-type="image" tabindex="164"><img src="https://s2.loli.net/2022/07/03/Tjq8ZYiU4FewKHE.png" alt="image-20220703215133786" loading="lazy"></figure>
<p>当三个服务全部为蓝色时，就表示已经正常运行了，现在我们来测试一下吧：</p>
<figure data-type="image" tabindex="165"><img src="https://s2.loli.net/2022/07/03/3TYABoDZGpK6Rjb.png" alt="image-20220703215211999" loading="lazy"></figure>
<p>接着我们来试试看向数据库传入数据：</p>
<figure data-type="image" tabindex="166"><img src="https://s2.loli.net/2022/07/03/nVEURiAe7qjworl.png" alt="image-20220703215236719" loading="lazy"></figure>
<figure data-type="image" tabindex="167"><img src="https://s2.loli.net/2022/07/03/QKFDdriwJCgPbxW.png" alt="image-20220703215245757" loading="lazy"></figure>
<p>可以看到响应成功，接着我们来请求一下：</p>
<figure data-type="image" tabindex="168"><img src="https://s2.loli.net/2022/07/03/uB6rYDCSbLXmOPE.png" alt="image-20220703215329690" loading="lazy"></figure>
<p>这样，我们的项目和MySQL基本就是自动部署了。</p>
<p>接着我们来配置一下Redis：</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>接着配置连接信息：</p>
<pre><code class="language-yaml">spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://app_mysql:3306/study
    username: root
    password: 123456.root
  jpa:
    database: mysql
    show-sql: true
    hibernate:
      ddl-auto: update
  redis:
    host: app_redis
</code></pre>
<pre><code class="language-java">//再加两个Redis操作进来
@Resource
StringRedisTemplate template;

@GetMapping(&quot;/take&quot;)
public String take(@RequestParam(&quot;key&quot;) String key){
    return template.opsForValue().get(key);
}

@PostMapping(&quot;/put&quot;)
public String  put(@RequestParam(&quot;key&quot;) String key,
                   @RequestParam(&quot;value&quot;) String value){
    template.opsForValue().set(key, value);
    return &quot;操作成功！&quot;;
}
</code></pre>
<p>最后我们来配置一下docker-compose的配置文件：</p>
<pre><code class="language-yaml">redis:
  container_name: app_redis
  image: redis:latest
  ports:
  - &quot;6379:6379&quot;
</code></pre>
<p>OK，按照之前的方式，我们重新再部署一下，然后测试：</p>
<figure data-type="image" tabindex="169"><img src="https://s2.loli.net/2022/07/03/2O9ExC4YgrJsjfe.png" alt="image-20220703220941562" loading="lazy"></figure>
<figure data-type="image" tabindex="170"><img src="https://s2.loli.net/2022/07/03/1SRG8EDtx5Oqr2M.png" alt="image-20220703221002195" loading="lazy"></figure>
<p>这样我们就完成整套环境+应用程序的配置了，我们在部署整个项目时，只需要使用docker-compose配置文件进行启动即可，这样就大大方便了我们的操作，实现开箱即用。甚至我们还可以专门使用一个平台来同时对多个主机进行一次性配置，大规模快速部署，而这些就留到以后的课程中再说吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JUC笔记（一）]]></title>
        <id>https://muouren7.github.io/post/JUC笔记（一）/</id>
        <link href="https://muouren7.github.io/post/JUC笔记（一）/">
        </link>
        <updated>2022-10-14T08:06:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="再谈多线程">再谈多线程</h1>
<blockquote>
<p>JUC相对于Java应用层的学习难度更大，<strong>开篇推荐掌握的预备知识：<strong>JavaSE多线程部分</strong>（必备）</strong>、操作系统、JVM**（推荐）**、计算机组成原理。掌握预备知识会让你的学习更加轻松，其中，JavaSE多线程部分要求必须掌握，否则无法继续学习本教程！我们不会再去重复教学JavaSE阶段的任何知识了。</p>
<p>各位小伙伴一定要点击收藏按钮（收藏 = 学会）</p>
</blockquote>
<p>还记得我们在JavaSE中学习的多线程吗？让我们来回顾一下：</p>
<p>在我们的操作系统之上，可以同时运行很多个进程，并且每个进程之间相互隔离互不干扰。我们的CPU会通过时间片轮转算法，为每一个进程分配时间片，并在时间片使用结束后切换下一个进程继续执行，通过这种方式来实现宏观上的多个程序同时运行。</p>
<p>由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时，那么有没有一种更好地方案呢？</p>
<p>后来，线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。</p>
<p>现在有这样一个问题：</p>
<pre><code class="language-java">public static void main(String[] args) {
    int[] arr = new int[]{3, 1, 5, 2, 4};
    //请将上面的数组按升序输出
}
</code></pre>
<p>按照正常思维，我们肯定是这样：</p>
<pre><code class="language-java">public static void main(String[] args) {
    int[] arr = new int[]{3, 1, 5, 2, 4};
		//直接排序吧
    Arrays.sort(arr);
    for (int i : arr) {
        System.out.println(i);
    }
}
</code></pre>
<p>而我们学习了多线程之后，可以换个思路来实现：</p>
<pre><code class="language-java">public static void main(String[] args) {
    int[] arr = new int[]{3, 1, 5, 2, 4};

    for (int i : arr) {
        new Thread(() -&gt; {
            try {
                Thread.sleep(i * 1000);   //越小的数休眠时间越短，优先被打印
                System.out.println(i);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
</code></pre>
<p>我们接触过的很多框架都在使用多线程，比如Tomcat服务器，所有用户的请求都是通过不同的线程来进行处理的，这样我们的网站才可以同时响应多个用户的请求，要是没有多线程，可想而知服务器的处理效率会有多低。</p>
<p>虽然多线程能够为我们解决很多问题，但是，如何才能正确地使用多线程，如何才能将多线程的资源合理使用，这都是我们需要关心的问题。</p>
<p>在Java 5的时候，新增了java.util.concurrent（JUC）包，其中包括大量用于多线程编程的工具类，目的是为了更好的支持高并发任务，让开发者进行多线程编程时减少竞争条件和死锁的问题！通过使用这些工具类，我们的程序会更加合理地使用多线程。而我们这一系列视频的主角，正是<code>JUC</code>。</p>
<p>但是我们先不着急去看这些内容，第一章，我们先来补点基础知识。</p>
<hr>
<h2 id="并发与并行">并发与并行</h2>
<p>我们经常听到并发编程，那么这个并发代表的是什么意思呢？而与之相似的并行又是什么意思？它们之间有什么区别？</p>
<p>比如现在一共有三个工作需要我们去完成。</p>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzupjszpjnj21bk06ujrw.jpg" alt="image-20220301213510841" loading="lazy"></figure>
<h3 id="顺序执行">顺序执行</h3>
<p>顺序执行其实很好理解，就是我们依次去将这些任务完成了：</p>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzupl4sldlj219s06et98.jpg" alt="image-20220301213629649" loading="lazy"></figure>
<p>实际上就是我们同一时间只能处理一个任务，所以需要前一个任务完成之后，才能继续下一个任务，依次完成所有任务。</p>
<h3 id="并发执行">并发执行</h3>
<p>并发执行也是我们同一时间只能处理一个任务，但是我们可以每个任务轮着做（时间片轮转）：</p>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzuppchmldj21lm078myf.jpg" alt="image-20220301214032719" loading="lazy"></figure>
<p>只要我们单次处理分配的时间足够的短，在宏观看来，就是三个任务在同时进行。</p>
<p>而我们Java中的线程，正是这种机制，当我们需要同时处理上百个上千个任务时，很明显CPU的数量是不可能赶得上我们的线程数的，所以说这时就要求我们的程序有良好的并发性能，来应对同一时间大量的任务处理。学习Java并发编程，能够让我们在以后的实际场景中，知道该如何应对高并发的情况。</p>
<h3 id="并行执行">并行执行</h3>
<p>并行执行就突破了同一时间只能处理一个任务的限制，我们同一时间可以做多个任务：</p>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzuprj83gqj21hw0hqmz2.jpg" alt="image-20220301214238743" loading="lazy"></figure>
<p>比如我们要进行一些排序操作，就可以用到并行计算，只需要等待所有子任务完成，最后将结果汇总即可。包括分布式计算模型MapReduce，也是采用的并行计算思路。</p>
<hr>
<h2 id="再谈锁机制">再谈锁机制</h2>
<p>谈到锁机制，相信各位应该并不陌生了，我们在JavaSE阶段，通过使用<code>synchronized</code>关键字来实现锁，这样就能够很好地解决线程之间争抢资源的情况。那么，<code>synchronized</code>底层到底是如何实现的呢？</p>
<p>我们知道，使用<code>synchronized</code>，一定是和某个对象相关联的，比如我们要对某一段代码加锁，那么我们就需要提供一个对象来作为锁本身：</p>
<pre><code class="language-java">public static void main(String[] args) {
    synchronized (Main.class) {
        //这里使用的是Main类的Class对象作为锁
    }
}
</code></pre>
<p>我们来看看，它变成字节码之后会用到哪些指令：</p>
<figure data-type="image" tabindex="5"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzvdbajqhfj229a0u0te0.jpg" alt="image-20220302111724784" loading="lazy"></figure>
<p>其中最关键的就是<code>monitorenter</code>指令了，可以看到之后也有<code>monitorexit</code>与之进行匹配（注意这里有2个），<code>monitorenter</code>和<code>monitorexit</code>分别对应加锁和释放锁，在执行<code>monitorenter</code>之前需要尝试获取锁，每个对象都有一个<code>monitor</code>监视器与之对应，而这里正是去获取对象监视器的所有权，一旦<code>monitor</code>所有权被某个线程持有，那么其他线程将无法获得（管程模型的一种实现）。</p>
<p>在代码执行完成之后，我们可以看到，一共有两个<code>monitorexit</code>在等着我们，那么为什么这里会有两个呢，按理说<code>monitorenter</code>和<code>monitorexit</code>不应该一一对应吗，这里为什么要释放锁两次呢？</p>
<p>首先我们来看第一个，这里在释放锁之后，会马上进入到一个goto指令，跳转到15行，而我们的15行对应的指令就是方法的返回指令，其实正常情况下只会执行第一个<code>monitorexit</code>释放锁，在释放锁之后就接着同步代码块后面的内容继续向下执行了。而第二个，其实是用来处理异常的，可以看到，它的位置是在12行，如果程序运行发生异常，那么就会执行第二个<code>monitorexit</code>，并且会继续向下通过<code>athrow</code>指令抛出异常，而不是直接跳转到15行正常运行下去。</p>
<figure data-type="image" tabindex="6"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzve59lrkqj21wq0ca76u.jpg" alt="image-20220302114613847" loading="lazy"></figure>
<p>实际上<code>synchronized</code>使用的锁就是存储在Java对象头中的，我们知道，对象是存放在堆内存中的，而每个对象内部，都有一部分空间用于存储对象头信息，而对象头信息中，则包含了Mark Word用于存放<code>hashCode</code>和对象的锁信息，在不同状态下，它存储的数据结构有一些不同。</p>
<figure data-type="image" tabindex="7"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzvtjfgg91j21e00howh1.jpg" alt="image-20220302203846868" loading="lazy"></figure>
<h3 id="重量级锁">重量级锁</h3>
<p>在JDK6之前，<code>synchronized</code>一直被称为重量级锁，<code>monitor</code>依赖于底层操作系统的Lock实现，Java的线程是映射到操作系统的原生线程上，切换成本较高。而在JDK6之后，锁的实现得到了改进。我们先从最原始的重量级锁开始：</p>
<p>我们说了，每个对象都有一个monitor与之关联，在Java虚拟机（HotSpot）中，monitor是由ObjectMonitor实现的：</p>
<pre><code class="language-c++">ObjectMonitor() {
    _header       = NULL;
    _count        = 0; //记录个数
    _waiters      = 0,
    _recursions   = 0;
    _object       = NULL;
    _owner        = NULL;
    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
}
</code></pre>
<p>每个等待锁的线程都会被封装成ObjectWaiter对象，进入到如下机制：</p>
<figure data-type="image" tabindex="8"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzvej55r7tj20dw08vjrt.jpg" alt="img" loading="lazy"></figure>
<p>ObjectWaiter首先会进入 Entry Set等着，当线程获取到对象的<code>monitor</code>后进入 The Owner 区域并把<code>monitor</code>中的<code>owner</code>变量设置为当前线程，同时<code>monitor</code>中的计数器<code>count</code>加1，若线程调用<code>wait()</code>方法，将释放当前持有的<code>monitor</code>，<code>owner</code>变量恢复为<code>null</code>，<code>count</code>自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放<code>monitor</code>并复位变量的值，以便其他线程进入获取对象的<code>monitor</code>。</p>
<p>虽然这样的设计思路非常合理，但是在大多数应用上，每一个线程占用同步代码块的时间并不是很长，我们完全没有必要将竞争中的线程挂起然后又唤醒，并且现代CPU基本都是多核心运行的，我们可以采用一种新的思路来实现锁。</p>
<p>在JDK1.4.2时，引入了自旋锁（JDK6之后默认开启），它不会将处于等待状态的线程挂起，而是通过无限循环的方式，不断检测是否能够获取锁，由于单个线程占用锁的时间非常短，所以说循环次数不会太多，可能很快就能够拿到锁并运行，这就是自旋锁。当然，仅仅是在等待时间非常短的情况下，自旋锁的表现会很好，但是如果等待时间太长，由于循环是需要处理器继续运算的，所以这样只会浪费处理器资源，因此自旋锁的等待时间是有限制的，默认情况下为10次，如果失败，那么会进而采用重量级锁机制。</p>
<figure data-type="image" tabindex="9"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzvmffuq1hj21dm0ae75f.jpg" alt="image-20220302163246988" loading="lazy"></figure>
<p>在JDK6之后，自旋锁得到了一次优化，自旋的次数限制不再是固定的，而是自适应变化的，比如在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行，那么这次自旋也是有可能成功的，所以会允许自旋更多次。当然，如果某个锁经常都自旋失败，那么有可能会不再采用自旋策略，而是直接使用重量级锁。</p>
<h3 id="轻量级锁">轻量级锁</h3>
<blockquote>
<p>从JDK 1.6开始，为了减少获得锁和释放锁带来的性能消耗，就引入了轻量级锁。</p>
</blockquote>
<p>轻量级锁的目标是，在无竞争情况下，减少重量级锁产生的性能消耗（并不是为了代替重量级锁，实际上就是赌一手同一时间只有一个线程在占用资源），包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。它不像是重量级锁那样，需要向操作系统申请互斥量。它的运作机制如下：</p>
<p>在即将开始执行同步代码块中的内容时，会首先检查对象的Mark Word，查看锁对象是否被其他线程占用，如果没有任何线程占用，那么会在当前线程中所处的栈帧中建立一个名为锁记录（Lock Record）的空间，用于复制并存储对象目前的Mark Word信息（官方称为Displaced Mark Word）。</p>
<p>接着，虚拟机将使用CAS操作将对象的Mark Word更新为轻量级锁状态（数据结构变为指向Lock Record的指针，指向的是当前的栈帧）</p>
<blockquote>
<p>CAS（Compare And Swap）是一种无锁算法（我们之前在Springboot阶段已经讲解过了），它并不会为对象加锁，而是在执行的时候，看看当前数据的值是不是我们预期的那样，如果是，那就正常进行替换，如果不是，那么就替换失败。比如有两个线程都需要修改变量<code>i</code>的值，默认为10，现在一个线程要将其修改为20，另一个要修改为30，如果他们都使用CAS算法，那么并不会加锁访问<code>i</code>，而是直接尝试修改<code>i</code>的值，但是在修改时，需要确认<code>i</code>是不是10，如果是，表示其他线程还没对其进行修改，如果不是，那么说明其他线程已经将其修改，此时不能完成修改任务，修改失败。</p>
<p>在CPU中，CAS操作使用的是<code>cmpxchg</code>指令，能够从最底层硬件层面得到效率的提升。</p>
</blockquote>
<p>如果CAS操作失败了的话，那么说明可能这时有线程已经进入这个同步代码块了，这时虚拟机会再次检查对象的Mark Word，是否指向当前线程的栈帧，如果是，说明不是其他线程，而是当前线程已经有了这个对象的锁，直接放心大胆进同步代码块即可。如果不是，那确实是被其他线程占用了。</p>
<p>这时，轻量级锁一开始的想法就是错的（这时有对象在竞争资源，已经赌输了），所以说只能将锁膨胀为重量级锁，按照重量级锁的操作执行（注意锁的膨胀是不可逆的）</p>
<figure data-type="image" tabindex="10"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzvuebbr7ej21b20ba763.jpg" alt="image-20220302210830272" loading="lazy"></figure>
<p>所以，轻量级锁 -&gt; 失败 -&gt; 自适应自旋锁 -&gt; 失败 -&gt; 重量级锁</p>
<p>解锁过程同样采用CAS算法，如果对象的MarkWord仍然指向线程的锁记录，那么就用CAS操作把对象的MarkWord和复制到栈帧中的Displaced Mark Word进行交换。如果替换失败，说明其他线程尝试过获取该锁，在释放锁的同时，需要唤醒被挂起的线程。</p>
<h3 id="偏向锁">偏向锁</h3>
<p>偏向锁相比轻量级锁更纯粹，干脆就把整个同步都消除掉，不需要再进行CAS操作了。它的出现主要是得益于人们发现某些情况下某个锁频繁地被同一个线程获取，这种情况下，我们可以对轻量级锁进一步优化。</p>
<p>偏向锁实际上就是专门为单个线程而生的，当某个线程第一次获得锁时，如果接下来都没有其他线程获取此锁，那么持有锁的线程将不再需要进行同步操作。</p>
<p>可以从之前的MarkWord结构中看到，偏向锁也会通过CAS操作记录线程的ID，如果一直都是同一个线程获取此锁，那么完全没有必要在进行额外的CAS操作。当然，如果有其他线程来抢了，那么偏向锁会根据当前状态，决定是否要恢复到未锁定或是膨胀为轻量级锁。</p>
<p>如果我们需要使用偏向锁，可以添加<code>-XX:+UseBiased</code>参数来开启。</p>
<p>所以，最终的锁等级为：未锁定 &lt; 偏向锁 &lt; 轻量级锁 &lt; 重量级锁</p>
<p>值得注意的是，如果对象通过调用<code>hashCode()</code>方法计算过对象的一致性哈希值，那么它是不支持偏向锁的，会直接进入到轻量级锁状态，因为Hash是需要被保存的，而偏向锁的Mark Word数据结构，无法保存Hash值；如果对象已经是偏向锁状态，再去调用<code>hashCode()</code>方法，那么会直接将锁升级为重量级锁，并将哈希值存放在<code>monitor</code>（有预留位置保存）中。</p>
<figure data-type="image" tabindex="11"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzvvi5l9jhj21cy0bwjtl.jpg" alt="image-20220302214647735" loading="lazy"></figure>
<h3 id="锁消除和锁粗化">锁消除和锁粗化</h3>
<p>锁消除和锁粗化都是在运行时的一些优化方案，比如我们某段代码虽然加了锁，但是在运行时根本不可能出现各个线程之间资源争夺的情况，这种情况下，完全不需要任何加锁机制，所以锁会被消除。锁粗化则是我们代码中频繁地出现互斥同步操作，比如在一个循环内部加锁，这样明显是非常消耗性能的，所以虚拟机一旦检测到这种操作，会将整个同步范围进行扩展。</p>
<hr>
<h2 id="jmm内存模型">JMM内存模型</h2>
<p>注意这里提到的内存模型和我们在JVM中介绍的内存模型不在同一个层次，JVM中的内存模型是虚拟机规范对整个内存区域的规划，而Java内存模型，是在JVM内存模型之上的抽象模型，具体实现依然是基于JVM内存模型实现的，我们会在后面介绍。</p>
<h3 id="java内存模型">Java内存模型</h3>
<p>我们在<code>计算机组成原理</code>中学习过，在我们的CPU中，一般都会有高速缓存，而它的出现，是为了解决内存的速度跟不上处理器的处理速度的问题，所以CPU内部会添加一级或多级高速缓存来提高处理器的数据获取效率，但是这样也会导致一个很明显的问题，因为现在基本都是多核心处理器，每个处理器都有一个自己的高速缓存，那么又该怎么去保证每个处理器的高速缓存内容一致呢？</p>
<figure data-type="image" tabindex="12"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzwjckl9pfj20x60cqdgt.jpg" alt="image-20220303113148313" loading="lazy"></figure>
<p>为了解决缓存一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。</p>
<p>而Java也采用了类似的模型来实现支持多线程的内存模型：</p>
<figure data-type="image" tabindex="13"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzwjnodcejj20xs0ewaba.jpg" alt="image-20220303114228749" loading="lazy"></figure>
<p>JMM（Java Memory Model）内存模型规定如下：</p>
<ul>
<li>所有的变量全部存储在主内存（注意这里包括下面提到的变量，指的都是会出现竞争的变量，包括成员变量、静态变量等，而局部变量这种属于线程私有，不包括在内）</li>
<li>每条线程有着自己的工作内存（可以类比CPU的高速缓存）线程对变量的所有操作，必须在工作内存中进行，不能直接操作主内存中的数据。</li>
<li>不同线程之间的工作内存相互隔离，如果需要在线程之间传递内容，只能通过主内存完成，无法直接访问对方的工作内存。</li>
</ul>
<p>也就是说，每一条线程如果要操作主内存中的数据，那么得先拷贝到自己的工作内存中，并对工作内存中数据的副本进行操作，操作完成之后，也需要从工作副本中将结果拷贝回主内存中，具体的操作就是<code>Save</code>（保存）和<code>Load</code>（加载）操作。</p>
<p>那么各位肯定会好奇，这个内存模型，结合之前JVM所讲的内容，具体是怎么实现的呢？</p>
<ul>
<li>主内存：对应堆中存放对象的实例的部分。</li>
<li>工作内存：对应线程的虚拟机栈的部分区域，虚拟机可能会对这部分内存进行优化，将其放在CPU的寄存器或是高速缓存中。比如在访问数组时，由于数组是一段连续的内存空间，所以可以将一部分连续空间放入到CPU高速缓存中，那么之后如果我们顺序读取这个数组，那么大概率会直接缓存命中。</li>
</ul>
<p>前面我们提到，在CPU中可能会遇到缓存不一致的问题，而Java中，也会遇到，比如下面这种情况：</p>
<pre><code class="language-java">public class Main {
    private static int i = 0;
    public static void main(String[] args) throws InterruptedException {
        new Thread(() -&gt; {
            for (int j = 0; j &lt; 100000; j++) i++;
            System.out.println(&quot;线程1结束&quot;);
        }).start();
        new Thread(() -&gt; {
            for (int j = 0; j &lt; 100000; j++) i++;
            System.out.println(&quot;线程2结束&quot;);
        }).start();
        //等上面两个线程结束
        Thread.sleep(1000);
        System.out.println(i);
    }
}
</code></pre>
<p>可以看到这里是两个线程同时对变量<code>i</code>各自进行100000次自增操作，但是实际得到的结果并不是我们所期望的那样。</p>
<p>那么为什么会这样呢？在之前学习了JVM之后，相信各位应该已经知道，自增操作实际上并不是由一条指令完成的（注意一定不要理解为一行代码就是一个指令完成的）：</p>
<figure data-type="image" tabindex="14"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzwojklg4fj224y0oktfi.jpg" alt="image-20220303143131899" loading="lazy"></figure>
<p>包括变量<code>i</code>的获取、修改、保存，都是被拆分为一个一个的操作完成的，那么这个时候就有可能出现在修改完保存之前，另一条线程也保存了，但是当前线程是毫不知情的。</p>
<figure data-type="image" tabindex="15"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzwow9xzb6j21kg0ayq54.jpg" alt="image-20220303144344450" loading="lazy"></figure>
<p>所以说，我们当时在JavaSE阶段讲解这个问题的时候，是通过<code>synchronized</code>关键字添加同步代码块解决的，当然，我们后面还会讲解另外的解决方案（原子类）</p>
<h3 id="重排序">重排序</h3>
<p>在编译或执行时，为了优化程序的执行效率，编译器或处理器常常会对指令进行重排序，有以下情况：</p>
<ol>
<li>编译器重排序：Java编译器通过对Java代码语义的理解，根据优化规则对代码指令进行重排序。</li>
<li>机器指令级别的重排序：现代处理器很高级，能够自主判断和变更机器指令的执行顺序。</li>
</ol>
<p>指令重排序能够在不改变结果（单线程）的情况下，优化程序的运行效率，比如：</p>
<pre><code class="language-java">public static void main(String[] args) {
    int a = 10;
    int b = 20;
    System.out.println(a + b);
}
</code></pre>
<p>我们其实可以交换第一行和第二行：</p>
<pre><code class="language-java">public static void main(String[] args) {
    int b = 10;
    int a = 20;
    System.out.println(a + b);
}
</code></pre>
<p>即使发生交换，但是我们程序最后的运行结果是不会变的，当然这里只通过代码的形式演示，实际上JVM在执行字节码指令时也会进行优化，可能两个指令并不会按照原有的顺序进行。</p>
<p>虽然单线程下指令重排确实可以起到一定程度的优化作用，但是在多线程下，似乎会导致一些问题：</p>
<pre><code class="language-java">public class Main {
    private static int a = 0;
    private static int b = 0;
    public static void main(String[] args) {
        new Thread(() -&gt; {
            if(b == 1) {
                if(a == 0) {
                    System.out.println(&quot;A&quot;);
                }else {
                    System.out.println(&quot;B&quot;);
                }   
            }
        }).start();
        new Thread(() -&gt; {
            a = 1;
            b = 1;
        }).start();
    }
}
</code></pre>
<p>上面这段代码，在正常情况下，按照我们的正常思维，是不可能输出<code>A</code>的，因为只要b等于1，那么a肯定也是1才对，因为a是在b之前完成的赋值。但是，如果进行了重排序，那么就有可能，a和b的赋值发生交换，b先被赋值为1，而恰巧这个时候，线程1开始判定b是不是1了，这时a还没来得及被赋值为1，可能线程1就已经走到打印那里去了，所以，是有可能输出<code>A</code>的。</p>
<h3 id="volatile关键字">volatile关键字</h3>
<p>好久好久都没有认识新的关键字了，今天我们来看一个新的关键字<code>volatile</code>，开始之前我们先介绍三个词语：</p>
<ul>
<li>原子性：其实之前讲过很多次了，就是要做什么事情要么做完，要么就不做，不存在做一半的情况。</li>
<li>可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>
<li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li>
</ul>
<p>我们之前说了，如果多线程访问同一个变量，那么这个变量会被线程拷贝到自己的工作内存中进行操作，而不是直接对主内存中的变量本体进行操作，下面这个操作看起来是一个有限循环，但是是无限的：</p>
<pre><code class="language-java">public class Main {
    private static int a = 0;
    public static void main(String[] args) throws InterruptedException {
        new Thread(() -&gt; {
            while (a == 0);
            System.out.println(&quot;线程结束！&quot;);
        }).start();

        Thread.sleep(1000);
        System.out.println(&quot;正在修改a的值...&quot;);
        a = 1;   //很明显，按照我们的逻辑来说，a的值被修改那么另一个线程将不再循环
    }
}
</code></pre>
<p>实际上这就是我们之前说的，虽然我们主线程中修改了a的值，但是另一个线程并不知道a的值发生了改变，所以循环中依然是使用旧值在进行判断，因此，普通变量是不具有可见性的。</p>
<p>要解决这种问题，我们第一个想到的肯定是加锁，同一时间只能有一个线程使用，这样总行了吧，确实，这样的话肯定是可以解决问题的：</p>
<pre><code class="language-java">public class Main {
    private static int a = 0;
    public static void main(String[] args) throws InterruptedException {
        new Thread(() -&gt; {
            while (a == 0) {
                synchronized (Main.class){}
            }
            System.out.println(&quot;线程结束！&quot;);
        }).start();

        Thread.sleep(1000);
        System.out.println(&quot;正在修改a的值...&quot;);
        synchronized (Main.class){
            a = 1;
        }
    }
}
</code></pre>
<p>但是，除了硬加一把锁的方案，我们也可以使用<code>volatile</code>关键字来解决，此关键字的第一个作用，就是保证变量的可见性。当写一个<code>volatile</code>变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去，并且这个写会操作会导致其他线程中的<code>volatile</code>变量缓存无效，这样，另一个线程修改了这个变时，当前线程会立即得知，并将工作内存中的变量更新为最新的版本。</p>
<p>那么我们就来试试看：</p>
<pre><code class="language-java">public class Main {
    //添加volatile关键字
    private static volatile int a = 0;
    public static void main(String[] args) throws InterruptedException {
        new Thread(() -&gt; {
            while (a == 0);
            System.out.println(&quot;线程结束！&quot;);
        }).start();

        Thread.sleep(1000);
        System.out.println(&quot;正在修改a的值...&quot;);
        a = 1;
    }
}
</code></pre>
<p>结果还真的如我们所说的那样，当a发生改变时，循环立即结束。</p>
<p>当然，虽然说<code>volatile</code>能够保证可见性，但是不能保证原子性，要解决我们上面的<code>i++</code>的问题，以我们目前所学的知识，还是只能使用加锁来完成：</p>
<pre><code class="language-java">public class Main {
    private static volatile int a = 0;
    public static void main(String[] args) throws InterruptedException {
        Runnable r = () -&gt; {
            for (int i = 0; i &lt; 10000; i++) a++;
            System.out.println(&quot;任务完成！&quot;);
        };
        new Thread(r).start();
        new Thread(r).start();

        //等待线程执行完成
        Thread.sleep(1000);
        System.out.println(a);
    }
}
</code></pre>
<p>不对啊，<code>volatile</code>不是能在改变变量的时候其他线程可见吗，那为什么还是不能保证原子性呢？还是那句话，自增操作是被瓜分为了多个步骤完成的，虽然保证了可见性，但是只要手速够快，依然会出现两个线程同时写同一个值的问题（比如线程1刚刚将a的值更新为100，这时线程2可能也已经执行到更新a的值这条指令了，已经刹不住车了，所以依然会将a的值再更新为一次100）</p>
<p>那要是真的遇到这种情况，那么我们不可能都去写个锁吧？后面，我们会介绍原子类来专门解决这种问题。</p>
<p>最后一个功能就是<code>volatile</code>会禁止指令重排，也就是说，如果我们操作的是一个<code>volatile</code>变量，它将不会出现重排序的情况，也就解决了我们最上面的问题。那么它是怎么解决的重排序问题呢？若用volatile修饰共享变量，在编译时，会在指令序列中插入<code>内存屏障</code>来禁止特定类型的处理器重排序</p>
<blockquote>
<p>内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：</p>
<ol>
<li>保证特定操作的顺序</li>
<li>保证某些变量的内存可见性（volatile的内存可见性，其实就是依靠这个实现的）</li>
</ol>
<p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序。</p>
<figure data-type="image" tabindex="16"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzwtkeydk7j2194068jsd.jpg" alt="image-20220303172519404" loading="lazy"></figure>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad</td>
<td>Load1;LoadLoad;Load2</td>
<td>保证Load1的读取操作在Load2及后续读取操作之前执行</td>
</tr>
<tr>
<td>StoreStore</td>
<td>Store1;StoreStore;Store2</td>
<td>在Store2及其后的写操作执行前，保证Store1的写操作已刷新到主内存</td>
</tr>
<tr>
<td>LoadStore</td>
<td>Load1;LoadStore;Store2</td>
<td>在Store2及其后的写操作执行前，保证Load1的读操作已读取结束</td>
</tr>
<tr>
<td>StoreLoad</td>
<td>Store1;StoreLoad;Load2</td>
<td>保证load1的写操作已刷新到主内存之后，load2及其后的读操作才能执行</td>
</tr>
</tbody>
</table>
</blockquote>
<p>所以<code>volatile</code>能够保证，之前的指令一定全部执行，之后的指令一定都没有执行，并且前面语句的结果对后面的语句可见。</p>
<p>最后我们来总结一下<code>volatile</code>关键字的三个特性：</p>
<ul>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>防止指令重排</li>
</ul>
<p>在之后我们的设计模式系列视频中，还会讲解单例模式下<code>volatile</code>的运用。</p>
<h3 id="happens-before原则">happens-before原则</h3>
<p>经过我们前面的讲解，相信各位已经了解了JMM内存模型以及重排序等机制带来的优点和缺点，综上，JMM提出了<code>happens-before</code>（先行发生）原则，定义一些禁止编译优化的场景，来向各位程序员做一些保证，只要我们是按照原则进行编程，那么就能够保持并发编程的正确性。具体如下：</p>
<ul>
<li>**程序次序规则：**同一个线程中，按照程序的顺序，前面的操作happens-before后续的任何操作。
<ul>
<li>同一个线程内，代码的执行结果是有序的。其实就是，可能会发生指令重排，但是保证代码的执行结果一定是和按照顺序执行得到的一致，程序前面对某一个变量的修改一定对后续操作可见的，不可能会出现前面才把a修改为1，接着读a居然是修改前的结果，这也是程序运行最基本的要求。</li>
</ul>
</li>
<li>**监视器锁规则：**对一个锁的解锁操作，happens-before后续对这个锁的加锁操作。
<ul>
<li>就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果。比如前一个线程将变量<code>x</code>的值修改为了<code>12</code>并解锁，之后另一个线程拿到了这把锁，对之前线程的操作是可见的，可以得到<code>x</code>是前一个线程修改后的结果<code>12</code>（所以synchronized是有happens-before规则的）</li>
</ul>
</li>
<li>**volatile变量规则：**对一个volatile变量的写操作happens-before后续对这个变量的读操作。
<ul>
<li>就是如果一个线程先去写一个<code>volatile</code>变量，紧接着另一个线程去读这个变量，那么这个写操作的结果一定对读的这个变量的线程可见。</li>
</ul>
</li>
<li>**线程启动规则：**主线程A启动线程B，线程B中可以看到主线程启动B之前的操作。
<ul>
<li>在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</li>
</ul>
</li>
<li>**线程加入规则：**如果线程A执行操作<code>join()</code>线程B并成功返回，那么线程B中的任意操作happens-before线程A<code>join()</code>操作成功返回。</li>
<li>**传递性规则：**如果A happens-before B，B happens-before C，那么A happens-before C。</li>
</ul>
<p>那么我们来从happens-before原则的角度，来解释一下下面的程序结果：</p>
<pre><code class="language-java">public class Main {
    private static int a = 0;
  	private static int b = 0;
    public static void main(String[] args) {
        a = 10;
        b = a + 1;
        new Thread(() -&gt; {
          if(b &gt; 10) System.out.println(a); 
        }).start();
    }
}
</code></pre>
<p>首先我们定义以上出现的操作：</p>
<ul>
<li>**A：**将变量<code>a</code>的值修改为<code>10</code></li>
<li>**B：**将变量<code>b</code>的值修改为<code>a + 1</code></li>
<li>**C：**主线程启动了一个新的线程，并在新的线程中获取<code>b</code>，进行判断，如果大于<code>10</code>那么就打印<code>a</code></li>
</ul>
<p>首先我们来分析，由于是同一个线程，并且<strong>B</strong>是一个赋值操作且读取了<strong>A</strong>，那么按照<strong>程序次序规则</strong>，A happens-before B，接着在B之后，马上执行了C，按照<strong>线程启动规则</strong>，在新的线程启动之前，当前线程之前的所有操作对新的线程是可见的，所以 B happens-before C，最后根据<strong>传递性规则</strong>，由于A happens-before B，B happens-before C，所以A happens-before C，因此在新的线程中会输出<code>a</code>修改后的结果<code>10</code>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JUC笔记（三）]]></title>
        <id>https://muouren7.github.io/post/JUC笔记（三）/</id>
        <link href="https://muouren7.github.io/post/JUC笔记（三）/">
        </link>
        <updated>2022-10-14T08:06:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="并发编程进阶">并发编程进阶</h1>
<p>欢迎来到JUC学习的最后一章，王炸当然是放在最后了。</p>
<h2 id="线程池">线程池</h2>
<p>在我们的程序中，多多少少都会用到多线程技术，而我们以往都是使用Thread类来创建一个新的线程：</p>
<pre><code class="language-java">public static void main(String[] args) {
    Thread t = new Thread(() -&gt; System.out.println(&quot;Hello World!&quot;));
    t.start();
}
</code></pre>
<p>利用多线程，我们的程序可以更加合理地使用CPU多核心资源，在同一时间完成更多的工作。但是，如果我们的程序频繁地创建线程，由于线程的创建和销毁也需要占用系统资源，因此这样会降低我们整个程序的性能，那么怎么做，才能更高效地使用多线程呢？</p>
<p>我们其实可以将已创建的线程复用，利用池化技术，就像数据库连接池一样，我们也可以创建很多个线程，然后反复地使用这些线程，而不对它们进行销毁。</p>
<p>虽然听起来这个想法比较新颖，但是实际上线程池早已利用到各个地方，比如我们的Tomcat服务器，要在同一时间接受和处理大量的请求，那么就必须要在短时间内创建大量的线程，结束后又进行销毁，这显然会导致很大的开销，因此这种情况下使用线程池显然是更好的解决方案。</p>
<p>由于线程池可以反复利用已有线程执行多线程操作，所以它一般是有容量限制的，当所有的线程都处于工作状态时，那么新的多线程请求会被阻塞，直到有一个线程空闲出来为止，实际上这里就会用到我们之前讲解的阻塞队列。</p>
<p>所以我们可以暂时得到下面一个样子：</p>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h09oslzmw2j21o20i277f.jpg" alt="image-20220314203232154" loading="lazy"></figure>
<p>当然，JUC提供的线程池肯定没有这么简单，接下来就让我们深入进行了解。</p>
<h3 id="线程池的使用">线程池的使用</h3>
<p>我们可以直接创建一个新的线程池对象，它已经提前帮助我们实现好了线程的调度机制，我们先来看它的构造方法：</p>
<pre><code class="language-java">public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize &lt; 0 ||
        maximumPoolSize &lt;= 0 ||
        maximumPoolSize &lt; corePoolSize ||
        keepAliveTime &lt; 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.acc = System.getSecurityManager() == null ?
            null :
            AccessController.getContext();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
</code></pre>
<p>参数稍微有一点多，这里我们依次进行讲解：</p>
<ul>
<li>corePoolSize：<strong>核心线程池大小</strong>，我们每向线程池提交一个多线程任务时，都会创建一个新的<code>核心线程</code>，无论是否存在其他空闲线程，直到到达核心线程池大小为止，之后会尝试复用线程资源。当然也可以在一开始就全部初始化好，调用<code> prestartAllCoreThreads()</code>即可。</li>
<li>maximumPoolSize：<strong>最大线程池大小</strong>，当目前线程池中所有的线程都处于运行状态，并且等待队列已满，那么就会直接尝试继续创建新的<code>非核心线程</code>运行，但是不能超过最大线程池大小。</li>
<li>keepAliveTime：<strong>线程最大空闲时间</strong>，当一个<code>非核心线程</code>空闲超过一定时间，会自动销毁。</li>
<li>unit：<strong>线程最大空闲时间的时间单位</strong></li>
<li>workQueue：<strong>线程等待队列</strong>，当线程池中核心线程数已满时，就会将任务暂时存到等待队列中，直到有线程资源可用为止，这里可以使用我们上一章学到的阻塞队列。</li>
<li>threadFactory：<strong>线程创建工厂</strong>，我们可以干涉线程池中线程的创建过程，进行自定义。</li>
<li>handler：<strong>拒绝策略</strong>，当等待队列和线程池都没有空间了，真的不能再来新的任务时，来了个新的多线程任务，那么只能拒绝了，这时就会根据当前设定的拒绝策略进行处理。</li>
</ul>
<p>最为重要的就是线程池大小的限定了，这个也是很有学问的，合理地分配大小会使得线程池的执行效率事半功倍：</p>
<ul>
<li>首先我们可以分析一下，线程池执行任务的特性，是CPU 密集型还是 IO 密集型
<ul>
<li>**CPU密集型：**主要是执行计算任务，响应时间很快，CPU一直在运行，这种任务CPU的利用率很高，那么线程数应该是根据 CPU 核心数来决定，CPU 核心数 = 最大同时执行线程数，以 i5-9400F 处理器为例，CPU 核心数为 6，那么最多就能同时执行 6 个线程。</li>
<li>**IO密集型：**主要是进行 IO 操作，因为执行 IO 操作的时间比较较长，比如从硬盘读取数据之类的，CPU就得等着IO操作，很容易出现空闲状态，导致 CPU 的利用率不高，这种情况下可以适当增加线程池的大小，让更多的线程可以一起进行IO操作，一般可以配置为CPU核心数的2倍。</li>
</ul>
</li>
</ul>
<p>这里我们手动创建一个新的线程池看看效果：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ThreadPoolExecutor executor =
            new ThreadPoolExecutor(2, 4,   //2个核心线程，最大线程数为4个
                    3, TimeUnit.SECONDS,        //最大空闲时间为3秒钟
                    new ArrayBlockingQueue&lt;&gt;(2));     //这里使用容量为2的ArrayBlockingQueue队列

    for (int i = 0; i &lt; 6; i++) {   //开始6个任务
        int finalI = i;
        executor.execute(() -&gt; {
            try {
                System.out.println(Thread.currentThread().getName()+&quot; 开始执行！（&quot;+ finalI);
                TimeUnit.SECONDS.sleep(1);
                System.out.println(Thread.currentThread().getName()+&quot; 已结束！（&quot;+finalI);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
    }

    TimeUnit.SECONDS.sleep(1);    //看看当前线程池中的线程数量
    System.out.println(&quot;线程池中线程数量：&quot;+executor.getPoolSize());
    TimeUnit.SECONDS.sleep(5);     //等到超过空闲时间
    System.out.println(&quot;线程池中线程数量：&quot;+executor.getPoolSize());

    executor.shutdownNow();    //使用完线程池记得关闭，不然程序不会结束，它会取消所有等待中的任务以及试图中断正在执行的任务，关闭后，无法再提交任务，一律拒绝
  	//executor.shutdown();     同样可以关闭，但是会执行完等待队列中的任务再关闭
}
</code></pre>
<p>这里我们创建了一个核心容量为2，最大容量为4，等待队列长度为2，空闲时间为3秒的线程池，现在我们向其中执行6个任务，每个任务都会进行1秒钟休眠，那么当线程池中2个核心线程都被占用时，还有4个线程就只能进入到等待队列中了，但是等待队列中只有2个容量，这时紧接着的2个任务，线程池将直接尝试创建线程，由于不大于最大容量，因此可以成功创建。最后所有线程完成之后，在等待5秒后，超过了线程池的最大空闲时间，<code>非核心线程</code>被回收了，所以线程池中只有2个线程存在。</p>
<p>那么要是等待队列设定为没有容量的SynchronousQueue呢，这个时候会发生什么？</p>
<pre><code class="language-java">pool-1-thread-1 开始执行！（0
pool-1-thread-4 开始执行！（3
pool-1-thread-3 开始执行！（2
pool-1-thread-2 开始执行！（1
Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task com.test.Main$$Lambda$1/1283928880@682a0b20 rejected from java.util.concurrent.ThreadPoolExecutor@3d075dc0[Running, pool size = 4, active threads = 4, queued tasks = 0, completed tasks = 0]
	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)
	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)
	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)
	at com.test.Main.main(Main.java:15)
</code></pre>
<p>可以看到，前4个任务都可以正常执行，但是到第五个任务时，直接抛出了异常，这其实就是因为等待队列的容量为0，相当于没有容量，那么这个时候，就只能拒绝任务了，拒绝的操作会根据拒绝策略决定。</p>
<p>线程池的拒绝策略默认有以下几个：</p>
<ul>
<li>AbortPolicy(默认)：像上面一样，直接抛异常。</li>
<li>CallerRunsPolicy：直接让提交任务的线程运行这个任务，比如在主线程向线程池提交了任务，那么就直接由主线程执行。</li>
<li>DiscardOldestPolicy：丢弃队列中最近的一个任务，替换为当前任务。</li>
<li>DiscardPolicy：什么也不用做。</li>
</ul>
<p>这里我们进行一下测试：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ThreadPoolExecutor executor =
            new ThreadPoolExecutor(2, 4,
                    3, TimeUnit.SECONDS,
                    new SynchronousQueue&lt;&gt;(),
                    new ThreadPoolExecutor.CallerRunsPolicy());   //使用另一个构造方法，最后一个参数传入策略，比如这里我们使用了CallerRunsPolicy策略
</code></pre>
<p>CallerRunsPolicy策略是谁提交的谁自己执行，所以：</p>
<pre><code class="language-java">pool-1-thread-1 开始执行！（0
pool-1-thread-2 开始执行！（1
main 开始执行！（4
pool-1-thread-4 开始执行！（3
pool-1-thread-3 开始执行！（2
pool-1-thread-3 已结束！（2
pool-1-thread-2 已结束！（1
pool-1-thread-1 已结束！（0
main 已结束！（4
pool-1-thread-4 已结束！（3
pool-1-thread-1 开始执行！（5
pool-1-thread-1 已结束！（5
线程池中线程数量：4
线程池中线程数量：2
</code></pre>
<p>可以看到，当队列塞不下时，直接在主线程运行任务，运行完之后再继续向下执行。</p>
<p>我们吧策略修改为DiscardOldestPolicy试试看：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ThreadPoolExecutor executor =
            new ThreadPoolExecutor(2, 4,
                    3, TimeUnit.SECONDS,
                    new ArrayBlockingQueue&lt;&gt;(1),    //这里设置为ArrayBlockingQueue，长度为1
                    new ThreadPoolExecutor.DiscardOldestPolicy());   
</code></pre>
<p>它会移除等待队列中的最近的一个任务，所以可以看到有一个任务实际上是被抛弃了的：</p>
<pre><code>pool-1-thread-1 开始执行！（0
pool-1-thread-4 开始执行！（4
pool-1-thread-3 开始执行！（3
pool-1-thread-2 开始执行！（1
pool-1-thread-1 已结束！（0
pool-1-thread-4 已结束！（4
pool-1-thread-1 开始执行！（5
线程池中线程数量：4
pool-1-thread-3 已结束！（3
pool-1-thread-2 已结束！（1
pool-1-thread-1 已结束！（5
线程池中线程数量：2
</code></pre>
<p>比较有意思的是，如果选择没有容量的SynchronousQueue作为等待队列会爆栈：</p>
<pre><code class="language-java">pool-1-thread-1 开始执行！（0
pool-1-thread-3 开始执行！（2
pool-1-thread-2 开始执行！（1
pool-1-thread-4 开始执行！（3
Exception in thread &quot;main&quot; java.lang.StackOverflowError
	at java.util.concurrent.SynchronousQueue.offer(SynchronousQueue.java:912)
	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1371)	
	...
pool-1-thread-1 已结束！（0
pool-1-thread-2 已结束！（1
pool-1-thread-4 已结束！（3
pool-1-thread-3 已结束！（2
</code></pre>
<p>这是为什么呢？我们来看看这个拒绝策略的源码：</p>
<pre><code class="language-java">public static class DiscardOldestPolicy implements RejectedExecutionHandler {
    public DiscardOldestPolicy() { }

    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            e.getQueue().poll();   //会先执行一次出队操作，但是这对于SynchronousQueue来说毫无意义
            e.execute(r);     //这里会再次调用execute方法
        }
    }
}
</code></pre>
<p>可以看到，它会先对等待队列进行出队操作，但是由于SynchronousQueue压根没容量，所有这个操作毫无意义，然后就会递归执行<code>execute</code>方法，而进入之后，又发现没有容量不能插入，于是又重复上面的操作，这样就会无限的递归下去，最后就爆栈了。</p>
<p>当然，除了使用官方提供的4种策略之外，我们还可以使用自定义的策略：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ThreadPoolExecutor executor =
            new ThreadPoolExecutor(2, 4,
                    3, TimeUnit.SECONDS,
                    new SynchronousQueue&lt;&gt;(),
                    (r, executor1) -&gt; {   //比如这里我们也来实现一个就在当前线程执行的策略
                        System.out.println(&quot;哎呀，线程池和等待队列都满了，你自己耗子尾汁吧&quot;);
                        r.run();   //直接运行
                    });
</code></pre>
<p>接着我们来看线程创建工厂，我们可以自己决定如何创建新的线程：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ThreadPoolExecutor executor =
            new ThreadPoolExecutor(2, 4,
                    3, TimeUnit.SECONDS,
                    new SynchronousQueue&lt;&gt;(),
                    new ThreadFactory() {
                        int counter = 0;
                        @Override
                        public Thread newThread(Runnable r) {
                            return new Thread(r, &quot;我的自定义线程-&quot;+counter++);
                        }
                    });

    for (int i = 0; i &lt; 4; i++) {
        executor.execute(() -&gt; System.out.println(Thread.currentThread().getName()+&quot; 开始执行！&quot;));
    }
}
</code></pre>
<p>这里传入的Runnable对象就是我们提交的任务，可以看到需要我们返回一个Thread对象，其实就是线程池创建线程的过程，而如何创建这个对象，以及它的一些属性，就都由我们来决定。</p>
<p>各位有没有想过这样一个情况，如果我们的任务在运行过程中出现异常了，那么是不是会导致线程池中的线程被销毁呢？</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 1,   //最大容量和核心容量锁定为1
            0, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;());
    executor.execute(() -&gt; {
        System.out.println(Thread.currentThread().getName());
        throw new RuntimeException(&quot;我是异常！&quot;);
    });
    TimeUnit.SECONDS.sleep(1);
    executor.execute(() -&gt; {
        System.out.println(Thread.currentThread().getName());
    });
}
</code></pre>
<p>可以看到，出现异常之后，再次提交新的任务，执行的线程是一个新的线程了。</p>
<p>除了我们自己创建线程池之外，官方也提供了很多的线程池定义，我们可以使用<code>Executors</code>工具类来快速创建线程池：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ExecutorService executor = Executors.newFixedThreadPool(2);   //直接创建一个固定容量的线程池
}
</code></pre>
<p>可以看到它的内部实现为：</p>
<pre><code class="language-java">public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre>
<p>这里直接将最大线程和核心线程数量设定为一样的，并且等待时间为0，因为压根不需要，并且采用的是一个无界的LinkedBlockingQueue作为等待队列。</p>
<p>使用newSingleThreadExecutor来创建只有一个线程的线程池：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ExecutorService executor = Executors.newSingleThreadExecutor();
    //创建一个只有一个线程的线程池
}
</code></pre>
<p>原理如下：</p>
<pre><code class="language-java">public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre>
<p>可以看到这里并不是直接创建的一个ThreadPoolExecutor对象，而是套了一层FinalizableDelegatedExecutorService，那么这个又是什么东西呢？</p>
<pre><code class="language-java">static class FinalizableDelegatedExecutorService
    extends DelegatedExecutorService {
    FinalizableDelegatedExecutorService(ExecutorService executor) {
        super(executor);
    }
    protected void finalize() {    //在GC时，会执行finalize方法，此方法中会关闭掉线程池，释放资源
        super.shutdown();
    }
}
</code></pre>
<pre><code class="language-java">static class DelegatedExecutorService extends AbstractExecutorService {
    private final ExecutorService e;    //被委派对象
    DelegatedExecutorService(ExecutorService executor) { e = executor; }   //实际上所以的操作都是让委派对象执行的，有点像代理
    public void execute(Runnable command) { e.execute(command); }
    public void shutdown() { e.shutdown(); }
    public List&lt;Runnable&gt; shutdownNow() { return e.shutdownNow(); }
</code></pre>
<p>所以，下面两种写法的区别在于：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ExecutorService executor1 = Executors.newSingleThreadExecutor();
    ExecutorService executor2 = Executors.newFixedThreadPool(1);
}
</code></pre>
<p>前者实际上是被代理了，我们没办法直接修改前者的相关属性，显然使用前者创建只有一个线程的线程池更加专业和安全（可以防止属性被修改）一些。</p>
<p>最后我们来看<code>newCachedThreadPool</code>方法：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ExecutorService executor = Executors.newCachedThreadPool();
    //它是一个会根据需要无限制创建新线程的线程池
}
</code></pre>
<p>我们来看看它的实现：</p>
<pre><code class="language-java">public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre>
<p>可以看到，核心线程数为0，那么也就是说所有的线程都是<code>非核心线程</code>，也就是说线程空闲时间超过1秒钟，一律销毁。但是它的最大容量是<code>Integer.MAX_VALUE</code>，也就是说，它可以无限制地增长下去，所以这玩意一定要慎用。</p>
<h3 id="执行带返回值的任务">执行带返回值的任务</h3>
<p>一个多线程任务不仅仅可以是void无返回值任务，比如我们现在需要执行一个任务，但是我们需要在任务执行之后得到一个结果，这个时候怎么办呢？</p>
<p>这里我们就可以使用到Future了，它可以返回任务的计算结果，我们可以通过它来获取任务的结果以及任务当前是否完成：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException, ExecutionException {
    ExecutorService executor = Executors.newSingleThreadExecutor();   //直接用Executors创建，方便就完事了
    Future&lt;String&gt; future = executor.submit(() -&gt; &quot;我是字符串!&quot;);     //使用submit提交任务，会返回一个Future对象，注意提交的对象可以是Runable也可以是Callable，这里使用的是Callable能够自定义返回值
    System.out.println(future.get());    //如果任务未完成，get会被阻塞，任务完成返回Callable执行结果返回值
    executor.shutdown();
}
</code></pre>
<p>当然结果也可以一开始就定义好，然后等待Runnable执行完之后再返回：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException, ExecutionException {
    ExecutorService executor = Executors.newSingleThreadExecutor();
    Future&lt;String&gt; future = executor.submit(() -&gt; {
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, &quot;我是字符串！&quot;);
    System.out.println(future.get());
    executor.shutdown();
}
</code></pre>
<p>还可以通过传入FutureTask对象的方式：</p>
<pre><code class="language-java">public static void main(String[] args) throws ExecutionException, InterruptedException {
    ExecutorService service = Executors.newSingleThreadExecutor();
    FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(() -&gt; &quot;我是字符串！&quot;);
    service.submit(task);
    System.out.println(task.get());
    executor.shutdown();
}
</code></pre>
<p>我们可以还通过Future对象获取当前任务的一些状态：</p>
<pre><code class="language-java">public static void main(String[] args) throws ExecutionException, InterruptedException {
    ExecutorService executor = Executors.newSingleThreadExecutor();
    Future&lt;String&gt; future = executor.submit(() -&gt; &quot;都看到这里了，不赏UP主一个一键三连吗？&quot;);
    System.out.println(future.get());
    System.out.println(&quot;任务是否执行完成：&quot;+future.isDone());
    System.out.println(&quot;任务是否被取消：&quot;+future.isCancelled());
    executor.shutdown();
}
</code></pre>
<p>我们来试试看在任务执行途中取消任务：</p>
<pre><code class="language-java">public static void main(String[] args) throws ExecutionException, InterruptedException {
    ExecutorService executor = Executors.newSingleThreadExecutor();
    Future&lt;String&gt; future = executor.submit(() -&gt; {
        TimeUnit.SECONDS.sleep(10);
        return &quot;这次一定！&quot;;
    });
    System.out.println(future.cancel(true));
    System.out.println(future.isCancelled());
    executor.shutdown();
}
</code></pre>
<h3 id="执行定时任务">执行定时任务</h3>
<p>既然线程池怎么强大，那么线程池能不能执行定时任务呢？我们之前如果需要执行一个定时任务，那么肯定会用到Timer和TimerTask，但是它只会创建一个线程处理我们的定时任务，无法实现多线程调度，并且它无法处理异常情况一旦抛出未捕获异常那么会直接终止，显然我们需要一个更加强大的定时器。</p>
<p>JDK5之后，我们可以使用ScheduledThreadPoolExecutor来提交定时任务，它继承自ThreadPoolExecutor，并且所有的构造方法都必须要求最大线程池容量为Integer.MAX_VALUE，并且都是采用的DelayedWorkQueue作为等待队列。</p>
<pre><code class="language-java">public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}

public ScheduledThreadPoolExecutor(int corePoolSize,
                                   ThreadFactory threadFactory) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue(), threadFactory);
}

public ScheduledThreadPoolExecutor(int corePoolSize,
                                   RejectedExecutionHandler handler) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue(), handler);
}

public ScheduledThreadPoolExecutor(int corePoolSize,
                                   ThreadFactory threadFactory,
                                   RejectedExecutionHandler handler) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue(), threadFactory, handler);
}
</code></pre>
<p>我们来测试一下它的方法，这个方法可以提交一个延时任务，只有到达指定时间之后才会开始：</p>
<pre><code class="language-java">public static void main(String[] args) throws ExecutionException, InterruptedException {
  	//直接设定核心线程数为1
    ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1);
    //这里我们计划在3秒后执行
    executor.schedule(() -&gt; System.out.println(&quot;HelloWorld!&quot;), 3, TimeUnit.SECONDS);

    executor.shutdown();
}
</code></pre>
<p>我们也可以像之前一样，传入一个Callable对象，用于接收返回值：</p>
<pre><code class="language-java">public static void main(String[] args) throws ExecutionException, InterruptedException {
    ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(2);
  	//这里使用ScheduledFuture
    ScheduledFuture&lt;String&gt; future = executor.schedule(() -&gt; &quot;????&quot;, 3, TimeUnit.SECONDS);
    System.out.println(&quot;任务剩余等待时间：&quot;+future.getDelay(TimeUnit.MILLISECONDS) / 1000.0 + &quot;s&quot;);
    System.out.println(&quot;任务执行结果：&quot;+future.get());
    executor.shutdown();
}
</code></pre>
<p>可以看到<code>schedule</code>方法返回了一个ScheduledFuture对象，和Future一样，它也支持返回值的获取、包括对任务的取消同时还支持获取剩余等待时间。</p>
<p>那么如果我们希望按照一定的频率不断执行任务呢？</p>
<pre><code class="language-java">public static void main(String[] args) throws ExecutionException, InterruptedException {
    ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(2);
    executor.scheduleAtFixedRate(() -&gt; System.out.println(&quot;Hello World!&quot;),
            3, 1, TimeUnit.SECONDS);
  	//三秒钟延迟开始，之后每隔一秒钟执行一次
}
</code></pre>
<p>Executors也为我们预置了newScheduledThreadPool方法用于创建线程池：</p>
<pre><code class="language-java">public static void main(String[] args) throws ExecutionException, InterruptedException {
    ScheduledExecutorService service = Executors.newScheduledThreadPool(1);
    service.schedule(() -&gt; System.out.println(&quot;Hello World!&quot;), 1, TimeUnit.SECONDS);
}
</code></pre>
<h3 id="线程池实现原理">线程池实现原理</h3>
<p>前面我们了解了线程池的使用，那么接着我们来看看它的详细实现过程，结构稍微有点复杂，坐稳，发车了。</p>
<p>这里需要首先介绍一下ctl变量：</p>
<pre><code class="language-java">//这个变量比较关键，用到了原子AtomicInteger，用于同时保存线程池运行状态和线程数量（使用原子类是为了保证原子性）
//它是通过拆分32个bit位来保存数据的，前3位保存状态，后29位保存工作线程数量（那要是工作线程数量29位装不下不就GG？）
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3;    //29位，线程数量位
private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;   //计算得出最大容量（1左移29位，最大容量为2的29次方-1）

// 所有的运行状态，注意都是只占用前3位，不会占用后29位
// 接收新任务，并等待执行队列中的任务
private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;   //111 | 0000... (后29数量位，下同)
// 不接收新任务，但是依然等待执行队列中的任务
private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;   //000 | 数量位
// 不接收新任务，也不执行队列中的任务，并且还要中断正在执行中的任务
private static final int STOP       =  1 &lt;&lt; COUNT_BITS;   //001 | 数量位
// 所有的任务都已结束，线程数量为0，即将完全关闭
private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;   //010 | 数量位
// 完全关闭
private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;   //011 | 数量位

// 封装和解析ctl变量的一些方法
private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }   //对CAPACITY取反就是后29位全部为0，前三位全部为1，接着与c进行与运算，这样就可以只得到前三位的结果了，所以这里是取运行状态
private static int workerCountOf(int c)  { return c &amp; CAPACITY; }
//同上，这里是为了得到后29位的结果，所以这里是取线程数量
private static int ctlOf(int rs, int wc) { return rs | wc; }   
// 比如上面的RUNNING, 0，进行与运算之后：
// 111 | 0000000000000000000000000
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0adhrjujsj21o605gwes.jpg" alt="image-20220315104707467" loading="lazy"></figure>
<p>我们先从最简单的入手，看看在调用<code>execute</code>方法之后，线程池会做些什么：</p>
<pre><code class="language-java">//这个就是我们指定的阻塞队列
private final BlockingQueue&lt;Runnable&gt; workQueue;

//再次提醒，这里没加锁！！该有什么意识不用我说了吧，所以说ctl才会使用原子类。
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();     //如果任务为null，那执行个寂寞，所以说直接空指针
    int c = ctl.get();      //获取ctl的值，一会要读取信息的
    if (workerCountOf(c) &lt; corePoolSize) {   //判断工作线程数量是否小于核心线程数
        if (addWorker(command, true))    //如果是，那不管三七二十一，直接加新的线程执行，然后返回即可
            return;
        c = ctl.get();    //如果线程添加失败（有可能其他线程也在对线程池进行操作），那就更新一下c的值
    }
    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {   //继续判断，如果当前线程池是运行状态，那就尝试向阻塞队列中添加一个新的等待任务
        int recheck = ctl.get();   //再次获取ctl的值
        if (! isRunning(recheck) &amp;&amp; remove(command))   //这里是再次确认当前线程池是否关闭，如果添加等待任务后线程池关闭了，那就把刚刚加进去任务的又拿出来
            reject(command);   //然后直接拒绝当前任务的提交（会根据我们的拒绝策略决定如何进行拒绝操作）
        else if (workerCountOf(recheck) == 0)   //如果这个时候线程池依然在运行状态，那么就检查一下当前工作线程数是否为0，如果是那就直接添加新线程执行
            addWorker(null, false);   //添加一个新的非核心线程，但是注意没添加任务
      	//其他情况就啥也不用做了
    }
    else if (!addWorker(command, false))   //这种情况要么就是线程池没有运行，要么就是队列满了，按照我们之前的规则，核心线程数已满且队列已满，那么会直接添加新的非核心线程，但是如果已经添加到最大数量，这里肯定是会失败的
        reject(command);   //确实装不下了，只能拒绝
}
</code></pre>
<p>是不是感觉思路还挺清晰的，我们接着来看<code>addWorker</code>是怎么创建和执行任务的，又是一大堆代码：</p>
<pre><code class="language-java">private boolean addWorker(Runnable firstTask, boolean core) {
  	//这里给最外层循环打了个标签，方便一会的跳转操作
    retry:
    for (;;) {    //无限循环，老套路了，注意这里全程没加锁
        int c = ctl.get();     //获取ctl值
        int rs = runStateOf(c);    //解析当前的运行状态

        // Check if queue empty only if necessary.
        if (rs &gt;= SHUTDOWN &amp;&amp;   //判断线程池是否不是处于运行状态
            ! (rs == SHUTDOWN &amp;&amp;   //如果不是运行状态，判断线程是SHUTDOWN状态并、任务不为null、等待队列不为空，只要有其中一者不满足，直接返回false，添加失败
               firstTask == null &amp;&amp;   
               ! workQueue.isEmpty()))
            return false;

        for (;;) {   //内层又一轮无限循环，这个循环是为了将线程计数增加，然后才可以真正地添加一个新的线程
            int wc = workerCountOf(c);    //解析当前的工作线程数量
            if (wc &gt;= CAPACITY ||
                wc &gt;= (core ? corePoolSize : maximumPoolSize))    //判断一下还装得下不，如果装得下，看看是核心线程还是非核心线程，如果是核心线程，不能大于核心线程数的限制，如果是非核心线程，不能大于最大线程数限制
                return false;
            if (compareAndIncrementWorkerCount(c))    //CAS自增线程计数，如果增加成功，任务完成，直接跳出继续
                break retry;    //注意这里要直接跳出最外层循环，所以用到了标签（类似于goto语句）
            c = ctl.get();  // 如果CAS失败，更新一下c的值
            if (runStateOf(c) != rs)    //如果CAS失败的原因是因为线程池状态和一开始的不一样了，那么就重新从外层循环再来一次
                continue retry;    //注意这里要直接从最外层循环继续，所以用到了标签（类似于goto语句）
            // 如果是其他原因导致的CAS失败，那只可能是其他线程同时在自增，所以重新再来一次内层循环
        }
    }

  	//好了，线程计数自增也完了，接着就是添加新的工作线程了
    boolean workerStarted = false;   //工作线程是否已启动
    boolean workerAdded = false;    //工作线程是否已添加
    Worker w = null;     //暂时理解为工作线程，别急，我们之后会解读Worker类
    try {
        w = new Worker(firstTask);     //创建新的工作线程，传入我们提交的任务
        final Thread t = w.thread;    //拿到工作线程中封装的Thread对象
        if (t != null) {      //如果线程不为null，那就可以安排干活了
            final ReentrantLock mainLock = this.mainLock;      //又是ReentrantLock加锁环节，这里开始就是只有一个线程能进入了
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());    //获取当前线程的运行状态

                if (rs &lt; SHUTDOWN ||
                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) {    //只有当前线程池是正在运行状态，或是SHUTDOWN状态且firstTask为空，那么就继续
                    if (t.isAlive()) // 检查一下线程是否正在运行状态
                        throw new IllegalThreadStateException();   //如果是那肯定是不能运行我们的任务的
                    workers.add(w);    //直接将新创建的Work丢进 workers 集合中
                    int s = workers.size();   //看看当前workers的大小
                    if (s &gt; largestPoolSize)   //这里是记录线程池运行以来，历史上的最多线程数
                        largestPoolSize = s;
                    workerAdded = true;   //工作线程已添加
                }
            } finally {
                mainLock.unlock();   //解锁
            }
            if (workerAdded) {
                t.start();   //启动线程
                workerStarted = true;  //工作线程已启动
            }
        }
    } finally {
        if (! workerStarted)    //如果线程在上面的启动过程中失败了
            addWorkerFailed(w);    //将w移出workers并将计数器-1，最后如果线程池是终止状态，会尝试加速终止线程池
    }
    return workerStarted;   //返回是否成功
}
</code></pre>
<p>接着我们来看Worker类是如何实现的，它继承自AbstractQueuedSynchronizer，时隔两章，居然再次遇到AQS，那也就是说，它本身就是一把锁：</p>
<pre><code class="language-java">private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable {
    //用来干活的线程
    final Thread thread;
    //要执行的第一个任务，构造时就确定了的
    Runnable firstTask;
    //干活数量计数器，也就是这个线程完成了多少个任务
    volatile long completedTasks;

    Worker(Runnable firstTask) {
        setState(-1); // 执行Task之前不让中断，将AQS的state设定为-1
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);   //通过预定义或是我们自定义的线程工厂创建线程
    }
  
    public void run() {
        runWorker(this);   //真正开始干活，包括当前活干完了又要等新的活来，就从这里开始，一会详细介绍
    }

   	//0就是没加锁，1就是已加锁
    protected boolean isHeldExclusively() {
        return getState() != 0;
    }

    ...
}
</code></pre>
<p>最后我们来看看一个Worker到底是怎么在进行任务的：</p>
<pre><code class="language-java">final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();   //获取当前线程
    Runnable task = w.firstTask;    //取出要执行的任务
    w.firstTask = null;   //然后把Worker中的任务设定为null
    w.unlock(); // 因为一开始为-1，这里是通过unlock操作将其修改回0，只有state大于等于0才能响应中断
    boolean completedAbruptly = true;
    try {
      	//只要任务不为null，或是任务为空但是可以从等待队列中取出任务不为空，那么就开始执行这个任务，注意这里是无限循环，也就是说如果当前没有任务了，那么会在getTask方法中卡住，因为要从阻塞队列中等着取任务
        while (task != null || (task = getTask()) != null) {
            w.lock();    //对当前Worker加锁，这里其实并不是防其他线程，而是在shutdown时保护此任务的运行
            
          //由于线程池在STOP状态及以上会禁止新线程加入并且中断正在进行的线程
            if ((runStateAtLeast(ctl.get(), STOP) ||   //只要线程池是STOP及以上的状态，那肯定是不能开始新任务的
                 (Thread.interrupted() &amp;&amp;    					 //线程是否已经被打上中断标记并且线程一定是STOP及以上
                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
                !wt.isInterrupted())   //再次确保线程被没有打上中断标记
                wt.interrupt();     //打中断标记
            try {
                beforeExecute(wt, task);  //开始之前的准备工作，这里暂时没有实现
                Throwable thrown = null;
                try {
                    task.run();    //OK，开始执行任务
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);    //执行之后的工作，也没实现
                }
            } finally {
                task = null;    //任务已完成，不需要了
                w.completedTasks++;   //任务完成数++
                w.unlock();    //解锁
            }
        }
        completedAbruptly = false;
    } finally {
      	//如果能走到这一步，那说明上面的循环肯定是跳出了，也就是说这个Worker可以丢弃了
      	//所以这里会直接将 Worker 从 workers 里删除掉
        processWorkerExit(w, completedAbruptly);
    }
}
</code></pre>
<p>那么它是怎么从阻塞队列里面获取任务的呢：</p>
<pre><code class="language-java">private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {    //无限循环获取
        int c = ctl.get();   //获取ctl 
        int rs = runStateOf(c);      //解析线程池运行状态

        // Check if queue empty only if necessary.
        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {      //判断是不是没有必要再执行等待队列中的任务了，也就是处于关闭线程池的状态了
            decrementWorkerCount();     //直接减少一个工作线程数量
            return null;    //返回null，这样上面的runWorker就直接结束了，下同
        }

        int wc = workerCountOf(c);   //如果线程池运行正常，那就获取当前的工作线程数量

        // Are workers subject to culling?
        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;   //如果线程数大于核心线程数或是允许核心线程等待超时，那么就标记为可超时的

      	//超时或maximumPoolSize在运行期间被修改了，并且线程数大于1或等待队列为空，那也是不能获取到任务的
        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))   //如果CAS减少工作线程成功
                return null;    //返回null
            continue;   //否则开下一轮循环
        }

        try {
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :   //如果可超时，那么最多等到超时时间
                workQueue.take();    //如果不可超时，那就一直等着拿任务
            if (r != null)    //如果成功拿到任务，ok，返回
                return r;
            timedOut = true;   //否则就是超时了，下一轮循环将直接返回null
        } catch (InterruptedException retry) {
            timedOut = false;
        }
      	//开下一轮循环吧
    }
}
</code></pre>
<p>虽然我们的源码解读越来越深，但是只要各位的思路不断，依然是可以继续往下看的。到此，有关<code>execute()</code>方法的源码解读，就先到这里。</p>
<p>接着我们来看当线程池关闭时会做什么事情：</p>
<pre><code class="language-java">//普通的shutdown会继续将等待队列中的线程执行完成后再关闭线程池
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
      	//判断是否有权限终止
        checkShutdownAccess();
      	//CAS将线程池运行状态改为SHUTDOWN状态，还算比较温柔，详细过程看下面
        advanceRunState(SHUTDOWN);
       	//让闲着的线程（比如正在等新的任务）中断，但是并不会影响正在运行的线程，详细过程请看下面
        interruptIdleWorkers();
        onShutdown(); //给ScheduledThreadPoolExecutor提供的钩子方法，就是等ScheduledThreadPoolExecutor去实现的，当前类没有实现
    } finally {
        mainLock.unlock();
    }
    tryTerminate();   //最后尝试终止线程池
}
</code></pre>
<pre><code class="language-java">private void advanceRunState(int targetState) {
    for (;;) {
        int c = ctl.get();    //获取ctl
        if (runStateAtLeast(c, targetState) ||    //是否大于等于指定的状态
            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))   //CAS设置ctl的值
            break;   //任意一个条件OK就可以结束了
    }
}
</code></pre>
<pre><code class="language-java">private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers) {
            Thread t = w.thread;    //拿到Worker中的线程
            if (!t.isInterrupted() &amp;&amp; w.tryLock()) {   //先判断一下线程是不是没有被中断然后尝试加锁，但是通过前面的runWorker()源代码我们得知，开始之后是让Worker加了锁的，所以如果线程还在执行任务，那么这里肯定会false
                try {
                    t.interrupt();    //如果走到这里，那么说明线程肯定是一个闲着的线程，直接给中断吧
                } catch (SecurityException ignore) {
                } finally {
                    w.unlock();    //解锁
                }
            }
            if (onlyOne)   //如果只针对一个Worker，那么就结束循环
                break;
        }
    } finally {
        mainLock.unlock();
    }
}
</code></pre>
<p>而<code>shutdownNow()</code>方法也差不多，但是这里会更直接一些：</p>
<pre><code class="language-java">//shutdownNow开始后，不仅不允许新的任务到来，也不会再执行等待队列的线程，而且会终止正在执行的线程
public List&lt;Runnable&gt; shutdownNow() {
    List&lt;Runnable&gt; tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
      	//这里就是直接设定为STOP状态了，不再像shutdown那么温柔
        advanceRunState(STOP);
      	//直接中断所有工作线程，详细过程看下面
        interruptWorkers();
      	//取出仍处于阻塞队列中的线程
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;   //最后返回还没开始的任务
}
</code></pre>
<pre><code class="language-java">private void interruptWorkers() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers)   //遍历所有Worker
            w.interruptIfStarted();   //无差别对待，一律加中断标记
    } finally {
        mainLock.unlock();
    }
}
</code></pre>
<p>最后的最后，我们再来看看<code>tryTerminate()</code>是怎么完完全全终止掉一个线程池的：</p>
<pre><code class="language-java">final void tryTerminate() {
    for (;;) {     //无限循环
        int c = ctl.get();    //上来先获取一下ctl值
      	//只要是正在运行 或是 线程池基本上关闭了 或是 处于SHUTDOWN状态且工作队列不为空，那么这时还不能关闭线程池，返回
        if (isRunning(c) ||
            runStateAtLeast(c, TIDYING) ||
            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))
            return;
      
      	//走到这里，要么处于SHUTDOWN状态且等待队列为空或是STOP状态
        if (workerCountOf(c) != 0) { // 如果工作线程数不是0，这里也会中断空闲状态下的线程
            interruptIdleWorkers(ONLY_ONE);   //这里最多只中断一个空闲线程，然后返回
            return;
        }

      	//走到这里，工作线程也为空了，可以终止线程池了
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {   //先CAS将状态设定为TIDYING表示基本终止，正在做最后的操作
                try {
                    terminated();   //终止，暂时没有实现
                } finally {
                    ctl.set(ctlOf(TERMINATED, 0));   //最后将状态设定为TERMINATED，线程池结束了它年轻的生命
                    termination.signalAll();    //如果有线程调用了awaitTermination方法，会等待当前线程池终止，到这里差不多就可以唤醒了
                }
                return;   //结束
            }
          	//注意如果CAS失败会直接进下一轮循环重新判断
        } finally {
            mainLock.unlock();
        }
        // else retry on failed CAS
    }
}
</code></pre>
<p>OK，有关线程池的实现原理，我们就暂时先介绍到这里，关于更高级的定时任务线程池，这里就不做讲解了。</p>
<hr>
<h2 id="并发工具类">并发工具类</h2>
<h3 id="计数器锁-countdownlatch">计数器锁 CountDownLatch</h3>
<p>多任务同步神器。它允许一个或多个线程，等待其他线程完成工作，比如现在我们有这样的一个需求：</p>
<ul>
<li>有20个计算任务，我们需要先将这些任务的结果全部计算出来，每个任务的执行时间未知</li>
<li>当所有任务结束之后，立即整合统计最终结果</li>
</ul>
<p>要实现这个需求，那么有一个很麻烦的地方，我们不知道任务到底什么时候执行完毕，那么可否将最终统计延迟一定时间进行呢？但是最终统计无论延迟多久进行，要么不能保证所有任务都完成，要么可能所有任务都完成了而这里还在等。</p>
<p>所以说，我们需要一个能够实现子任务同步的工具。</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(20);  //创建一个初始值为10的计数器锁
    for (int i = 0; i &lt; 20; i++) {
        int finalI = i;
        new Thread(() -&gt; {
            try {
                Thread.sleep((long) (2000 * new Random().nextDouble()));
                System.out.println(&quot;子任务&quot;+ finalI +&quot;执行完成！&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            latch.countDown();   //每执行一次计数器都会-1
        }).start();
    }

    //开始等待所有的线程完成，当计数器为0时，恢复运行
    latch.await();   //这个操作可以同时被多个线程执行，一起等待，这里只演示了一个
    System.out.println(&quot;所有子任务都完成！任务完成！！！&quot;);
  
  	//注意这个计数器只能使用一次，用完只能重新创一个，没有重置的说法
}
</code></pre>
<p>我们在调用<code>await()</code>方法之后，实际上就是一个等待计数器衰减为0的过程，而进行自减操作则由各个子线程来完成，当子线程完成工作后，那么就将计数器-1，所有的子线程完成之后，计数器为0，结束等待。</p>
<p>那么它是如何实现的呢？实现 原理非常简单：</p>
<pre><code class="language-java">public class CountDownLatch {
   	//同样是通过内部类实现AbstractQueuedSynchronizer
    private static final class Sync extends AbstractQueuedSynchronizer {
        
        Sync(int count) {   //这里直接使用AQS的state作为计数器（可见state能被玩出各种花样），也就是说一开始就加了count把共享锁，当线程调用countdown时，就解一层锁
            setState(count);
        }

        int getCount() {
            return getState();
        }

      	//采用共享锁机制，因为可以被不同的线程countdown，所以实现的tryAcquireShared和tryReleaseShared
      	//获取这把共享锁其实就是去等待state被其他线程减到0
        protected int tryAcquireShared(int acquires) {
            return (getState() == 0) ? 1 : -1;
        }

        protected boolean tryReleaseShared(int releases) {
            // 每次执行都会将state值-1，直到为0
            for (;;) {
                int c = getState();
                if (c == 0)
                    return false;   //如果已经是0了，那就false
                int nextc = c-1;
                if (compareAndSetState(c, nextc))   //CAS设置state值，失败直接下一轮循环
                    return nextc == 0;    //返回c-1之后，是不是0，如果是那就true，否则false，也就是说只有刚好减到0的时候才会返回true
            }
        }
    }

    private final Sync sync;

    public CountDownLatch(int count) {
        if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);  //count那肯定不能小于0啊
        this.sync = new Sync(count);   //构造Sync对象，将count作为state初始值
    }

   	//通过acquireSharedInterruptibly方法获取共享锁，但是如果state不为0，那么会被持续阻塞，详细原理下面讲
    public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }

    //同上，但是会超时
    public boolean await(long timeout, TimeUnit unit)
        throws InterruptedException {
        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    }

   	//countDown其实就是解锁一次
    public void countDown() {
        sync.releaseShared(1);
    }

    //获取当前的计数，也就是AQS中state的值
    public long getCount() {
        return sync.getCount();
    }

    //这个就不说了
    public String toString() {
        return super.toString() + &quot;[Count = &quot; + sync.getCount() + &quot;]&quot;;
    }
}
</code></pre>
<p>在深入讲解之前，我们先大致了解一下CountDownLatch的基本实现思路：</p>
<ul>
<li>利用共享锁实现</li>
<li>在一开始的时候就是已经上了count层锁的状态，也就是<code>state = count</code></li>
<li><code>await()</code>就是加共享锁，但是必须<code>state</code>为<code>0</code>才能加锁成功，否则按照AQS的机制，会进入等待队列阻塞，加锁成功后结束阻塞</li>
<li><code>countDown()</code>就是解<code>1</code>层锁，也就是靠这个方法一点一点把<code>state</code>的值减到<code>0</code></li>
</ul>
<p>由于我们前面只对独占锁进行了讲解，没有对共享锁进行讲解，这里还是稍微提一下它：</p>
<pre><code class="language-java">public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) &lt; 0)   //上来就调用tryAcquireShared尝试以共享模式获取锁，小于0则失败，上面判断的是state==0返回1，否则-1，也就是说如果计数器不为0，那么这里会判断成功
        doAcquireShared(arg);   //计数器不为0的时候，按照它的机制，那么会阻塞，所以我们来看看doAcquireShared中是怎么进行阻塞的
}
</code></pre>
<pre><code class="language-java">private void doAcquireShared(int arg) {
    final Node node = addWaiter(Node.SHARED);   //向等待队列中添加一个新的共享模式结点
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {    //无限循环
            final Node p = node.predecessor();   //获取当前节点的前驱的结点
            if (p == head) {    //如果p就是头结点，那么说明当前结点就是第一个等待节点
                int r = tryAcquireShared(arg);    //会再次尝试获取共享锁
                if (r &gt;= 0) {      //要是获取成功
                    setHeadAndPropagate(node, r);   //那么就将当前节点设定为新的头结点，并且会继续唤醒后继节点
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;   //和独占模式下一样的操作，这里不多说了
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);   //如果最后都还是没获取到，那么就cancel
    }
}
//其实感觉大体上和独占模式的获取有点像，但是它多了个传播机制，会继续唤醒后续节点
</code></pre>
<pre><code class="language-java">private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // 取出头结点并将当前节点设定为新的头结点
    setHead(node);
    
  	//因为一个线程成功获取到共享锁之后，有可能剩下的等待中的节点也有机会拿到共享锁
    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||
        (h = head) == null || h.waitStatus &lt; 0) {   //如果propagate大于0（表示共享锁还能继续获取）或是h.waitStatus &lt; 0，这是由于在其他线程释放共享锁时，doReleaseShared会将状态设定为PROPAGATE表示可以传播唤醒，后面会讲
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();   //继续唤醒下一个等待节点
    }
}
</code></pre>
<p>我们接着来看，它的countdown过程：</p>
<pre><code class="language-java">public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {   //直接尝试释放锁，如果成功返回true（在CountDownLatch中只有state减到0的那一次，会返回true）
        doReleaseShared();    //这里也会调用doReleaseShared继续唤醒后面的结点
        return true;
    }
    return false;   //其他情况false
  									//不过这里countdown并没有用到这些返回值
}
</code></pre>
<pre><code class="language-java">private void doReleaseShared() {
    for (;;) {   //无限循环
        Node h = head;    //获取头结点
        if (h != null &amp;&amp; h != tail) {    //如果头结点不为空且头结点不是尾结点，那么说明等待队列中存在节点
            int ws = h.waitStatus;    //取一下头结点的等待状态
            if (ws == Node.SIGNAL) {    //如果是SIGNAL，那么就CAS将头结点的状态设定为初始值
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            //失败就开下一轮循环重来
                unparkSuccessor(h);    //和独占模式一样，当锁被释放，都会唤醒头结点的后继节点，doAcquireShared循环继续，如果成功，那么根据setHeadAndPropagate，又会继续调用当前方法，不断地传播下去，让后面的线程一个一个地获取到共享锁，直到不能再继续获取为止
            }
            else if (ws == 0 &amp;&amp;
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))   //如果等待状态是默认值0，那么说明后继节点已经被唤醒，直接将状态设定为PROPAGATE，它代表在后续获取资源的时候，够向后面传播
                continue;                //失败就开下一轮循环重来
        }
        if (h == head)                   // 如果头结点发生了变化，不会break，而是继续循环，否则直接break退出
            break;
    }
}
</code></pre>
<p>可能看完之后还是有点乱，我们再来理一下：</p>
<ul>
<li>共享锁是线程共享的，同一时刻能有多个线程拥有共享锁。</li>
<li>如果一个线程刚获取了共享锁，那么在其之后等待的线程也很有可能能够获取到锁，所以得传播下去继续尝试唤醒后面的结点，不像独占锁，独占的压根不需要考虑这些。</li>
<li>如果一个线程刚释放了锁，不管是独占锁还是共享锁，都需要唤醒后续等待结点的线程。</li>
</ul>
<p>回到CountDownLatch，再结合整个AQS共享锁的实现机制，进行一次完整的推导，看明白还是比较简单的。</p>
<h3 id="循环屏障-cyclicbarrier">循环屏障 CyclicBarrier</h3>
<p>好比一场游戏，我们必须等待房间内人数足够之后才能开始，并且游戏开始之后玩家需要同时进入游戏以保证公平性。</p>
<p>假如现在游戏房间内一共5人，但是游戏开始需要10人，所以我们必须等待剩下5人到来之后才能开始游戏，并且保证游戏开始时所有玩家都是同时进入，那么怎么实现这个功能呢？我们可以使用CyclicBarrier，翻译过来就是循环屏障，那么这个屏障正式为了解决这个问题而出现的。</p>
<pre><code class="language-java">public static void main(String[] args) {
    CyclicBarrier barrier = new CyclicBarrier(10,   //创建一个初始值为10的循环屏障
                () -&gt; System.out.println(&quot;飞机马上就要起飞了，各位特种兵请准备！&quot;));   //人等够之后执行的任务
    for (int i = 0; i &lt; 10; i++) {
        int finalI = i;
        new Thread(() -&gt; {
            try {
                Thread.sleep((long) (2000 * new Random().nextDouble()));
                System.out.println(&quot;玩家 &quot;+ finalI +&quot; 进入房间进行等待... (&quot;+barrier.getNumberWaiting()+&quot;/10)&quot;);

                barrier.await();    //调用await方法进行等待，直到等待的线程足够多为止

                //开始游戏，所有玩家一起进入游戏
                System.out.println(&quot;玩家 &quot;+ finalI +&quot; 进入游戏！&quot;);
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
</code></pre>
<p>可以看到，循环屏障会不断阻挡线程，直到被阻挡的线程足够多时，才能一起冲破屏障，并且在冲破屏障时，我们也可以做一些其他的任务。这和人多力量大的道理是差不多的，当人足够多时方能冲破阻碍，到达美好的明天。当然，屏障由于是可循环的，所以它在被冲破后，会重新开始计数，继续阻挡后续的线程：</p>
<pre><code class="language-java">public static void main(String[] args) {
    CyclicBarrier barrier = new CyclicBarrier(5);  //创建一个初始值为5的循环屏障

    for (int i = 0; i &lt; 10; i++) {   //创建5个线程
        int finalI = i;
        new Thread(() -&gt; {
            try {
                Thread.sleep((long) (2000 * new Random().nextDouble()));
                System.out.println(&quot;玩家 &quot;+ finalI +&quot; 进入房间进行等待... (&quot;+barrier.getNumberWaiting()+&quot;/5)&quot;);

                barrier.await();    //调用await方法进行等待，直到等待线程到达5才会一起继续执行

                //人数到齐之后，可以开始游戏了
                System.out.println(&quot;玩家 &quot;+ finalI +&quot; 进入游戏！&quot;);
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
</code></pre>
<p>可以看到，通过使用循环屏障，我们可以对线程进行一波一波地放行，每一波都放行5个线程，当然除了自动重置之外，我们也可以调用<code>reset()</code>方法来手动进行重置操作，同样会重新计数：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    CyclicBarrier barrier = new CyclicBarrier(5);  //创建一个初始值为10的计数器锁

    for (int i = 0; i &lt; 3; i++)
        new Thread(() -&gt; {
            try {
                barrier.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
        }).start();

    Thread.sleep(500);   //等一下上面的线程开始运行
    System.out.println(&quot;当前屏障前的等待线程数：&quot;+barrier.getNumberWaiting());

    barrier.reset();
    System.out.println(&quot;重置后屏障前的等待线程数：&quot;+barrier.getNumberWaiting());
}
</code></pre>
<p>可以看到，在调用<code>reset()</code>之后，处于等待状态下的线程，全部被中断并且抛出BrokenBarrierException异常，循环屏障等待线程数归零。那么要是处于等待状态下的线程被中断了呢？屏障的线程等待数量会不会自动减少？</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    CyclicBarrier barrier = new CyclicBarrier(10);
    Runnable r = () -&gt; {
        try {
            barrier.await();
        } catch (InterruptedException | BrokenBarrierException e) {
            e.printStackTrace();
        }
    };
    Thread t = new Thread(r);
    t.start();
    t.interrupt();
    new Thread(r).start();
}
</code></pre>
<p>可以看到，当<code>await()</code>状态下的线程被中断，那么屏障会直接变成损坏状态，一旦屏障损坏，那么这一轮就无法再做任何等待操作了。也就是说，本来大家计划一起合力冲破屏障，结果有一个人摆烂中途退出了，那么所有人的努力都前功尽弃，这一轮的屏障也不可能再被冲破了（所以CyclicBarrier告诉我们，不要做那个害群之马，要相信你的团队，不然没有好果汁吃），只能进行<code>reset()</code>重置操作进行重置才能恢复正常。</p>
<p>乍一看，怎么感觉和之前讲的CountDownLatch有点像，好了，这里就得区分一下了，千万别搞混：</p>
<ul>
<li>CountDownLatch：
<ol>
<li>它只能使用一次，是一个一次性的工具</li>
<li>它是一个或多个线程用于等待其他线程完成的同步工具</li>
</ol>
</li>
<li>CyclicBarrier
<ol>
<li>它可以反复使用，允许自动或手动重置计数</li>
<li>它是让一定数量的线程在同一时间开始运行的同步工具</li>
</ol>
</li>
</ul>
<p>我们接着来看循环屏障的实现细节：</p>
<pre><code class="language-java">public class CyclicBarrier {
    //内部类，存放broken标记，表示屏障是否损坏，损坏的屏障是无法正常工作的
    private static class Generation {
        boolean broken = false;
    }

    /** 内部维护一个可重入锁 */
    private final ReentrantLock lock = new ReentrantLock();
    /** 再维护一个Condition */
    private final Condition trip = lock.newCondition();
    /** 这个就是屏障的最大阻挡容量，就是构造方法传入的初始值 */
    private final int parties;
    /* 在屏障破裂时做的事情 */
    private final Runnable barrierCommand;
    /** 当前这一轮的Generation对象，每一轮都有一个新的，用于保存broken标记 */
    private Generation generation = new Generation();

    //默认为最大阻挡容量，每来一个线程-1，和CountDownLatch挺像，当屏障破裂或是被重置时，都会将其重置为最大阻挡容量
    private int count;

  	//构造方法
  	public CyclicBarrier(int parties, Runnable barrierAction) {
        if (parties &lt;= 0) throw new IllegalArgumentException();
        this.parties = parties;
        this.count = parties;
        this.barrierCommand = barrierAction;
    }
  
    public CyclicBarrier(int parties) {
        this(parties, null);
    }
  
    //开启下一轮屏障，一般屏障被冲破之后，就自动重置了，进入到下一轮
    private void nextGeneration() {
        // 唤醒所有等待状态的线程
        trip.signalAll();
        // 重置count的值
        count = parties;
      	//创建新的Generation对象
        generation = new Generation();
    }

    //破坏当前屏障，变为损坏状态，之后就不能再使用了，除非重置
    private void breakBarrier() {
        generation.broken = true;
        count = parties;
        trip.signalAll();
    }
  
  	//开始等待
  	public int await() throws InterruptedException, BrokenBarrierException {
        try {
            return dowait(false, 0L);
        } catch (TimeoutException toe) {
            throw new Error(toe); // 因为这里没有使用定时机制，不可能发生异常，如果发生怕是出了错误
        }
    }
    
  	//可超时的等待
    public int await(long timeout, TimeUnit unit)
        throws InterruptedException,
               BrokenBarrierException,
               TimeoutException {
        return dowait(true, unit.toNanos(timeout));
    }

    //这里就是真正的等待流程了，让我们细细道来
    private int dowait(boolean timed, long nanos)
        throws InterruptedException, BrokenBarrierException,
               TimeoutException {
        final ReentrantLock lock = this.lock;
        lock.lock();   //加锁，注意，因为多个线程都会调用await方法，因此只有一个线程能进，其他都被卡着了
        try {
            final Generation g = generation;   //获取当前这一轮屏障的Generation对象

            if (g.broken)
                throw new BrokenBarrierException();   //如果这一轮屏障已经损坏，那就没办法使用了

            if (Thread.interrupted()) {   //如果当前等待状态的线程被中断，那么会直接破坏掉屏障，并抛出中断异常（破坏屏障的第1种情况）
                breakBarrier();
                throw new InterruptedException();
            }

            int index = --count;     //如果上面都没有出现不正常，那么就走正常流程，首先count自减并赋值给index，index表示当前是等待的第几个线程
            if (index == 0) {  // 如果自减之后就是0了，那么说明来的线程已经足够，可以冲破屏障了
                boolean ranAction = false;
                try {
                    final Runnable command = barrierCommand;
                    if (command != null)
                        command.run();   //执行冲破屏障后的任务，如果这里抛异常了，那么会进finally
                    ranAction = true;
                    nextGeneration();   //一切正常，开启下一轮屏障（方法进入之后会唤醒所有等待的线程，这样所有的线程都可以同时继续运行了）然后返回0，注意最下面finally中会解锁，不然其他线程唤醒了也拿不到锁啊
                    return 0;
                } finally {
                    if (!ranAction)   //如果是上面出现异常进来的，那么也会直接破坏屏障（破坏屏障的第2种情况）
                        breakBarrier();
                }
            }

            // 能走到这里，那么说明当前等待的线程数还不够多，不足以冲破屏障
            for (;;) {   //无限循环，一直等，等到能冲破屏障或是出现异常为止
                try {
                    if (!timed)
                        trip.await();    //如果不是定时的，那么就直接永久等待
                    else if (nanos &gt; 0L)
                        nanos = trip.awaitNanos(nanos);   //否则最多等一段时间
                } catch (InterruptedException ie) {    //等的时候会判断是否被中断（依然是破坏屏障的第1种情况）
                    if (g == generation &amp;&amp; ! g.broken) {
                        breakBarrier();
                        throw ie;
                    } else {
                        Thread.currentThread().interrupt();
                    }
                }

                if (g.broken)
                    throw new BrokenBarrierException();   //如果线程被唤醒之后发现屏障已经被破坏，那么直接抛异常

                if (g != generation)   //成功冲破屏障开启下一轮，那么直接返回当前是第几个等待的线程。
                    return index;

                if (timed &amp;&amp; nanos &lt;= 0L) {   //线程等待超时，也会破坏屏障（破坏屏障的第3种情况）然后抛异常
                    breakBarrier();
                    throw new TimeoutException();
                }
            }
        } finally {
            lock.unlock();    //最后别忘了解锁，不然其他线程拿不到锁
        }
    }

  	//不多说了
    public int getParties() {
        return parties;
    }

  	//判断是否被破坏，也是加锁访问，因为有可能这时有其他线程正在执行dowait
    public boolean isBroken() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return generation.broken;
        } finally {
            lock.unlock();
        }
    }

  	//重置操作，也要加锁
    public void reset() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            breakBarrier();   // 先破坏这一轮的线程，注意这个方法会先破坏再唤醒所有等待的线程，那么所有等待的线程会直接抛BrokenBarrierException异常（详情请看上方dowait倒数第13行）
            nextGeneration(); // 开启下一轮
        } finally {
            lock.unlock();
        }
    }
	
  	//获取等待线程数量，也要加锁
    public int getNumberWaiting() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return parties - count;   //最大容量 - 当前剩余容量 = 正在等待线程数
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<p>看完了CyclicBarrier的源码之后，是不是感觉比CountDownLatch更简单一些？</p>
<h3 id="信号量-semaphore">信号量 Semaphore</h3>
<p>还记得我们在《操作系统》中学习的信号量机制吗？它在解决进程之间的同步问题中起着非常大的作用。</p>
<blockquote>
<p>信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。</p>
</blockquote>
<p>通过使用信号量，我们可以决定某个资源同一时间能够被访问的最大线程数，它相当于对某个资源的访问进行了流量控制。简单来说，它就是一个可以被N个线程占用的排它锁（因此也支持公平和非公平模式），我们可以在最开始设定Semaphore的许可证数量，每个线程都可以获得1个或n个许可证，当许可证耗尽或不足以供其他线程获取时，其他线程将被阻塞。</p>
<pre><code class="language-java">public static void main(String[] args) throws ExecutionException, InterruptedException {
    //每一个Semaphore都会在一开始获得指定的许可证数数量，也就是许可证配额
    Semaphore semaphore = new Semaphore(2);   //许可证配额设定为2

    for (int i = 0; i &lt; 3; i++) {
        new Thread(() -&gt; {
            try {
                semaphore.acquire();   //申请一个许可证
                System.out.println(&quot;许可证申请成功！&quot;);
                semaphore.release();   //归还一个许可证
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) throws ExecutionException, InterruptedException {
    //每一个Semaphore都会在一开始获得指定的许可证数数量，也就是许可证配额
    Semaphore semaphore = new Semaphore(3);   //许可证配额设定为3

    for (int i = 0; i &lt; 2; i++)
        new Thread(() -&gt; {
            try {
                semaphore.acquire(2);    //一次性申请两个许可证
                System.out.println(&quot;许可证申请成功！&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    
}
</code></pre>
<p>我们也可以通过Semaphore获取一些常规信息：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Semaphore semaphore = new Semaphore(3);   //只配置一个许可证，5个线程进行争抢，不内卷还想要许可证？
    for (int i = 0; i &lt; 5; i++)
        new Thread(semaphore::acquireUninterruptibly).start();   //可以以不响应中断（主要是能简写一行，方便）
    Thread.sleep(500);
    System.out.println(&quot;剩余许可证数量：&quot;+semaphore.availablePermits());
    System.out.println(&quot;是否存在线程等待许可证：&quot;+(semaphore.hasQueuedThreads() ? &quot;是&quot; : &quot;否&quot;));
    System.out.println(&quot;等待许可证线程数量：&quot;+semaphore.getQueueLength());
}
</code></pre>
<p>我们可以手动回收掉所有的许可证：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Semaphore semaphore = new Semaphore(3);
    new Thread(semaphore::acquireUninterruptibly).start();
    Thread.sleep(500);
    System.out.println(&quot;收回剩余许可数量：&quot;+semaphore.drainPermits());   //直接回收掉剩余的许可证
}
</code></pre>
<p>这里我们模拟一下，比如现在有10个线程同时进行任务，任务要求是执行某个方法，但是这个方法最多同时只能由5个线程执行，这里我们使用信号量就非常合适。</p>
<h3 id="数据交换-exchanger">数据交换 Exchanger</h3>
<p>线程之间的数据传递也可以这么简单。</p>
<p>使用Exchanger，它能够实现线程之间的数据交换：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;();
    new Thread(() -&gt; {
        try {
            System.out.println(&quot;收到主线程传递的交换数据：&quot;+exchanger.exchange(&quot;AAAA&quot;));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }).start();
    System.out.println(&quot;收到子线程传递的交换数据：&quot;+exchanger.exchange(&quot;BBBB&quot;));
}
</code></pre>
<p>在调用<code>exchange</code>方法后，当前线程会等待其他线程调用同一个exchanger对象的<code>exchange</code>方法，当另一个线程也调用之后，方法会返回对方线程传入的参数。</p>
<p>可见功能还是比较简单的。</p>
<h3 id="forkjoin框架">Fork/Join框架</h3>
<p>在JDK7时，出现了一个新的框架用于并行执行任务，它的目的是为了把大型任务拆分为多个小任务，最后汇总多个小任务的结果，得到整大任务的结果，并且这些小任务都是同时在进行，大大提高运算效率。Fork就是拆分，Join就是合并。</p>
<p>我们来演示一下实际的情况，比如一个算式：18x7+36x8+9x77+8x53，可以拆分为四个小任务：18x7、36x8、9x77、8x53，最后我们只需要将这四个任务的结果加起来，就是我们原本算式的结果了，有点归并排序的味道。</p>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0c43lq5kfj223e0lg42t.jpg" alt="image-20220316225312840" loading="lazy"></figure>
<p>它不仅仅只是拆分任务并使用多线程，而且还可以利用工作窃取算法，提高线程的利用率。</p>
<blockquote>
<p>**工作窃取算法：**是指某个线程从其他队列里窃取任务来执行。一个大任务分割为若干个互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务待处理。干完活的线程与其等着，不如帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0c4kgoen9j21s00gmwis.jpg" alt="image-20220316230928072" loading="lazy"></figure>
<p>现在我们来看看如何使用它，这里以计算1-1000的和为例，我们可以将其拆分为8个小段的数相加，比如1-125、126-250... ，最后再汇总即可，它也是依靠线程池来实现的：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ForkJoinPool pool = new ForkJoinPool();
        System.out.println(pool.submit(new SubTask(1, 1000)).get());
    }


  	//继承RecursiveTask，这样才可以作为一个任务，泛型就是计算结果类型
    private static class SubTask extends RecursiveTask&lt;Integer&gt; {
        private final int start;   //比如我们要计算一个范围内所有数的和，那么就需要限定一下范围，这里用了两个int存放
        private final int end;

        public SubTask(int start, int end) {
            this.start = start;
            this.end = end;
        }

        @Override
        protected Integer compute() {
            if(end - start &gt; 125) {    //每个任务最多计算125个数的和，如果大于继续拆分，小于就可以开始算了
                SubTask subTask1 = new SubTask(start, (end + start) / 2);
                subTask1.fork();    //会继续划分子任务执行
                SubTask subTask2 = new SubTask((end + start) / 2 + 1, end);
                subTask2.fork();   //会继续划分子任务执行
                return subTask1.join() + subTask2.join();   //越玩越有递归那味了
            } else {
                System.out.println(Thread.currentThread().getName()+&quot; 开始计算 &quot;+start+&quot;-&quot;+end+&quot; 的值!&quot;);
                int res = 0;
                for (int i = start; i &lt;= end; i++) {
                    res += i;
                }
                return res;   //返回的结果会作为join的结果
            }
        }
    }
}
</code></pre>
<pre><code>ForkJoinPool-1-worker-2 开始计算 1-125 的值!
ForkJoinPool-1-worker-2 开始计算 126-250 的值!
ForkJoinPool-1-worker-0 开始计算 376-500 的值!
ForkJoinPool-1-worker-6 开始计算 751-875 的值!
ForkJoinPool-1-worker-3 开始计算 626-750 的值!
ForkJoinPool-1-worker-5 开始计算 501-625 的值!
ForkJoinPool-1-worker-4 开始计算 251-375 的值!
ForkJoinPool-1-worker-7 开始计算 876-1000 的值!
500500
</code></pre>
<p>可以看到，结果非常正确，但是整个计算任务实际上是拆分为了8个子任务同时完成的，结合多线程，原本的单线程任务，在多线程的加持下速度成倍提升。</p>
<p>包括Arrays工具类提供的并行排序也是利用了ForkJoinPool来实现：</p>
<pre><code class="language-java">public static void parallelSort(byte[] a) {
    int n = a.length, p, g;
    if (n &lt;= MIN_ARRAY_SORT_GRAN ||
        (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
        DualPivotQuicksort.sort(a, 0, n - 1);
    else
        new ArraysParallelSortHelpers.FJByte.Sorter
            (null, a, new byte[n], 0, n, 0,
             ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
             MIN_ARRAY_SORT_GRAN : g).invoke();
}
</code></pre>
<p>并行排序的性能在多核心CPU环境下，肯定是优于普通排序的，并且排序规模越大优势越显著。</p>
<p>至此，并发编程篇完结。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JUC笔记（二）]]></title>
        <id>https://muouren7.github.io/post/JUC笔记（二）/</id>
        <link href="https://muouren7.github.io/post/JUC笔记（二）/">
        </link>
        <updated>2022-10-14T08:06:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="多线程编程核心">多线程编程核心</h1>
<p>在前面，我们了解了多线程的底层运作机制，我们终于知道，原来多线程环境下存在着如此之多的问题。在JDK5之前，我们只能选择<code>synchronized</code>关键字来实现锁，而JDK5之后，由于<code>volatile</code>关键字得到了升级（具体功能就是上一章所描述的），所以并发框架包便出现了，相比传统的<code>synchronized</code>关键字，我们对于锁的实现，有了更多的选择。</p>
<blockquote>
<p>Doug Lea — JUC并发包的作者</p>
<p>如果IT的历史，是以人为主体串接起来的话，那么肯定少不了Doug Lea。这个鼻梁挂着眼镜，留着德王威廉二世的胡子，脸上永远挂着谦逊腼腆笑容，服务于纽约州立大学Oswego分校计算机科学系的老大爷。</p>
<p>说他是这个世界上对Java影响力最大的一个人，一点也不为过。因为两次Java历史上的大变革，他都间接或直接的扮演了举足轻重的角色。2004年所推出的Tiger。Tiger广纳了15项JSRs(Java Specification Requests)的语法及标准，其中一项便是JSR-166。JSR-166是来自于Doug编写的util.concurrent包。</p>
</blockquote>
<p>那么，从这章开始，就让我们来感受一下，JUC为我们带来了什么。</p>
<hr>
<h2 id="锁框架">锁框架</h2>
<p>在JDK 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，Lock接口提供了与synchronized关键字类似的同步功能，但需要在使用时手动获取锁和释放锁。</p>
<h3 id="lock和condition接口">Lock和Condition接口</h3>
<p>使用并发包中的锁和我们传统的<code>synchronized</code>锁不太一样，这里的锁我们可以认为是一把真正意义上的锁，每个锁都是一个对应的锁对象，我只需要向锁对象获取锁或是释放锁即可。我们首先来看看，此接口中定义了什么：</p>
<pre><code class="language-java">public interface Lock {
  	//获取锁，拿不到锁会阻塞，等待其他线程释放锁，获取到锁后返回
    void lock();
  	//同上，但是等待过程中会响应中断
    void lockInterruptibly() throws InterruptedException;
  	//尝试获取锁，但是不会阻塞，如果能获取到会返回true，不能返回false
    boolean tryLock();
  	//尝试获取锁，但是可以限定超时时间，如果超出时间还没拿到锁返回false，否则返回true，可以响应中断
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
  	//释放锁
    void unlock();
  	//暂时可以理解为替代传统的Object的wait()、notify()等操作的工具
    Condition newCondition();
}
</code></pre>
<p>这里我们可以演示一下，如何使用Lock类来进行加锁和释放锁操作：</p>
<pre><code class="language-java">public class Main {
    private static int i = 0;
    public static void main(String[] args) throws InterruptedException {
        Lock testLock = new ReentrantLock();   //可重入锁ReentrantLock类是Lock类的一个实现，我们后面会进行介绍
        Runnable action = () -&gt; {
            for (int j = 0; j &lt; 100000; j++) {   //还是以自增操作为例
                testLock.lock();    //加锁，加锁成功后其他线程如果也要获取锁，会阻塞，等待当前线程释放
                i++;
                testLock.unlock();  //解锁，释放锁之后其他线程就可以获取这把锁了（注意在这之前一定得加锁，不然报错）
            }
        };
        new Thread(action).start();
        new Thread(action).start();
        Thread.sleep(1000);   //等上面两个线程跑完
        System.out.println(i);
    }
}
</code></pre>
<p>可以看到，和我们之前使用<code>synchronized</code>相比，我们这里是真正在操作一个&quot;锁&quot;对象，当我们需要加锁时，只需要调用<code>lock()</code>方法，而需要释放锁时，只需要调用<code>unlock()</code>方法。程序运行的最终结果和使用<code>synchronized</code>锁是一样的。</p>
<p>那么，我们如何像传统的加锁那样，调用对象的<code>wait()</code>和<code>notify()</code>方法呢，并发包提供了Condition接口：</p>
<pre><code class="language-java">public interface Condition {
  	//与调用锁对象的wait方法一样，会进入到等待状态，但是这里需要调用Condition的signal或signalAll方法进行唤醒（感觉就是和普通对象的wait和notify是对应的）同时，等待状态下是可以响应中断的
 		void await() throws InterruptedException;
  	//同上，但不响应中断（看名字都能猜到）
  	void awaitUninterruptibly();
  	//等待指定时间，如果在指定时间（纳秒）内被唤醒，会返回剩余时间，如果超时，会返回0或负数，可以响应中断
  	long awaitNanos(long nanosTimeout) throws InterruptedException;
  	//等待指定时间（可以指定时间单位），如果等待时间内被唤醒，返回true，否则返回false，可以响应中断
  	boolean await(long time, TimeUnit unit) throws InterruptedException;
  	//可以指定一个明确的时间点，如果在时间点之前被唤醒，返回true，否则返回false，可以响应中断
  	boolean awaitUntil(Date deadline) throws InterruptedException;
  	//唤醒一个处于等待状态的线程，注意还得获得锁才能接着运行
  	void signal();
  	//同上，但是是唤醒所有等待线程
  	void signalAll();
}
</code></pre>
<p>这里我们通过一个简单的例子来演示一下：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Lock testLock = new ReentrantLock();
    Condition condition = testLock.newCondition();
    new Thread(() -&gt; {
        testLock.lock();   //和synchronized一样，必须持有锁的情况下才能使用await
        System.out.println(&quot;线程1进入等待状态！&quot;);
        try {
            condition.await();   //进入等待状态
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;线程1等待结束！&quot;);
        testLock.unlock();
    }).start();
    Thread.sleep(100); //防止线程2先跑
    new Thread(() -&gt; {
        testLock.lock();
        System.out.println(&quot;线程2开始唤醒其他等待线程&quot;);
        condition.signal();   //唤醒线程1，但是此时线程1还必须要拿到锁才能继续运行
        System.out.println(&quot;线程2结束&quot;);
        testLock.unlock();   //这里释放锁之后，线程1就可以拿到锁继续运行了
    }).start();
}
</code></pre>
<p>可以发现，Condition对象使用方法和传统的对象使用差别不是很大。</p>
<p>**思考：**下面这种情况跟上面有什么不同？</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Lock testLock = new ReentrantLock();
    new Thread(() -&gt; {
        testLock.lock();
        System.out.println(&quot;线程1进入等待状态！&quot;);
        try {
            testLock.newCondition().await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;线程1等待结束！&quot;);
        testLock.unlock();
    }).start();
    Thread.sleep(100);
    new Thread(() -&gt; {
        testLock.lock();
        System.out.println(&quot;线程2开始唤醒其他等待线程&quot;);
        testLock.newCondition().signal();
        System.out.println(&quot;线程2结束&quot;);
        testLock.unlock();
    }).start();
}
</code></pre>
<p>通过分析可以得到，在调用<code>newCondition()</code>后，会生成一个新的Condition对象，并且同一把锁内是可以存在多个Condition对象的（实际上原始的锁机制等待队列只能有一个，而这里可以创建很多个Condition来实现多等待队列），而上面的例子中，实际上使用的是不同的Condition对象，只有对同一个Condition对象进行等待和唤醒操作才会有效，而不同的Condition对象是分开计算的。</p>
<p>最后我们再来讲解一下时间单位，这是一个枚举类，也是位于<code>java.util.concurrent</code>包下：</p>
<pre><code class="language-java">public enum TimeUnit {
    /**
     * Time unit representing one thousandth of a microsecond
     */
    NANOSECONDS {
        public long toNanos(long d)   { return d; }
        public long toMicros(long d)  { return d/(C1/C0); }
        public long toMillis(long d)  { return d/(C2/C0); }
        public long toSeconds(long d) { return d/(C3/C0); }
        public long toMinutes(long d) { return d/(C4/C0); }
        public long toHours(long d)   { return d/(C5/C0); }
        public long toDays(long d)    { return d/(C6/C0); }
        public long convert(long d, TimeUnit u) { return u.toNanos(d); }
        int excessNanos(long d, long m) { return (int)(d - (m*C2)); }
    },
  	//....
</code></pre>
<p>可以看到时间单位有很多的，比如<code>DAY</code>、<code>SECONDS</code>、<code>MINUTES</code>等，我们可以直接将其作为时间单位，比如我们要让一个线程等待3秒钟，可以像下面这样编写：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Lock testLock = new ReentrantLock();
    new Thread(() -&gt; {
        testLock.lock();
        try {
            System.out.println(&quot;等待是否未超时：&quot;+testLock.newCondition().await(1, TimeUnit.SECONDS));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        testLock.unlock();
    }).start();
}
</code></pre>
<p>当然，Lock类的tryLock方法也是支持使用时间单位的，各位可以自行进行测试。TimeUnit除了可以作为时间单位表示以外，还可以在不同单位之间相互转换：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    System.out.println(&quot;60秒 = &quot;+TimeUnit.SECONDS.toMinutes(60) +&quot;分钟&quot;);
    System.out.println(&quot;365天 = &quot;+TimeUnit.DAYS.toSeconds(365) +&quot; 秒&quot;);
}
</code></pre>
<p>也可以更加便捷地使用对象的<code>wait()</code>方法：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    synchronized (Main.class) {
        System.out.println(&quot;开始等待&quot;);
        TimeUnit.SECONDS.timedWait(Main.class, 3);   //直接等待3秒
        System.out.println(&quot;等待结束&quot;);
    }
}
</code></pre>
<p>我们也可以直接使用它来进行休眠操作：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    TimeUnit.SECONDS.sleep(1);  //休眠1秒钟
}
</code></pre>
<h3 id="可重入锁">可重入锁</h3>
<p>前面，我们讲解了锁框架的两个核心接口，那么我们接着来看看锁接口的具体实现类，我们前面用到了ReentrantLock，它其实是锁的一种，叫做可重入锁，那么这个可重入代表的是什么意思呢？简单来说，就是同一个线程，可以反复进行加锁操作：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ReentrantLock lock = new ReentrantLock();
    lock.lock();
    lock.lock();   //连续加锁2次
    new Thread(() -&gt; {
        System.out.println(&quot;线程2想要获取锁&quot;);
        lock.lock();
        System.out.println(&quot;线程2成功获取到锁&quot;);
    }).start();
    lock.unlock();
    System.out.println(&quot;线程1释放了一次锁&quot;);
    TimeUnit.SECONDS.sleep(1);
    lock.unlock();
    System.out.println(&quot;线程1再次释放了一次锁&quot;);  //释放两次后其他线程才能加锁
}
</code></pre>
<p>可以看到，主线程连续进行了两次加锁操作（此操作是不会被阻塞的），在当前线程持有锁的情况下继续加锁不会被阻塞，并且，加锁几次，就必须要解锁几次，否则此线程依旧持有锁。我们可以使用<code>getHoldCount()</code>方法查看当前线程的加锁次数：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ReentrantLock lock = new ReentrantLock();
    lock.lock();
    lock.lock();
    System.out.println(&quot;当前加锁次数：&quot;+lock.getHoldCount()+&quot;，是否被锁：&quot;+lock.isLocked());
    TimeUnit.SECONDS.sleep(1);
    lock.unlock();
    System.out.println(&quot;当前加锁次数：&quot;+lock.getHoldCount()+&quot;，是否被锁：&quot;+lock.isLocked());
    TimeUnit.SECONDS.sleep(1);
    lock.unlock();
    System.out.println(&quot;当前加锁次数：&quot;+lock.getHoldCount()+&quot;，是否被锁：&quot;+lock.isLocked());
}
</code></pre>
<p>可以看到，当锁不再被任何线程持有时，值为<code>0</code>，并且通过<code>isLocked()</code>方法查询结果为<code>false</code>。</p>
<p>实际上，如果存在线程持有当前的锁，那么其他线程在获取锁时，是会暂时进入到等待队列的，我们可以通过<code>getQueueLength()</code>方法获取等待中线程数量的预估值：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ReentrantLock lock = new ReentrantLock();
    lock.lock();
    Thread t1 = new Thread(lock::lock), t2 = new Thread(lock::lock);;
    t1.start();
    t2.start();
    TimeUnit.SECONDS.sleep(1);
    System.out.println(&quot;当前等待锁释放的线程数：&quot;+lock.getQueueLength());
    System.out.println(&quot;线程1是否在等待队列中：&quot;+lock.hasQueuedThread(t1));
    System.out.println(&quot;线程2是否在等待队列中：&quot;+lock.hasQueuedThread(t2));
    System.out.println(&quot;当前线程是否在等待队列中：&quot;+lock.hasQueuedThread(Thread.currentThread()));
}
</code></pre>
<p>我们可以通过<code>hasQueuedThread()</code>方法来判断某个线程是否正在等待获取锁状态。</p>
<p>同样的，Condition也可以进行判断：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ReentrantLock lock = new ReentrantLock();
    Condition condition = lock.newCondition();
    new Thread(() -&gt; {
       lock.lock();
        try {
            condition.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        lock.unlock();
    }).start();
    TimeUnit.SECONDS.sleep(1);
    lock.lock();
    System.out.println(&quot;当前Condition的等待线程数：&quot;+lock.getWaitQueueLength(condition));
    condition.signal();
    System.out.println(&quot;当前Condition的等待线程数：&quot;+lock.getWaitQueueLength(condition));
    lock.unlock();
}
</code></pre>
<p>通过使用<code>getWaitQueueLength()</code>方法能够查看同一个Condition目前有多少线程处于等待状态。</p>
<h4 id="公平锁与非公平锁">公平锁与非公平锁</h4>
<p>前面我们了解了如果线程之间争抢同一把锁，会暂时进入到等待队列中，那么多个线程获得锁的顺序是不是一定是根据线程调用<code>lock()</code>方法时间来定的呢，我们可以看到，<code>ReentrantLock</code>的构造方法中，是这样写的：</p>
<pre><code class="language-java">public ReentrantLock() {
    sync = new NonfairSync();   //看名字貌似是非公平的
}
</code></pre>
<p>其实锁分为公平锁和非公平锁，默认我们创建出来的ReentrantLock是采用的非公平锁作为底层锁机制。那么什么是公平锁什么又是非公平锁呢？</p>
<ul>
<li>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</li>
<li>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</li>
</ul>
<p>简单来说，公平锁不让插队，都老老实实排着；非公平锁让插队，但是排队的人让不让你插队就是另一回事了。</p>
<p>我们可以来测试一下公平锁和非公平锁的表现情况：</p>
<pre><code class="language-java">public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
</code></pre>
<p>这里我们选择使用第二个构造方法，可以选择是否为公平锁实现：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ReentrantLock lock = new ReentrantLock(false);

    Runnable action = () -&gt; {
        System.out.println(&quot;线程 &quot;+Thread.currentThread().getName()+&quot; 开始获取锁...&quot;);
        lock.lock();
        System.out.println(&quot;线程 &quot;+Thread.currentThread().getName()+&quot; 成功获取锁！&quot;);
        lock.unlock();
    };
    for (int i = 0; i &lt; 10; i++) {   //建立10个线程
        new Thread(action, &quot;T&quot;+i).start();
    }
}
</code></pre>
<p>这里我们只需要对比<code>将在1秒后开始获取锁...</code>和<code>成功获取锁！</code>的顺序是否一致即可，如果是一致，那说明所有的线程都是按顺序排队获取的锁，如果不是，那说明肯定是有线程插队了。</p>
<p>运行结果可以发现，在公平模式下，确实是按照顺序进行的，而在非公平模式下，一般会出现这种情况：线程刚开始获取锁马上就能抢到，并且此时之前早就开始的线程还在等待状态，很明显的插队行为。</p>
<p>那么，接着下一个问题，公平锁在任何情况下都一定是公平的吗？有关这个问题，我们会留到队列同步器中再进行讨论。</p>
<hr>
<h3 id="读写锁">读写锁</h3>
<p>除了可重入锁之外，还有一种类型的锁叫做读写锁，当然它并不是专门用作读写操作的锁，它和可重入锁不同的地方在于，可重入锁是一种排他锁，当一个线程得到锁之后，另一个线程必须等待其释放锁，否则一律不允许获取到锁。而读写锁在同一时间，是可以让多个线程获取到锁的，它其实就是针对于读写场景而出现的。</p>
<p>读写锁维护了一个读锁和一个写锁，这两个锁的机制是不同的。</p>
<ul>
<li>读锁：在没有任何线程占用写锁的情况下，同一时间可以有多个线程加读锁。</li>
<li>写锁：在没有任何线程占用读锁的情况下，同一时间只能有一个线程加写锁。</li>
</ul>
<p>读写锁也有一个专门的接口：</p>
<pre><code class="language-java">public interface ReadWriteLock {
    //获取读锁
    Lock readLock();

  	//获取写锁
    Lock writeLock();
}
</code></pre>
<p>此接口有一个实现类ReentrantReadWriteLock（实现的是ReadWriteLock接口，不是Lock接口，它本身并不是锁），注意我们操作ReentrantReadWriteLock时，不能直接上锁，而是需要获取读锁或是写锁，再进行锁操作：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    lock.readLock().lock();
    new Thread(lock.readLock()::lock).start();
}
</code></pre>
<p>这里我们对读锁加锁，可以看到可以多个线程同时对读锁加锁。</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    lock.readLock().lock();
    new Thread(lock.writeLock()::lock).start();
}
</code></pre>
<p>有读锁状态下无法加写锁，反之亦然：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    lock.writeLock().lock();
    new Thread(lock.readLock()::lock).start();
}
</code></pre>
<p>并且，ReentrantReadWriteLock不仅具有读写锁的功能，还保留了可重入锁和公平/非公平机制，比如同一个线程可以重复为写锁加锁，并且必须全部解锁才真正释放锁：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    lock.writeLock().lock();
    lock.writeLock().lock();
    new Thread(() -&gt; {
        lock.writeLock().lock();
        System.out.println(&quot;成功获取到写锁！&quot;);
    }).start();
    System.out.println(&quot;释放第一层锁！&quot;);
    lock.writeLock().unlock();
    TimeUnit.SECONDS.sleep(1);
    System.out.println(&quot;释放第二层锁！&quot;);
    lock.writeLock().unlock();
}
</code></pre>
<p>通过之前的例子来验证公平和非公平：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ReentrantReadWriteLock lock = new ReentrantReadWriteLock(true);

    Runnable action = () -&gt; {
        System.out.println(&quot;线程 &quot;+Thread.currentThread().getName()+&quot; 将在1秒后开始获取锁...&quot;);
        lock.writeLock().lock();
        System.out.println(&quot;线程 &quot;+Thread.currentThread().getName()+&quot; 成功获取锁！&quot;);
        lock.writeLock().unlock();
    };
    for (int i = 0; i &lt; 10; i++) {   //建立10个线程
        new Thread(action, &quot;T&quot;+i).start();
    }
}
</code></pre>
<p>可以看到，结果是一致的。</p>
<h4 id="锁降级和锁升级">锁降级和锁升级</h4>
<p>锁降级指的是写锁降级为读锁。当一个线程持有写锁的情况下，虽然其他线程不能加读锁，但是线程自己是可以加读锁的：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    lock.writeLock().lock();
    lock.readLock().lock();
    System.out.println(&quot;成功加读锁！&quot;);
}
</code></pre>
<p>那么，如果我们在同时加了写锁和读锁的情况下，释放写锁，是否其他的线程就可以一起加读锁了呢？</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    lock.writeLock().lock();
    lock.readLock().lock();
    new Thread(() -&gt; {
        System.out.println(&quot;开始加读锁！&quot;);
        lock.readLock().lock();
        System.out.println(&quot;读锁添加成功！&quot;);
    }).start();
    TimeUnit.SECONDS.sleep(1);
    lock.writeLock().unlock();    //如果释放写锁，会怎么样？
}
</code></pre>
<p>可以看到，一旦写锁被释放，那么主线程就只剩下读锁了，因为读锁可以被多个线程共享，所以这时第二个线程也添加了读锁。而这种操作，就被称之为&quot;锁降级&quot;（注意不是先释放写锁再加读锁，而是持有写锁的情况下申请读锁再释放写锁）</p>
<p>注意在仅持有读锁的情况下去申请写锁，属于&quot;锁升级&quot;，ReentrantReadWriteLock是不支持的：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    lock.readLock().lock();
    lock.writeLock().lock();
    System.out.println(&quot;所升级成功！&quot;);
}
</code></pre>
<p>可以看到线程直接卡在加写锁的那一句了。</p>
<h3 id="队列同步器aqs">队列同步器AQS</h3>
<p>**注意：**难度巨大，如果对锁的使用不是很熟悉建议之后再来看！</p>
<p>前面我们了解了可重入锁和读写锁，那么它们的底层实现原理到底是什么样的呢？又是大家看到就想跳过的套娃解析环节。</p>
<p>比如我们执行了ReentrantLock的<code>lock()</code>方法，那它的内部是怎么在执行的呢？</p>
<pre><code class="language-java">public void lock() {
    sync.lock();
}
</code></pre>
<p>可以看到，它的内部实际上啥都没做，而是交给了Sync对象在进行，并且，不只是这个方法，其他的很多方法都是依靠Sync对象在进行：</p>
<pre><code class="language-java">public void unlock() {
    sync.release(1);
}
</code></pre>
<p>那么这个Sync对象是干什么的呢？可以看到，公平锁和非公平锁都是继承自Sync，而Sync是继承自AbstractQueuedSynchronizer，简称队列同步器：</p>
<pre><code class="language-java">abstract static class Sync extends AbstractQueuedSynchronizer {
   //...
}

static final class NonfairSync extends Sync {}
static final class FairSync extends Sync {}
</code></pre>
<p>所以，要了解它的底层到底是如何进行操作的，还得看队列同步器，我们就先从这里下手吧！</p>
<h4 id="底层实现">底层实现</h4>
<p>AbstractQueuedSynchronizer（下面称为AQS）是实现锁机制的基础，它的内部封装了包括锁的获取、释放、以及等待队列。</p>
<p>一个锁（排他锁为例）的基本功能就是获取锁、释放锁、当锁被占用时，其他线程来争抢会进入等待队列，AQS已经将这些基本的功能封装完成了，其中等待队列是核心内容，等待队列是由双向链表数据结构实现的，每个等待状态下的线程都可以被封装进结点中并放入双向链表中，而对于双向链表是以队列的形式进行操作的，它像这样：</p>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h008jltp0zj212k0b4tac.jpg" alt="image-20220306162015545" loading="lazy"></figure>
<p>AQS中有一个<code>head</code>字段和一个<code>tail</code>字段分别记录双向链表的头结点和尾结点，而之后的一系列操作都是围绕此队列来进行的。我们先来了解一下每个结点都包含了哪些内容：</p>
<pre><code class="language-java">//每个处于等待状态的线程都可以是一个节点，并且每个节点是有很多状态的
static final class Node {
  	//每个节点都可以被分为独占模式节点或是共享模式节点，分别适用于独占锁和共享锁
    static final Node SHARED = new Node();
    static final Node EXCLUSIVE = null;

  	//等待状态，这里都定义好了
   	//唯一一个大于0的状态，表示已失效，可能是由于超时或中断，此节点被取消。
    static final int CANCELLED =  1;
  	//此节点后面的节点被挂起（进入等待状态）
    static final int SIGNAL    = -1;	
  	//在条件队列中的节点才是这个状态
    static final int CONDITION = -2;
  	//传播，一般用于共享锁
    static final int PROPAGATE = -3;

    volatile int waitStatus;    //等待状态值
    volatile Node prev;   //双向链表基操
    volatile Node next;
    volatile Thread thread;   //每一个线程都可以被封装进一个节点进入到等待队列
  
    Node nextWaiter;   //在等待队列中表示模式，条件队列中作为下一个结点的指针

    final boolean isShared() {
        return nextWaiter == SHARED;
    }

    final Node predecessor() throws NullPointerException {
        Node p = prev;
        if (p == null)
            throw new NullPointerException();
        else
            return p;
    }

    Node() {
    }

    Node(Thread thread, Node mode) {
        this.nextWaiter = mode;
        this.thread = thread;
    }

    Node(Thread thread, int waitStatus) {
        this.waitStatus = waitStatus;
        this.thread = thread;
    }
}
</code></pre>
<p>在一开始的时候，<code>head</code>和<code>tail</code>都是<code>null</code>，<code>state</code>为默认值<code>0</code>：</p>
<pre><code class="language-java">private transient volatile Node head;

private transient volatile Node tail;

private volatile int state;
</code></pre>
<p>不用担心双向链表不会进行初始化，初始化是在实际使用时才开始的，先不管，我们接着来看其他的初始化内容：</p>
<pre><code class="language-java">//直接使用Unsafe类进行操作
private static final Unsafe unsafe = Unsafe.getUnsafe();
//记录类中属性的在内存中的偏移地址，方便Unsafe类直接操作内存进行赋值等（直接修改对应地址的内存）
private static final long stateOffset;   //这里对应的就是AQS类中的state成员字段
private static final long headOffset;    //这里对应的就是AQS类中的head头结点成员字段
private static final long tailOffset;
private static final long waitStatusOffset;
private static final long nextOffset;

static {   //静态代码块，在类加载的时候就会自动获取偏移地址
    try {
        stateOffset = unsafe.objectFieldOffset
            (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));
        headOffset = unsafe.objectFieldOffset
            (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;));
        tailOffset = unsafe.objectFieldOffset
            (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));
        waitStatusOffset = unsafe.objectFieldOffset
            (Node.class.getDeclaredField(&quot;waitStatus&quot;));
        nextOffset = unsafe.objectFieldOffset
            (Node.class.getDeclaredField(&quot;next&quot;));

    } catch (Exception ex) { throw new Error(ex); }
}

//通过CAS操作来修改头结点
private final boolean compareAndSetHead(Node update) {
  	//调用的是Unsafe类的compareAndSwapObject方法，通过CAS算法比较对象并替换
    return unsafe.compareAndSwapObject(this, headOffset, null, update);
}

//同上，省略部分代码
private final boolean compareAndSetTail(Node expect, Node update) {

private static final boolean compareAndSetWaitStatus(Node node, int expect, int update) {

private static final boolean compareAndSetNext(Node node, Node expect, Node update) {
</code></pre>
<p>可以发现，队列同步器由于要使用到CAS算法，所以，直接使用了Unsafe工具类，Unsafe类中提供了CAS操作的方法（Java无法实现，底层由C++实现）所有对AQS类中成员字段的修改，都有对应的CAS操作封装。</p>
<p>现在我们大致了解了一下它的底层运作机制，我们接着来看这个类是如何进行使用的，它提供了一些可重写的方法（根据不同的锁类型和机制，可以自由定制规则，并且为独占式和非独占式锁都提供了对应的方法），以及一些已经写好的模板方法（模板方法会调用这些可重写的方法），使用此类只需要将可重写的方法进行重写，并调用提供的模板方法，从而实现锁功能（学习过设计模式会比较好理解一些）</p>
<p>我们首先来看可重写方法：</p>
<pre><code class="language-java">//独占式获取同步状态，查看同步状态是否和参数一致，如果返没有问题，那么会使用CAS操作设置同步状态并返回true
protected boolean tryAcquire(int arg) {
    throw new UnsupportedOperationException();
}

//独占式释放同步状态
protected boolean tryRelease(int arg) {
    throw new UnsupportedOperationException();
}

//共享式获取同步状态，返回值大于0表示成功，否则失败
protected int tryAcquireShared(int arg) {
    throw new UnsupportedOperationException();
}

//共享式释放同步状态
protected boolean tryReleaseShared(int arg) {
    throw new UnsupportedOperationException();
}

//是否在独占模式下被当前线程占用（锁是否被当前线程持有）
protected boolean isHeldExclusively() {
    throw new UnsupportedOperationException();
}
</code></pre>
<p>可以看到，这些需要重写的方法默认是直接抛出<code>UnsupportedOperationException</code>，也就是说根据不同的锁类型，我们需要去实现对应的方法，我们可以来看一下ReentrantLock（此类是全局独占式的）中的公平锁是如何借助AQS实现的：</p>
<pre><code class="language-java">static final class FairSync extends Sync {
    private static final long serialVersionUID = -3000897897090466540L;

  	//加锁操作调用了模板方法acquire
  	//为了防止各位绕晕，请时刻记住，lock方法一定是在某个线程下为了加锁而调用的，并且同一时间可能会有其他线程也在调用此方法
    final void lock() {
        acquire(1);
    }

    ...
}
</code></pre>
<p>我们先看看加锁操作干了什么事情，这里直接调用了AQS提供的模板方法<code>acquire()</code>，我们来看看它在AQS类中的实现细节：</p>
<pre><code class="language-java">@ReservedStackAccess //这个是JEP 270添加的新注解，它会保护被注解的方法，通过添加一些额外的空间，防止在多线程运行的时候出现栈溢出，下同
public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))   //节点为独占模式Node.EXCLUSIVE
        selfInterrupt();
}
</code></pre>
<p>首先会调用<code>tryAcquire()</code>方法（这里是由FairSync类实现的），如果尝试加独占锁失败（返回false了）说明可能这个时候有其他线程持有了此独占锁，所以当前线程得先等着，那么会调用<code>addWaiter()</code>方法将线程加入等待队列中：</p>
<pre><code class="language-java">private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // 先尝试使用CAS直接入队，如果这个时候其他线程也在入队（就是不止一个线程在同一时间争抢这把锁）就进入enq()
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
  	//此方法是CAS快速入队失败时调用
    enq(node);
    return node;
}

private Node enq(final Node node) {
  	//自旋形式入队，可以看到这里是一个无限循环
    for (;;) {
        Node t = tail;
        if (t == null) {  //这种情况只能说明头结点和尾结点都还没初始化
            if (compareAndSetHead(new Node()))   //初始化头结点和尾结点
                tail = head;
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;   //只有CAS成功的情况下，才算入队成功，如果CAS失败，那说明其他线程同一时间也在入队，并且手速还比当前线程快，刚好走到CAS操作的时候，其他线程就先入队了，那么这个时候node.prev就不是我们预期的节点了，而是另一个线程新入队的节点，所以说得进下一次循环再来一次CAS，这种形式就是自旋
            }
        }
    }
}
</code></pre>
<p>在了解了<code>addWaiter()</code>方法会将节点加入等待队列之后，我们接着来看，<code>addWaiter()</code>会返回已经加入的节点，<code>acquireQueued()</code>在得到返回的节点时，也会进入自旋状态，等待唤醒（也就是开始进入到拿锁的环节了）：</p>
<pre><code class="language-java">@ReservedStackAccess
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {   //可以看到当此节点位于队首(node.prev == head)时，会再次调用tryAcquire方法获取锁，如果获取成功，会返回此过程中是否被中断的值
                setHead(node);    //新的头结点设置为当前结点
                p.next = null; // 原有的头结点没有存在的意义了
                failed = false;   //没有失败
                return interrupted;   //直接返回等待过程中是否被中断
            }	
          	//依然没获取成功，
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;   //将当前节点的前驱节点等待状态设置为SIGNAL，如果失败将直接开启下一轮循环，直到成功为止，如果成功接着往下
                parkAndCheckInterrupt())   //挂起线程进入等待状态，等待被唤醒，如果在等待状态下被中断，那么会返回true，直接将中断标志设为true，否则就是正常唤醒，继续自旋
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);   //通过unsafe类操作底层挂起线程（会直接进入阻塞状态）
    return Thread.interrupted();
}
</code></pre>
<pre><code class="language-java">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)
        return true;   //已经是SIGNAL，直接true
    if (ws &gt; 0) {   //不能是已经取消的节点，必须找到一个没被取消的
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;   //直接抛弃被取消的节点
    } else {
        //不是SIGNAL，先CAS设置为SIGNAL（这里没有返回true因为CAS不一定成功，需要下一轮再判断一次）
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;   //返回false，马上开启下一轮循环
}
</code></pre>
<p>所以，<code>acquire()</code>中的if条件如果为true，那么只有一种情况，就是等待过程中被中断了，其他任何情况下都是成功获取到独占锁，所以当等待过程被中断时，会调用<code>selfInterrupt()</code>方法：</p>
<pre><code class="language-java">static void selfInterrupt() {
    Thread.currentThread().interrupt();
}
</code></pre>
<p>这里就是直接向当前线程发送中断信号了。</p>
<p>上面提到了LockSupport类，它是一个工具类，我们也可以来玩一下这个<code>park</code>和<code>unpark</code>:</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Thread t = Thread.currentThread();  //先拿到主线程的Thread对象
    new Thread(() -&gt; {
        try {
            TimeUnit.SECONDS.sleep(1);
            System.out.println(&quot;主线程可以继续运行了！&quot;);
            LockSupport.unpark(t);
          	//t.interrupt();   发送中断信号也可以恢复运行
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }).start();
    System.out.println(&quot;主线程被挂起！&quot;);
    LockSupport.park();
    System.out.println(&quot;主线程继续运行！&quot;);
}
</code></pre>
<p>这里我们就把公平锁的<code>lock()</code>方法实现讲解完毕了（让我猜猜，已经晕了对吧，越是到源码越考验个人的基础知识掌握，基础不牢地动山摇）接着我们来看公平锁的<code>tryAcquire()</code>方法：</p>
<pre><code class="language-java">static final class FairSync extends Sync {
  	//可重入独占锁的公平实现
    @ReservedStackAccess
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();   //先获取当前线程的Thread对象
        int c = getState();     //获取当前AQS对象状态（独占模式下0为未占用，大于0表示已占用）
        if (c == 0) {       //如果是0，那就表示没有占用，现在我们的线程就要来尝试占用它
            if (!hasQueuedPredecessors() &amp;&amp;    //等待队列是否不为空且当前线程没有拿到锁，其实就是看看当前线程有没有必要进行排队，如果没必要排队，就说明可以直接获取锁
                compareAndSetState(0, acquires)) {   //CAS设置状态，如果成功则说明成功拿到了这把锁，失败则说明可能这个时候其他线程在争抢，并且还比你先抢到
                setExclusiveOwnerThread(current);    //成功拿到锁，会将独占模式所有者线程设定为当前线程（这个方法是父类AbstractOwnableSynchronizer中的，就表示当前这把锁已经是这个线程的了）
                return true;   //占用锁成功，返回true
            }
        }
        else if (current == getExclusiveOwnerThread()) {   //如果不是0，那就表示被线程占用了，这个时候看看是不是自己占用的，如果是，由于是可重入锁，可以继续加锁
            int nextc = c + acquires;    //多次加锁会将状态值进行增加，状态值就是加锁次数
            if (nextc &lt; 0)   //加到int值溢出了？
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);   //设置为新的加锁次数
            return true;
        }
        return false;   //其他任何情况都是加锁失败
    }
}
</code></pre>
<p>在了解了公平锁的实现之后，是不是感觉有点恍然大悟的感觉，虽然整个过程非常复杂，但是只要理清思路，还是比较简单的。</p>
<p>加锁过程已经OK，我们接着来看，它的解锁过程，<code>unlock()</code>方法是在AQS中实现的：</p>
<pre><code class="language-java">public void unlock() {
    sync.release(1);    //直接调用了AQS中的release方法，参数为1表示解锁一次state值-1
}
</code></pre>
<pre><code class="language-java">@ReservedStackAccess
public final boolean release(int arg) {
    if (tryRelease(arg)) {   //和tryAcquire一样，也得子类去重写，释放锁操作
        Node h = head;    //释放锁成功后，获取新的头结点
        if (h != null &amp;&amp; h.waitStatus != 0)   //如果新的头结点不为空并且不是刚刚建立的结点（初始状态下status为默认值0，而上面在进行了shouldParkAfterFailedAcquire之后，会被设定为SIGNAL状态，值为-1）
            unparkSuccessor(h);   //唤醒头节点下一个节点中的线程
        return true;
    }
    return false;
}
</code></pre>
<pre><code class="language-java">private void unparkSuccessor(Node node) {
    // 将等待状态waitStatus设置为初始值0
    int ws = node.waitStatus;
    if (ws &lt; 0)
        compareAndSetWaitStatus(node, ws, 0);

    //获取下一个结点
    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {   //如果下一个结点为空或是等待状态是已取消，那肯定是不能通知unpark的，这时就要遍历所有节点再另外找一个符合unpark要求的节点了
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)   //这里是从队尾向前，因为enq()方法中的t.next = node是在CAS之后进行的，而 node.prev = t 是CAS之前进行的，所以从后往前一定能够保证遍历所有节点
            if (t.waitStatus &lt;= 0)
                s = t;
    }
    if (s != null)   //要是找到了，就直接unpark，要是还是没找到，那就算了
        LockSupport.unpark(s.thread);
}
</code></pre>
<p>那么我们来看看<code>tryRelease()</code>方法是怎么实现的，具体实现在Sync中：</p>
<pre><code class="language-java">@ReservedStackAccess
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;   //先计算本次解锁之后的状态值
    if (Thread.currentThread() != getExclusiveOwnerThread())   //因为是独占锁，那肯定这把锁得是当前线程持有才行
        throw new IllegalMonitorStateException();   //否则直接抛异常
    boolean free = false;
    if (c == 0) {  //如果解锁之后的值为0，表示已经完全释放此锁
        free = true;
        setExclusiveOwnerThread(null);  //将独占锁持有线程设置为null
    }
    setState(c);   //状态值设定为c
    return free;  //如果不是0表示此锁还没完全释放，返回false，是0就返回true
}
</code></pre>
<p>综上，我们来画一个完整的流程图：</p>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h004uzeni8j224k0ca0w9.jpg" alt="image-20220306141248030" loading="lazy"></figure>
<p>这里我们只讲解了公平锁，有关非公平锁和读写锁，还请各位观众根据我们之前的思路，自行解读。</p>
<h4 id="公平锁一定公平吗">公平锁一定公平吗？</h4>
<p>前面我们讲解了公平锁的实现原理，那么，我们尝试分析一下，在并发的情况下，公平锁一定公平吗？</p>
<p>我们再次来回顾一下<code>tryAcquire()</code>方法的实现：</p>
<pre><code class="language-java">@ReservedStackAccess
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (!hasQueuedPredecessors() &amp;&amp;   //注意这里，公平锁的机制是，一开始会查看是否有节点处于等待
            compareAndSetState(0, acquires)) {   //如果前面的方法执行后发现没有等待节点，就直接进入占锁环节了
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc &lt; 0)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    return false;
}
</code></pre>
<p>所以<code>hasQueuedPredecessors()</code>这个环节容不得半点闪失，否则会直接破坏掉公平性，假如现在出现了这样的情况：</p>
<p>线程1已经持有锁了，这时线程2来争抢这把锁，走到<code>hasQueuedPredecessors()</code>，判断出为 <code>false</code>，线程2继续运行，然后线程2肯定获取锁失败（因为锁这时是被线程1占有的），因此就进入到等待队列中：</p>
<pre><code class="language-java">private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        if (t == null) { // 线程2进来之后，肯定是要先走这里的，因为head和tail都是null
            if (compareAndSetHead(new Node()))
                tail = head;   //这里就将tail直接等于head了，注意这里完了之后还没完，这里只是初始化过程
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}

private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    Node pred = tail;
    if (pred != null) {   //由于一开始head和tail都是null，所以线程2直接就进enq()了
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);   //请看上面
    return node;
}
</code></pre>
<p>而碰巧不巧，这个时候线程3也来抢锁了，按照正常流程走到了<code>hasQueuedPredecessors()</code>方法，而在此方法中：</p>
<pre><code class="language-java">public final boolean hasQueuedPredecessors() {
    Node t = tail; // Read fields in reverse initialization order
    Node h = head;
    Node s;
  	//这里直接判断h != t，而此时线程2才刚刚执行完 tail = head，所以直接就返回false了
    return h != t &amp;&amp;
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
</code></pre>
<p>因此，线程3这时就紧接着准备开始CAS操作了，又碰巧，这时线程1释放锁了，现在的情况就是，线程3直接开始CAS判断，而线程2还在插入节点状态，结果可想而知，居然是线程3先拿到了锁，这显然是违背了公平锁的公平机制。</p>
<p>一张图就是：</p>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h007thq2x1j22ce0k879c.jpg" alt="image-20220306155509195" loading="lazy"></figure>
<p>因此公不公平全看<code>hasQueuedPredecessors()</code>，而此方法只有在等待队列中存在节点时才能保证不会出现问题。所以公平锁，只有在等待队列存在节点时，才是真正公平的。</p>
<h4 id="condition实现原理">Condition实现原理</h4>
<p>通过前面的学习，我们知道Condition类实际上就是用于代替传统对象的wait/notify操作的，同样可以实现等待/通知模式，并且同一把锁下可以创建多个Condition对象。那么我们接着来看看，它又是如何实现的呢，我们先从单个Condition对象进行分析：</p>
<p>在AQS中，Condition有一个实现类ConditionObject，而这里也是使用了链表实现了条件队列：</p>
<pre><code class="language-java">public class ConditionObject implements Condition, java.io.Serializable {
    private static final long serialVersionUID = 1173984872572414699L;
    /** 条件队列的头结点 */
    private transient Node firstWaiter;
    /** 条件队列的尾结点 */
    private transient Node lastWaiter;
  
  	//...
</code></pre>
<p>这里是直接使用了AQS中的Node类，但是使用的是Node类中的nextWaiter字段连接节点，并且Node的status为CONDITION：</p>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h016lyg63ij21ew0dsgnt.jpg" alt="image-20220307115850295" loading="lazy"></figure>
<p>我们知道，当一个线程调用<code>await()</code>方法时，会进入等待状态，直到其他线程调用<code>signal()</code>方法将其唤醒，而这里的条件队列，正是用于存储这些处于等待状态的线程。</p>
<p>我们先来看看最关键的<code>await()</code>方法是如何实现的，为了防止一会绕晕，在开始之前，我们先明确此方法的目标：</p>
<ul>
<li>只有已经持有锁的线程才可以使用此方法</li>
<li>当调用此方法后，会直接释放锁，无论加了多少次锁</li>
<li>只有其他线程调用<code>signal()</code>或是被中断时才会唤醒等待中的线程</li>
<li>被唤醒后，需要等待其他线程释放锁，拿到锁之后才可以继续执行，并且会恢复到之前的状态（await之前加了几层锁唤醒后依然是几层锁）</li>
</ul>
<p>好了，差不多可以上源码了：</p>
<pre><code class="language-java">public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();   //如果在调用await之前就被添加了中断标记，那么会直接抛出中断异常
    Node node = addConditionWaiter();    //为当前线程创建一个新的节点，并将其加入到条件队列中
    int savedState = fullyRelease(node);    //完全释放当前线程持有的锁，并且保存一下state值，因为唤醒之后还得恢复
    int interruptMode = 0;     //用于保存中断状态
    while (!isOnSyncQueue(node)) {   //循环判断是否位于同步队列中，如果等待状态下的线程被其他线程唤醒，那么会正常进入到AQS的等待队列中（之后我们会讲）
        LockSupport.park(this);   //如果依然处于等待状态，那么继续挂起
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)   //看看等待的时候是不是被中断了
            break;
    }
  	//出了循环之后，那线程肯定是已经醒了，这时就差拿到锁就可以恢复运行了
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  //直接开始acquireQueued尝试拿锁（之前已经讲过了）从这里开始基本就和一个线程去抢锁是一样的了
        interruptMode = REINTERRUPT;
  	//已经拿到锁了，基本可以开始继续运行了，这里再进行一下后期清理工作
    if (node.nextWaiter != null) 
        unlinkCancelledWaiters();  //将等待队列中，不是Node.CONDITION状态的节点移除
    if (interruptMode != 0)   //依然是响应中断
        reportInterruptAfterWait(interruptMode);
  	//OK，接着该干嘛干嘛
}
</code></pre>
<p>实际上<code>await()</code>方法比较中规中矩，大部分操作也在我们的意料之中，那么我们接着来看<code>signal()</code>方法是如何实现的，同样的，为了防止各位绕晕，先明确signal的目标：</p>
<ul>
<li>只有持有锁的线程才能唤醒锁所属的Condition等待的线程</li>
<li>优先唤醒条件队列中的第一个，如果唤醒过程中出现问题，接着找往下找，直到找到一个可以唤醒的</li>
<li>唤醒操作本质上是将条件队列中的结点直接丢进AQS等待队列中，让其参与到锁的竞争中</li>
<li>拿到锁之后，线程才能恢复运行</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h016s4p0rfj21as0hg76w.jpg" alt="image-20220307120449303" loading="lazy"></figure>
<p>好了，上源码：</p>
<pre><code class="language-java">public final void signal() {
    if (!isHeldExclusively())    //先看看当前线程是不是持有锁的状态
        throw new IllegalMonitorStateException();   //不是？那你不配唤醒别人
    Node first = firstWaiter;    //获取条件队列的第一个结点
    if (first != null)    //如果队列不为空，获取到了，那么就可以开始唤醒操作
        doSignal(first);
}
</code></pre>
<pre><code class="language-java">private void doSignal(Node first) {
    do {
        if ( (firstWaiter = first.nextWaiter) == null)   //如果当前节点在本轮循环没有后继节点了，条件队列就为空了
            lastWaiter = null;   //所以这里相当于是直接清空
        first.nextWaiter = null;   //将给定节点的下一个结点设置为null，因为当前结点马上就会离开条件队列了
    } while (!transferForSignal(first) &amp;&amp;   //接着往下看
             (first = firstWaiter) != null);   //能走到这里只能说明给定节点被设定为了取消状态，那就继续看下一个结点
}
</code></pre>
<pre><code class="language-java">final boolean transferForSignal(Node node) {
    /*
     * 如果这里CAS失败，那有可能此节点被设定为了取消状态
     */
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;

    //CAS成功之后，结点的等待状态就变成了默认值0，接着通过enq方法直接将节点丢进AQS的等待队列中，相当于唤醒并且可以等待获取锁了
  	//这里enq方法返回的是加入之后等待队列队尾的前驱节点，就是原来的tail
    Node p = enq(node);
    int ws = p.waitStatus;   //保存前驱结点的等待状态
  	//如果上一个节点的状态为取消, 或者尝试设置上一个节点的状态为SIGNAL失败（可能是在ws&gt;0判断完之后马上变成了取消状态，导致CAS失败）
    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);  //直接唤醒线程
    return true;
}
</code></pre>
<p>其实最让人不理解的就是倒数第二行，明明上面都正常进入到AQS等待队列了，应该是可以开始走正常流程了，那么这里为什么还要提前来一次unpark呢？</p>
<p>这里其实是为了进行优化而编写，直接unpark会有两种情况：</p>
<ul>
<li>如果插入结点前，AQS等待队列的队尾节点就已经被取消，则满足wc &gt; 0</li>
<li>如果插入node后，AQS内部等待队列的队尾节点已经稳定，满足tail.waitStatus == 0，但在执行ws &gt;<br>
0之后!compareAndSetWaitStatus(p, ws,<br>
Node.SIGNAL)之前被取消，则CAS也会失败，满足compareAndSetWaitStatus(p, ws,<br>
Node.SIGNAL) == false</li>
</ul>
<p>如果这里被提前unpark，那么在<code>await()</code>方法中将可以被直接唤醒，并跳出while循环，直接开始争抢锁，因为前一个等待结点是被取消的状态，没有必要再等它了。</p>
<p>所以，大致流程下：</p>
<figure data-type="image" tabindex="6"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h018ts8x80j21to0eidix.jpg" alt="image-20220307131536020" loading="lazy"></figure>
<p>只要把整个流程理清楚，还是很好理解的。</p>
<h4 id="自行实现锁类">自行实现锁类</h4>
<p>既然前面了解了那么多AQS的功能，那么我就仿照着这些锁类来实现一个简单的锁：</p>
<ul>
<li>要求：同一时间只能有一个线程持有锁，不要求可重入（反复加锁无视即可）</li>
</ul>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) throws InterruptedException {
        
    }

    /**
     * 自行实现一个最普通的独占锁
     * 要求：同一时间只能有一个线程持有锁，不要求可重入
     */
    private static class MyLock implements Lock {

        /**
         * 设计思路：
         * 1. 锁被占用，那么exclusiveOwnerThread应该被记录，并且state = 1
         * 2. 锁没有被占用，那么exclusiveOwnerThread为null，并且state = 0
         */
        private static class Sync extends AbstractQueuedSynchronizer {
            @Override
            protected boolean tryAcquire(int arg) {
                if(isHeldExclusively()) return true;     //无需可重入功能，如果是当前线程直接返回true
                if(compareAndSetState(0, arg)){    //CAS操作进行状态替换
                    setExclusiveOwnerThread(Thread.currentThread());    //成功后设置当前的所有者线程
                    return true;
                }
                return false;
            }

            @Override
            protected boolean tryRelease(int arg) {
                if(getState() == 0)
                    throw new IllegalMonitorStateException();   //没加锁情况下是不能直接解锁的
                if(isHeldExclusively()){     //只有持有锁的线程才能解锁
                    setExclusiveOwnerThread(null);    //设置所有者线程为null
                    setState(0);    //状态变为0
                    return true;
                }
                return false;
            }

            @Override
            protected boolean isHeldExclusively() {
                return getExclusiveOwnerThread() == Thread.currentThread();
            }

            protected Condition newCondition(){
                return new ConditionObject();    //直接用现成的
            }
        }

        private final Sync sync = new Sync();

        @Override
        public void lock() {
            sync.acquire(1);
        }

        @Override
        public void lockInterruptibly() throws InterruptedException {
            sync.acquireInterruptibly(1);
        }

        @Override
        public boolean tryLock() {
            return sync.tryAcquire(1);
        }

        @Override
        public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
            return sync.tryAcquireNanos(1, unit.toNanos(time));
        }

        @Override
        public void unlock() {
            sync.release(1);
        }

        @Override
        public Condition newCondition() {
            return sync.newCondition();
        }
    }
}
</code></pre>
<p>到这里，我们对应队列同步器AQS的讲解就先到此为止了，当然，AQS的全部机制并非仅仅只有我们讲解的内容，一些我们没有提到的内容，还请各位观众自行探索，会有满满的成就感哦~</p>
<hr>
<h2 id="原子类">原子类</h2>
<p>前面我们讲解了锁框架的使用和实现原理，虽然比较复杂，但是收获还是很多的（主要是观摩大佬写的代码）这一部分我们就来讲一点轻松的。</p>
<p>前面我们说到，如果要保证<code>i++</code>的原子性，那么我们的唯一选择就是加锁，那么，除了加锁之外，还有没有其他更好的解决方法呢？JUC为我们提供了原子类，底层采用CAS算法，它是一种用法简单、性能高效、线程安全地更新变量的方式。</p>
<p>所有的原子类都位于<code>java.util.concurrent.atomic</code>包下。</p>
<h3 id="原子类介绍">原子类介绍</h3>
<p>常用基本数据类，有对应的原子类封装：</p>
<ul>
<li>AtomicInteger：原子更新int</li>
<li>AtomicLong：原子更新long</li>
<li>AtomicBoolean：原子更新boolean</li>
</ul>
<p>那么，原子类和普通的基本类在使用上有没有什么区别呢？我们先来看正常情况下使用一个基本类型：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        int i = 1;
        System.out.println(i++);
    }
}
</code></pre>
<p>现在我们使用int类型对应的原子类，要实现同样的代码该如何编写：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        AtomicInteger i = new AtomicInteger(1);
        System.out.println(i.getAndIncrement());  //如果想实现i += 2这种操作，可以使用 addAndGet() 自由设置delta 值
    }
}
</code></pre>
<p>我们可以将int数值封装到此类中（注意必须调用构造方法，它不像Integer那样有装箱机制），并且通过调用此类提供的方法来获取或是对封装的int值进行自增，乍一看，这不就是基本类型包装类嘛，有啥高级的。确实，还真有包装类那味，但是它可不仅仅是简单的包装，它的自增操作是具有原子性的：</p>
<pre><code class="language-java">public class Main {
    private static AtomicInteger i = new AtomicInteger(0);
    public static void main(String[] args) throws InterruptedException {
        Runnable r = () -&gt; {
            for (int j = 0; j &lt; 100000; j++)
                i.getAndIncrement();
            System.out.println(&quot;自增完成！&quot;);
        };
        new Thread(r).start();
        new Thread(r).start();
        TimeUnit.SECONDS.sleep(1);
        System.out.println(i.get());
    }
}
</code></pre>
<p>同样是直接进行自增操作，我们发现，使用原子类是可以保证自增操作原子性的，就跟我们前面加锁一样。怎么会这么神奇？我们来看看它的底层是如何实现的，直接从构造方法点进去：</p>
<pre><code class="language-java">private volatile int value;

public AtomicInteger(int initialValue) {
    value = initialValue;
}

public AtomicInteger() {
}
</code></pre>
<p>可以看到，它的底层是比较简单的，其实本质上就是封装了一个<code>volatile</code>类型的int值，这样能够保证可见性，在CAS操作的时候不会出现问题。</p>
<pre><code class="language-java">private static final Unsafe unsafe = Unsafe.getUnsafe();
private static final long valueOffset;

static {
    try {
        valueOffset = unsafe.objectFieldOffset
            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));
    } catch (Exception ex) { throw new Error(ex); }
}
</code></pre>
<p>可以看到最上面是和AQS采用了类似的机制，因为要使用CAS算法更新value的值，所以得先计算出value字段在对象中的偏移地址，CAS直接修改对应位置的内存即可（可见Unsafe类的作用巨大，很多的底层操作都要靠它来完成）</p>
<p>接着我们来看自增操作是怎么在运行的：</p>
<pre><code class="language-java">public final int getAndIncrement() {
    return unsafe.getAndAddInt(this, valueOffset, 1);
}
</code></pre>
<p>可以看到这里调用了<code>unsafe.getAndAddInt()</code>，套娃时间到，我们接着看看Unsafe里面写了什么：</p>
<pre><code class="language-java">public final int getAndAddInt(Object o, long offset, int delta) {  //delta就是变化的值，++操作就是自增1
    int v;
    do {
      	//volatile版本的getInt()
      	//能够保证可见性
        v = getIntVolatile(o, offset);
    } while (!compareAndSwapInt(o, offset, v, v + delta));  //这里是开始cas替换int的值，每次都去拿最新的值去进行替换，如果成功则离开循环，不成功说明这个时候其他线程先修改了值，就进下一次循环再获取最新的值然后再cas一次，直到成功为止
    return v;
}
</code></pre>
<p>可以看到这是一个<code>do-while</code>循环，那么这个循环在做一个什么事情呢？感觉就和我们之前讲解的AQS队列中的机制差不多，也是采用自旋形式，来不断进行CAS操作，直到成功。</p>
<figure data-type="image" tabindex="7"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h02eg5qcfaj21pa0ekju1.jpg" alt="image-20220308131536403" loading="lazy"></figure>
<p>可见，原子类底层也是采用了CAS算法来保证的原子性，包括<code>getAndSet</code>、<code>getAndAdd</code>等方法都是这样。原子类也直接提供了CAS操作方法，我们可以直接使用：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    AtomicInteger integer = new AtomicInteger(10);
    System.out.println(integer.compareAndSet(30, 20));
    System.out.println(integer.compareAndSet(10, 20));
    System.out.println(integer);
}
</code></pre>
<p>如果想以普通变量的方式来设定值，那么可以使用<code>lazySet()</code>方法，这样就不采用<code>volatile</code>的立即可见机制了。</p>
<pre><code class="language-java">AtomicInteger integer = new AtomicInteger(1);
integer.lazySet(2);
</code></pre>
<p>除了基本类有原子类以外，基本类型的数组类型也有原子类：</p>
<ul>
<li>AtomicIntegerArray：原子更新int数组</li>
<li>AtomicLongArray：原子更新long数组</li>
<li>AtomicReferenceArray：原子更新引用数组</li>
</ul>
<p>其实原子数组和原子类型一样的，不过我们可以对数组内的元素进行原子操作：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    AtomicIntegerArray array = new AtomicIntegerArray(new int[]{0, 4, 1, 3, 5});
    Runnable r = () -&gt; {
        for (int i = 0; i &lt; 100000; i++)
            array.getAndAdd(0, 1);
    };
    new Thread(r).start();
    new Thread(r).start();
    TimeUnit.SECONDS.sleep(1);
    System.out.println(array.get(0));
}
</code></pre>
<p>在JDK8之后，新增了<code>DoubleAdder</code>和<code>LongAdder</code>，在高并发情况下，<code>LongAdder</code>的性能比<code>AtomicLong</code>的性能更好，主要体现在自增上，它的大致原理如下：在低并发情况下，和<code>AtomicLong</code>是一样的，对value值进行CAS操作，但是出现高并发的情况时，<code>AtomicLong</code>会进行大量的循环操作来保证同步，而<code>LongAdder</code>会将对value值的CAS操作分散为对数组<code>cells</code>中多个元素的CAS操作（内部维护一个Cell[] as数组，每个Cell里面有一个初始值为0的long型变量，在高并发时会进行分散CAS，就是不同的线程可以对数组中不同的元素进行CAS自增，这样就避免了所有线程都对同一个值进行CAS），只需要最后再将结果加起来即可。</p>
<figure data-type="image" tabindex="8"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h02g67t42fj21ps0lan19.jpg" alt="image-20220308141517668" loading="lazy"></figure>
<p>使用如下：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    LongAdder adder = new LongAdder();
    Runnable r = () -&gt; {
        for (int i = 0; i &lt; 100000; i++)
            adder.add(1);
    };
    for (int i = 0; i &lt; 100; i++)
        new Thread(r).start();   //100个线程
    TimeUnit.SECONDS.sleep(1);
    System.out.println(adder.sum());   //最后求和即可
}
</code></pre>
<p>由于底层源码比较复杂，这里就不做讲解了。两者的性能对比（这里用到了CountDownLatch，建议学完之后再来看）：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) throws InterruptedException {
        System.out.println(&quot;使用AtomicLong的时间消耗：&quot;+test2()+&quot;ms&quot;);
        System.out.println(&quot;使用LongAdder的时间消耗：&quot;+test1()+&quot;ms&quot;);
    }

    private static long test1() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(100);
        LongAdder adder = new LongAdder();
        long timeStart = System.currentTimeMillis();
        Runnable r = () -&gt; {
            for (int i = 0; i &lt; 100000; i++)
                adder.add(1);
            latch.countDown();
        };
        for (int i = 0; i &lt; 100; i++)
            new Thread(r).start();
        latch.await();
        return System.currentTimeMillis() - timeStart;
    }

    private static long test2() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(100);
        AtomicLong atomicLong = new AtomicLong();
        long timeStart = System.currentTimeMillis();
        Runnable r = () -&gt; {
            for (int i = 0; i &lt; 100000; i++)
                atomicLong.incrementAndGet();
            latch.countDown();
        };
        for (int i = 0; i &lt; 100; i++)
            new Thread(r).start();
        latch.await();
        return System.currentTimeMillis() - timeStart;
    }
}
</code></pre>
<p>除了对基本数据类型支持原子操作外，对于引用类型，也是可以实现原子操作的：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    String a = &quot;Hello&quot;;
    String b = &quot;World&quot;;
    AtomicReference&lt;String&gt; reference = new AtomicReference&lt;&gt;(a);
    reference.compareAndSet(a, b);
    System.out.println(reference.get());
}
</code></pre>
<p>JUC还提供了字段原子更新器，可以对类中的某个指定字段进行原子操作（注意字段必须添加volatile关键字）：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) throws InterruptedException {
        Student student = new Student();
        AtomicIntegerFieldUpdater&lt;Student&gt; fieldUpdater =
                AtomicIntegerFieldUpdater.newUpdater(Student.class, &quot;age&quot;);
        System.out.println(fieldUpdater.incrementAndGet(student));
    }

    public static class Student{
        volatile int age;
    }
}
</code></pre>
<p>了解了这么多原子类，是不是感觉要实现保证原子性的工作更加轻松了？</p>
<h3 id="aba问题及解决方案">ABA问题及解决方案</h3>
<p>我们来想象一下这种场景：</p>
<figure data-type="image" tabindex="9"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h02hpquocrj213i0c8myf.jpg" alt="image-20220308150840321" loading="lazy"></figure>
<p>线程1和线程2同时开始对<code>a</code>的值进行CAS修改，但是线程1的速度比较快，将a的值修改为2之后紧接着又修改回1，这时线程2才开始进行判断，发现a的值是1，所以CAS操作成功。</p>
<p>很明显，这里的1已经不是一开始的那个1了，而是被重新赋值的1，这也是CAS操作存在的问题（无锁虽好，但是问题多多），它只会机械地比较当前值是不是预期值，但是并不会关心当前值是否被修改过，这种问题称之为<code>ABA</code>问题。</p>
<p>那么如何解决这种<code>ABA</code>问题呢，JUC提供了带版本号的引用类型，只要每次操作都记录一下版本号，并且版本号不会重复，那么就可以解决ABA问题了：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    String a = &quot;Hello&quot;;
    String b = &quot;World&quot;;
    AtomicStampedReference&lt;String&gt; reference = new AtomicStampedReference&lt;&gt;(a, 1);  //在构造时需要指定初始值和对应的版本号
    reference.attemptStamp(a, 2);   //可以中途对版本号进行修改，注意要填写当前的引用对象
    System.out.println(reference.compareAndSet(a, b, 2, 3));   //CAS操作时不仅需要提供预期值和修改值，还要提供预期版本号和新的版本号
}
</code></pre>
<p>至此，有关原子类的讲解就到这里。</p>
<hr>
<h2 id="并发容器">并发容器</h2>
<p>简单的讲完了，又该讲难一点的了。</p>
<p>**注意：**本版块的重点在于探究并发容器是如何利用锁机制和算法实现各种丰富功能的，我们会忽略一些常规功能的实现细节（比如链表如何插入元素删除元素），而更关注并发容器应对并发场景算法上的实现（比如在多线程环境下的插入操作是按照什么规则进行的）</p>
<p>在单线程模式下，集合类提供的容器可以说是非常方便了，几乎我们每个项目中都能或多或少的用到它们，我们在JavaSE阶段，为各位讲解了各个集合类的实现原理，我们了解了链表、顺序表、哈希表等数据结构，那么，在多线程环境下，这些数据结构还能正常工作吗？</p>
<h3 id="传统容器线程安全吗">传统容器线程安全吗</h3>
<p>我们来测试一下，100个线程同时向ArrayList中添加元素会怎么样：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        Runnable r = () -&gt; {
            for (int i = 0; i &lt; 100; i++)
                list.add(&quot;lbwnb&quot;);
        };
        for (int i = 0; i &lt; 100; i++)
            new Thread(r).start();
      	TimeUnit.SECONDS.sleep(1);
        System.out.println(list.size());
    }
}
</code></pre>
<p>不出意外的话，肯定是会报错的：</p>
<pre><code>Exception in thread &quot;Thread-0&quot; java.lang.ArrayIndexOutOfBoundsException: 73
	at java.util.ArrayList.add(ArrayList.java:465)
	at com.test.Main.lambda$main$0(Main.java:13)
	at java.lang.Thread.run(Thread.java:750)
Exception in thread &quot;Thread-19&quot; java.lang.ArrayIndexOutOfBoundsException: 1851
	at java.util.ArrayList.add(ArrayList.java:465)
	at com.test.Main.lambda$main$0(Main.java:13)
	at java.lang.Thread.run(Thread.java:750)
9773
</code></pre>
<p>那么我们来看看报的什么错，从栈追踪信息可以看出，是add方法出现了问题：</p>
<pre><code class="language-java">public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;   //这一句出现了数组越界
    return true;
}
</code></pre>
<p>也就是说，同一时间其他线程也在疯狂向数组中添加元素，那么这个时候有可能在<code>ensureCapacityInternal</code>（确认容量足够）执行之后，<code>elementData[size++] = e;</code>执行之前，其他线程插入了元素，导致size的值超出了数组容量。这些在单线程的情况下不可能发生的问题，在多线程下就慢慢出现了。</p>
<p>我们再来看看比较常用的HashMap呢？</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();
    for (int i = 0; i &lt; 100; i++) {
        int finalI = i;
        new Thread(() -&gt; {
            for (int j = 0; j &lt; 100; j++)
                map.put(finalI * 1000 + j, &quot;lbwnb&quot;);
        }).start();
    }
    TimeUnit.SECONDS.sleep(2);
    System.out.println(map.size());
}
</code></pre>
<p>经过测试发现，虽然没有报错，但是最后的结果并不是我们期望的那样，实际上它还有可能导致Entry对象出现环状数据结构，引起死循环。</p>
<p>所以，在多线程环境下，要安全地使用集合类，我们得找找解决方案了。</p>
<h3 id="并发容器介绍">并发容器介绍</h3>
<p>怎么才能解决并发情况下的容器问题呢？我们首先想到的肯定是给方法前面加个<code>synchronzed</code>关键字，这样总不会抢了吧，在之前我们可以使用Vector或是Hashtable来解决，但是它们的效率实在是太低了，完全依靠锁来解决问题，因此现在已经很少再使它们了，这里也不会再去进行讲解。</p>
<p>JUC提供了专用于并发场景下的容器，比如我们刚刚使用的ArrayList，在多线程环境下是没办法使用的，我们可以将其替换为JUC提供的多线程专用集合类：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();  //这里使用CopyOnWriteArrayList来保证线程安全
    Runnable r = () -&gt; {
        for (int i = 0; i &lt; 100; i++)
            list.add(&quot;lbwnb&quot;);
    };
    for (int i = 0; i &lt; 100; i++)
        new Thread(r).start();
    TimeUnit.SECONDS.sleep(1);
    System.out.println(list.size());
}
</code></pre>
<p>我们发现，使用了<code>CopyOnWriteArrayList</code>之后，再没出现过上面的问题。</p>
<p>那么它是如何实现的呢，我们先来看看它是如何进行<code>add()</code>操作的：</p>
<pre><code class="language-java">public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();   //直接加锁，保证同一时间只有一个线程进行添加操作
    try {
        Object[] elements = getArray();  //获取当前存储元素的数组
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);   //直接复制一份数组
        newElements[len] = e;   //修改复制出来的数组
        setArray(newElements);   //将元素数组设定为复制出来的数组
        return true;
    } finally {
        lock.unlock();
    }
}
</code></pre>
<p>可以看到添加操作是直接上锁，并且会先拷贝一份当前存放元素的数组，然后对数组进行修改，再将此数组替换（CopyOnWrite）接着我们来看读操作：</p>
<pre><code class="language-java">public E get(int index) {
    return get(getArray(), index);
}
</code></pre>
<p>因此，<code>CopyOnWriteArrayList</code>对于读操作不加锁，而对于写操作是加锁的，类似于我们前面讲解的读写锁机制，这样就可以保证不丢失读性能的情况下，写操作不会出现问题。</p>
<p>接着我们来看对于HashMap的并发容器<code>ConcurrentHashMap</code>：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    Map&lt;Integer, String&gt; map = new ConcurrentHashMap&lt;&gt;();
    for (int i = 0; i &lt; 100; i++) {
        int finalI = i;
        new Thread(() -&gt; {
            for (int j = 0; j &lt; 100; j++)
                map.put(finalI * 100 + j, &quot;lbwnb&quot;);
        }).start();
    }
    TimeUnit.SECONDS.sleep(1);
    System.out.println(map.size());
}
</code></pre>
<p>可以看到这里的ConcurrentHashMap就没有出现之前HashMap的问题了。因为线程之间会争抢同一把锁，我们之前在讲解LongAdder的时候学习到了一种压力分散思想，既然每个线程都想抢锁，那我就干脆多搞几把锁，让你们每个人都能拿到，这样就不会存在等待的问题了，而JDK7之前，ConcurrentHashMap的原理也比较类似，它将所有数据分为一段一段地存储，先分很多段出来，每一段都给一把锁，当一个线程占锁访问时，只会占用其中一把锁，也就是仅仅锁了一小段数据，而其他段的数据依然可以被其他线程正常访问。</p>
<figure data-type="image" tabindex="10"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h02kqcrfhcj21fk0fk75i.jpg" alt="image-20220308165304048" loading="lazy"></figure>
<p>这里我们重点讲解JDK8之后它是怎么实现的，它采用了CAS算法配合锁机制实现，我们先来回顾一下JDK8下的HashMap是什么样的结构：</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/img_convert/3ad05990ed9e29801b1992030c030a00.png" alt="img" loading="lazy"></figure>
<p>HashMap就是利用了哈希表，哈希表的本质其实就是一个用于存放后续节点的头结点的数组，数组里面的每一个元素都是一个头结点（也可以说就是一个链表），当要新插入一个数据时，会先计算该数据的哈希值，找到数组下标，然后创建一个新的节点，添加到对应的链表后面。当链表的长度达到8时，会自动将链表转换为红黑树，这样能使得原有的查询效率大幅度降低！当使用红黑树之后，我们就可以利用二分搜索的思想，快速地去寻找我们想要的结果，而不是像链表一样挨个去看。</p>
<p>又是基础不牢地动山摇环节，由于ConcurrentHashMap的源码比较复杂，所以我们先从最简单的构造方法开始下手：</p>
<figure data-type="image" tabindex="12"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h02t130fslj222h0u0k1b.jpg" alt="image-20220308214006830" loading="lazy"></figure>
<p>我们发现，它的构造方法和HashMap的构造方法有很大的出入，但是大体的结构和HashMap是差不多的，也是维护了一个哈希表，并且哈希表中存放的是链表或是红黑树，所以我们直接来看<code>put()</code>操作是如何实现的，只要看明白这个，基本上就懂了：</p>
<pre><code class="language-java">public V put(K key, V value) {
    return putVal(key, value, false);
}

//有点小乱，如果看着太乱，可以在IDEA中折叠一下代码块，不然有点难受
final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException(); //键值不能为空，基操
    int hash = spread(key.hashCode());    //计算键的hash值，用于确定在哈希表中的位置
    int binCount = 0;   //一会用来记录链表长度的，忽略
    for (Node&lt;K,V&gt;[] tab = table;;) {    //无限循环，而且还是并发包中的类，盲猜一波CAS自旋锁
        Node&lt;K,V&gt; f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();    //如果数组（哈希表）为空肯定是要进行初始化的，然后再重新进下一轮循环
        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {   //如果哈希表该位置为null，直接CAS插入结点作为头结即可（注意这里会将f设置当前哈希表位置上的头结点）
            if (casTabAt(tab, i, null,
                         new Node&lt;K,V&gt;(hash, key, value, null)))  
                break;                   // 如果CAS成功，直接break结束put方法，失败那就继续下一轮循环
        } else if ((fh = f.hash) == MOVED)   //头结点哈希值为-1，这里只需要知道是因为正在扩容即可
            tab = helpTransfer(tab, f);   //帮助进行迁移，完事之后再来下一次循环
        else {     //特殊情况都完了，这里就该是正常情况了，
            V oldVal = null;
            synchronized (f) {   //在前面的循环中f肯定是被设定为了哈希表某个位置上的头结点，这里直接把它作为锁加锁了，防止同一时间其他线程也在操作哈希表中这个位置上的链表或是红黑树
                if (tabAt(tab, i) == f) {
                    if (fh &gt;= 0) {    //头结点的哈希值大于等于0说明是链表，下面就是针对链表的一些列操作
                        ...实现细节略
                    } else if (f instanceof TreeBin) {   //肯定不大于0，肯定也不是-1，还判断是不是TreeBin，所以不用猜了，肯定是红黑树，下面就是针对红黑树的情况进行操作
                      	//在ConcurrentHashMap并不是直接存储的TreeNode，而是TreeBin
                        ...实现细节略
                    }
                }
            }
          	//根据链表长度决定是否要进化为红黑树
            if (binCount != 0) {
                if (binCount &gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);   //注意这里只是可能会进化为红黑树，如果当前哈希表的长度小于64，它会优先考虑对哈希表进行扩容
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}
</code></pre>
<p>怎么样，是不是感觉看着挺复杂，其实也还好，总结一下就是：</p>
<figure data-type="image" tabindex="13"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h02vkx608bj21eo0iwad0.jpg" alt="image-20220308230825627" loading="lazy"></figure>
<p>我们接着来看看<code>get()</code>操作：</p>
<pre><code class="language-java">public V get(Object key) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;
    int h = spread(key.hashCode());   //计算哈希值
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (e = tabAt(tab, (n - 1) &amp; h)) != null) {
      	// 如果头结点就是我们要找的，那直接返回值就行了
        if ((eh = e.hash) == h) {
            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))
                return e.val;
        }
      	//要么是正在扩容，要么就是红黑树，负数只有这两种情况
        else if (eh &lt; 0)
            return (p = e.find(h, key)) != null ? p.val : null;
      	//确认无误，肯定在列表里，开找
        while ((e = e.next) != null) {
            if (e.hash == h &amp;&amp;
                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))
                return e.val;
        }
    }
  	//没找到只能null了
    return null;
}
</code></pre>
<p>综上，ConcurrentHashMap的put操作，实际上是对哈希表上的所有头结点元素分别加锁，理论上来说哈希表的长度很大程度上决定了ConcurrentHashMap在同一时间能够处理的线程数量，这也是为什么<code>treeifyBin()</code>会优先考虑为哈希表进行扩容的原因。显然，这种加锁方式比JDK7的分段锁机制性能更好。</p>
<p>其实这里也只是简单地介绍了一下它的运行机制，ConcurrentHashMap真正的难点在于扩容和迁移操作，我们主要了解的是他的并发执行机制，有关它的其他实现细节，这里暂时不进行讲解。</p>
<h3 id="阻塞队列">阻塞队列</h3>
<p>除了我们常用的容器类之外，JUC还提供了各种各样的阻塞队列，用于不同的工作场景。</p>
<p>阻塞队列本身也是队列，但是它是适用于多线程环境下的，基于ReentrantLock实现的，它的接口定义如下：</p>
<pre><code class="language-java">public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; {
   	boolean add(E e);

    //入队，如果队列已满，返回false否则返回true（非阻塞）
    boolean offer(E e);

    //入队，如果队列已满，阻塞线程直到能入队为止
    void put(E e) throws InterruptedException;

    //入队，如果队列已满，阻塞线程直到能入队或超时、中断为止，入队成功返回true否则false
    boolean offer(E e, long timeout, TimeUnit unit)
        throws InterruptedException;

    //出队，如果队列为空，阻塞线程直到能出队为止
    E take() throws InterruptedException;

    //出队，如果队列为空，阻塞线程直到能出队超时、中断为止，出队成功正常返回，否则返回null
    E poll(long timeout, TimeUnit unit)
        throws InterruptedException;

    //返回此队列理想情况下（在没有内存或资源限制的情况下）可以不阻塞地入队的数量，如果没有限制，则返回 Integer.MAX_VALUE
    int remainingCapacity();

    boolean remove(Object o);

    public boolean contains(Object o);

  	//一次性从BlockingQueue中获取所有可用的数据对象（还可以指定获取数据的个数）
    int drainTo(Collection&lt;? super E&gt; c);

    int drainTo(Collection&lt;? super E&gt; c, int maxElements);
</code></pre>
<p>比如现在有一个容量为3的阻塞队列，这个时候一个线程<code>put</code>向其添加了三个元素，第二个线程接着<code>put</code>向其添加三个元素，那么这个时候由于容量已满，会直接被阻塞，而这时第三个线程从队列中取走2个元素，线程二停止阻塞，先丢两个进去，还有一个还是进不去，所以说继续阻塞。</p>
<figure data-type="image" tabindex="14"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h03qghwg2nj21sc0gawhb.jpg" alt="image-20220309165644403" loading="lazy"></figure>
<p>利用阻塞队列，我们可以轻松地实现消费者和生产者模式，还记得我们在JavaSE中的实战吗？</p>
<blockquote>
<p>所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。</p>
</blockquote>
<p>通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒，窗口上只能放一个菜。</p>
<p>我们来看看，使用阻塞队列如何实现，这里我们就使用<code>ArrayBlockingQueue</code>实现类：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue&lt;Object&gt; queue = new ArrayBlockingQueue&lt;&gt;(1);
        Runnable supplier = () -&gt; {
            while (true){
                try {
                    String name = Thread.currentThread().getName();
                    System.err.println(time()+&quot;生产者 &quot;+name+&quot; 正在准备餐品...&quot;);
                    TimeUnit.SECONDS.sleep(3);
                    System.err.println(time()+&quot;生产者 &quot;+name+&quot; 已出餐！&quot;);
                    queue.put(new Object());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    break;
                }
            }
        };
        Runnable consumer = () -&gt; {
            while (true){
                try {
                    String name = Thread.currentThread().getName();
                    System.out.println(time()+&quot;消费者 &quot;+name+&quot; 正在等待出餐...&quot;);
                    queue.take();
                    System.out.println(time()+&quot;消费者 &quot;+name+&quot; 取到了餐品。&quot;);
                    TimeUnit.SECONDS.sleep(4);
                    System.out.println(time()+&quot;消费者 &quot;+name+&quot; 已经将饭菜吃完了！&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    break;
                }
            }
        };
        for (int i = 0; i &lt; 2; i++) new Thread(supplier, &quot;Supplier-&quot;+i).start();
        for (int i = 0; i &lt; 3; i++) new Thread(consumer, &quot;Consumer-&quot;+i).start();
    }

    private static String time(){
        SimpleDateFormat format = new SimpleDateFormat(&quot;HH:mm:ss&quot;);
        return &quot;[&quot;+format.format(new Date()) + &quot;] &quot;;
    }
}
</code></pre>
<p>可以看到，阻塞队列在多线程环境下的作用是非常明显的，算上ArrayBlockingQueue，一共有三种常用的阻塞队列：</p>
<ul>
<li>ArrayBlockingQueue：有界带缓冲阻塞队列（就是队列是有容量限制的，装满了肯定是不能再装的，只能阻塞，数组实现）</li>
<li>SynchronousQueue：无缓冲阻塞队列（相当于没有容量的ArrayBlockingQueue，因此只有阻塞的情况）</li>
<li>LinkedBlockingQueue：无界带缓冲阻塞队列（没有容量限制，也可以限制容量，也会阻塞，链表实现）</li>
</ul>
<p>这里我们以ArrayBlockingQueue为例进行源码解读，我们先来看看构造方法：</p>
<pre><code class="language-java">final ReentrantLock lock;

private final Condition notEmpty;

private final Condition notFull;

public ArrayBlockingQueue(int capacity, boolean fair) {
    if (capacity &lt;= 0)
        throw new IllegalArgumentException();
    this.items = new Object[capacity];
    lock = new ReentrantLock(fair);   //底层采用锁机制保证线程安全性，这里我们可以选择使用公平锁或是非公平锁
    notEmpty = lock.newCondition();   //这里创建了两个Condition（都属于lock）一会用于入队和出队的线程阻塞控制
    notFull =  lock.newCondition();
}
</code></pre>
<p>接着我们来看<code>put</code>和<code>offer</code>方法是如何实现的：</p>
<pre><code class="language-java">public boolean offer(E e) {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;    //可以看到这里也是使用了类里面的ReentrantLock进行加锁操作
    lock.lock();    //保证同一时间只有一个线程进入
    try {
        if (count == items.length)   //直接看看队列是否已满，如果没满则直接入队，如果已满则返回false
            return false;
        else {
            enqueue(e);
            return true;
        }
    } finally {
        lock.unlock();
    }
}

public void put(E e) throws InterruptedException {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;    //同样的，需要进行加锁操作
    lock.lockInterruptibly();    //注意这里是可以响应中断的
    try {
        while (count == items.length)
            notFull.await();    //可以看到当队列已满时会直接挂起当前线程，在其他线程出队操作时会被唤醒
        enqueue(e);   //直到队列有空位才将线程入队
    } finally {
        lock.unlock();
    }
}
</code></pre>
<pre><code class="language-java">private E dequeue() {
    // assert lock.getHoldCount() == 1;
    // assert items[takeIndex] != null;
    final Object[] items = this.items;
    @SuppressWarnings(&quot;unchecked&quot;)
    E x = (E) items[takeIndex];
    items[takeIndex] = null;
    if (++takeIndex == items.length)
        takeIndex = 0;
    count--;
    if (itrs != null)
        itrs.elementDequeued();
    notFull.signal();    //出队操作会调用notFull的signal方法唤醒被挂起处于等待状态的线程
    return x;
}
</code></pre>
<p>接着我们来看出队操作：</p>
<pre><code class="language-java">public E poll() {
    final ReentrantLock lock = this.lock;
    lock.lock();    //出队同样进行加锁操作，保证同一时间只能有一个线程执行
    try {
        return (count == 0) ? null : dequeue();   //如果队列不为空则出队，否则返回null
    } finally {
        lock.unlock();
    }
}

public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();    //可以响应中断进行加锁
    try {
        while (count == 0)
            notEmpty.await();    //和入队相反，也是一直等直到队列中有元素之后才可以出队，在入队时会唤醒此线程
        return dequeue();
    } finally {
        lock.unlock();
    }
}
</code></pre>
<pre><code class="language-java">private void enqueue(E x) {
    // assert lock.getHoldCount() == 1;
    // assert items[putIndex] == null;
    final Object[] items = this.items;
    items[putIndex] = x;
    if (++putIndex == items.length)
        putIndex = 0;
    count++;
    notEmpty.signal();    //对notEmpty的signal唤醒操作
}
</code></pre>
<p>可见，如果各位对锁的使用非常熟悉的话，那么在阅读这些源码的时候，就会非常轻松了。</p>
<p>接着我们来看一个比较特殊的队列SynchronousQueue，它没有任何容量，也就是说正常情况下出队必须和入队操作成对出现，我们先来看它的内部，可以看到内部有一个抽象类Transferer，它定义了一个<code>transfer</code>方法：</p>
<pre><code class="language-java">abstract static class Transferer&lt;E&gt; {
    /**
     * 可以是put也可以是take操作
     *
     * @param e 如果不是空，即作为生产者，那么表示会将传入参数元素e交给消费者
     *          如果为空，即作为消费者，那么表示会从生产者那里得到一个元素e并返回
     * @param 是否可以超时
     * @param 超时时间
     * @return 不为空就是从生产者那里返回的，为空表示要么被中断要么超时。
     */
    abstract E transfer(E e, boolean timed, long nanos);
}
</code></pre>
<p>乍一看，有点迷惑，难不成还要靠这玩意去实现put和take操作吗？实际上它是直接以生产者消费者模式进行的，由于不需要依靠任何容器结构来暂时存放数据，所以我们可以直接通过<code>transfer</code>方法来对生产者和消费者之间的数据进行传递。</p>
<p>比如一个线程put一个新的元素进入，这时如果没有其他线程调用take方法获取元素，那么会持续被阻塞，直到有线程取出元素，而<code>transfer</code>正是需要等生产者消费者双方都到齐了才能进行交接工作，单独只有其中一方都需要进行等待。</p>
<pre><code class="language-java">public void put(E e) throws InterruptedException {
    if (e == null) throw new NullPointerException();  //判空
    if (transferer.transfer(e, false, 0) == null) {   //直接使用transfer方法进行数据传递
        Thread.interrupted();    //为空表示要么被中断要么超时
        throw new InterruptedException();
    }
}
</code></pre>
<p>它在公平和非公平模式下，有两个实现，这里我们来看公平模式下的SynchronousQueue是如何实现的：</p>
<pre><code class="language-java">static final class TransferQueue&lt;E&gt; extends Transferer&lt;E&gt; {
     //头结点（头结点仅作为头结点，后续节点才是真正等待的线程节点）
     transient volatile QNode head;
     //尾结点
     transient volatile QNode tail;

    /** 节点有生产者和消费者角色之分 */
    static final class QNode {
        volatile QNode next;          // 后继节点
        volatile Object item;         // 存储的元素
        volatile Thread waiter;       // 处于等待的线程，和之前的AQS一样的思路，每个线程等待的时候都会被封装为节点
        final boolean isData;         // 是生产者节点还是消费者节点
</code></pre>
<p>公平模式下，Transferer的实现是TransferQueue，是以先进先出的规则的进行的，内部有一个QNode类来保存等待的线程。</p>
<p>好了，我们直接上<code>transfer()</code>方法的实现（这里再次提醒各位，多线程环境下的源码分析和单线程的分析不同，我们需要时刻关注当前代码块的加锁状态，如果没有加锁，一定要具有多线程可能会同时运行的意识，这个意识在以后你自己处理多线程问题伴随着你，才能保证你的思路在多线程环境下是正确的）：</p>
<pre><code class="language-java">E transfer(E e, boolean timed, long nanos) {   //注意这里面没加锁，肯定会多个线程之间竞争
    QNode s = null;
    boolean isData = (e != null);   //e为空表示消费者，不为空表示生产者

    for (;;) {
        QNode t = tail;
        QNode h = head;
        if (t == null || h == null)         // 头结点尾结点任意为空（但是在构造的时候就已经不是空了）
            continue;                       // 自旋

        if (h == t || t.isData == isData) { // 头结点等于尾结点表示队列中只有一个头结点，肯定是空，或者尾结点角色和当前节点一样，这两种情况下，都需要进行入队操作
            QNode tn = t.next;
            if (t != tail)                  // 如果这段时间内t被其他线程修改了，如果是就进下一轮循环重新来
                continue;
            if (tn != null) {               // 继续校验是否为队尾，如果tn不为null，那肯定是其他线程改了队尾，可以进下一轮循环重新来了
                advanceTail(t, tn);					// CAS将新的队尾节点设置为tn，成不成功都无所谓，反正这一轮肯定没戏了
                continue;
            }
            if (timed &amp;&amp; nanos &lt;= 0)        // 超时返回null
                return null;
            if (s == null)
                s = new QNode(e, isData);   //构造当前结点，准备加入等待队列
            if (!t.casNext(null, s))        // CAS添加当前节点为尾结点的下一个，如果失败肯定其他线程又抢先做了，直接进下一轮循环重新来
                continue;

            advanceTail(t, s);              // 上面的操作基本OK了，那么新的队尾元素就修改为s
            Object x = awaitFulfill(s, e, timed, nanos);   //开始等待s所对应的消费者或是生产者进行交接，比如s现在是生产者，那么它就需要等到一个消费者的到来才会继续（这个方法会先进行自旋等待匹配，如果自旋一定次数后还是没有匹配成功，那么就挂起）
            if (x == s) {                   // 如果返回s本身说明等待状态下被取消
                clean(t, s);
                return null;
            }

            if (!s.isOffList()) {           // 如果s操作完成之后没有离开队列，那么这里将其手动丢弃
                advanceHead(t, s);          // 将s设定为新的首节点(注意头节点仅作为头结点，并非处于等待的线程节点)
                if (x != null)              // 删除s内的其他信息
                    s.item = s;
                s.waiter = null;
            }
            return (x != null) ? (E)x : e;   //假如当前是消费者，直接返回x即可，x就是从生产者那里拿来的元素

        } else {                            // 这种情况下就是与队列中结点类型匹配的情况了（注意队列要么为空要么只会存在一种类型的节点，因为一旦出现不同类型的节点马上会被交接掉）
            QNode m = h.next;               // 获取头结点的下一个接口，准备进行交接工作
            if (t != tail || m == null || h != head)
                continue;                   // 判断其他线程是否先修改，如果修改过那么开下一轮

            Object x = m.item;
            if (isData == (x != null) ||    // 判断节点类型，如果是相同的操作，那肯定也是有问题的
                x == m ||                   // 或是当前操作被取消
                !m.casItem(x, e)) {         // 上面都不是？那么最后再进行CAS替换m中的元素，成功表示交接成功，失败就老老实实重开吧
                advanceHead(h, m);          // dequeue and retry
                continue;
            }

            advanceHead(h, m);              // 成功交接，新的头结点可以改为m了，原有的头结点直接不要了
            LockSupport.unpark(m.waiter);   // m中的等待交接的线程可以继续了，已经交接完成
            return (x != null) ? (E)x : e;  // 同上，该返回什么就返回什么
        }
    }
}
</code></pre>
<p>所以，总结为以下流程：</p>
<figure data-type="image" tabindex="15"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h08pt2hn9rj21rw0mojw7.jpg" alt="image-20220314002203511" loading="lazy"></figure>
<p>对于非公平模式下的SynchronousQueue，则是采用的栈结构来存储等待节点，但是思路也是与这里的一致，需要等待并进行匹配操作，各位如果感兴趣可以继续了解一下非公平模式下的SynchronousQueue实现。</p>
<p>在JDK7的时候，基于SynchronousQueue产生了一个更强大的TransferQueue，它保留了SynchronousQueue的匹配交接机制，并且与等待队列进行融合。</p>
<p>我们知道，SynchronousQueue并没有使用锁，而是采用CAS操作保证生产者与消费者的协调，但是它没有容量，而LinkedBlockingQueue虽然是有容量且无界的，但是内部基本都是基于锁实现的，性能并不是很好，这时，我们就可以将它们各自的优点单独拿出来，揉在一起，就成了性能更高的LinkedTransferQueue</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    LinkedTransferQueue&lt;String&gt; queue = new LinkedTransferQueue&lt;&gt;();
    queue.put(&quot;1&quot;);  //插入时，会先检查是否有其他线程等待获取，如果是，直接进行交接，否则插入到存储队列中
   	queue.put(&quot;2&quot;);  //不会像SynchronousQueue那样必须等一个匹配的才可以
    queue.forEach(System.out::println);   //直接打印所有的元素，这在SynchronousQueue下只能是空，因为单独的入队或出队操作都会被阻塞
}
</code></pre>
<p>相比 <code>SynchronousQueue</code> ，它多了一个可以存储的队列，我们依然可以像阻塞队列那样获取队列中所有元素的值，简单来说，<code>LinkedTransferQueue</code>其实就是一个多了存储队列的<code>SynchronousQueue</code>。</p>
<p>接着我们来了解一些其他的队列：</p>
<ul>
<li>PriorityBlockingQueue - 是一个支持优先级的阻塞队列，元素的获取顺序按优先级决定。</li>
<li>DelayQueue - 它能够实现延迟获取元素，同样支持优先级。</li>
</ul>
<p>我们先来看优先级阻塞队列：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    PriorityBlockingQueue&lt;Integer&gt; queue =
            new PriorityBlockingQueue&lt;&gt;(10, Integer::compare);   //可以指定初始容量（可扩容）和优先级比较规则，这里我们使用升序
    queue.add(3);
    queue.add(1);
    queue.add(2);
    System.out.println(queue);    //注意保存顺序并不会按照优先级排列，所以可以看到结果并不是排序后的结果
    System.out.println(queue.poll());   //但是出队顺序一定是按照优先级进行的
    System.out.println(queue.poll());
    System.out.println(queue.poll());
}
</code></pre>
<p>我们的重点是DelayQueue，它能实现延时出队，也就是说当一个元素插入后，如果没有超过一定时间，那么是无法让此元素出队的。</p>
<pre><code class="language-java">public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt;
    implements BlockingQueue&lt;E&gt; {
</code></pre>
<p>可以看到此类只接受Delayed的实现类作为元素：</p>
<pre><code class="language-java">public interface Delayed extends Comparable&lt;Delayed&gt; {  //注意这里继承了Comparable，它支持优先级

    //获取剩余等待时间，正数表示还需要进行等待，0或负数表示等待结束
    long getDelay(TimeUnit unit);
}
</code></pre>
<p>这里我们手动实现一个：</p>
<pre><code class="language-java">private static class Test implements Delayed {
    private final long time;   //延迟时间，这里以毫秒为单位
    private final int priority;
    private final long startTime;
    private final String data;

    private Test(long time, int priority, String data) {
        this.time = TimeUnit.SECONDS.toMillis(time);   //秒转换为毫秒
        this.priority = priority;
        this.startTime = System.currentTimeMillis();   //这里我们以毫秒为单位
        this.data = data;
    }

    @Override
    public long getDelay(TimeUnit unit) {
        long leftTime = time - (System.currentTimeMillis() - startTime); //计算剩余时间 = 设定时间 - 已度过时间(= 当前时间 - 开始时间)
        return unit.convert(leftTime, TimeUnit.MILLISECONDS);   //注意进行单位转换，单位由队列指定（默认是纳秒单位）
    }

    @Override
    public int compareTo(Delayed o) {
        if(o instanceof Test)
            return priority - ((Test) o).priority;   //优先级越小越优先
        return 0;
    }

    @Override
    public String toString() {
        return data;
    }
}
</code></pre>
<p>接着我们在主方法中尝试使用：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    DelayQueue&lt;Test&gt; queue = new DelayQueue&lt;&gt;();
    queue.add(new Test(1, 2, &quot;2号&quot;));   //1秒钟延时
    queue.add(new Test(3, 1, &quot;1号&quot;));   //1秒钟延时，优先级最高

    System.out.println(queue.take());    //注意出队顺序是依照优先级来的，即使一个元素已经可以出队了，依然需要等待优先级更高的元素到期
    System.out.println(queue.take());
}
</code></pre>
<p>我们来研究一下DelayQueue是如何实现的，首先来看<code>add()</code>方法：</p>
<pre><code class="language-java">public boolean add(E e) {
    return offer(e);
}

public boolean offer(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        q.offer(e);   //注意这里是向内部维护的一个优先级队列添加元素，并不是DelayQueue本身存储元素
        if (q.peek() == e) {   //如果入队后队首就是当前元素，那么直接进行一次唤醒操作（因为有可能之前就有其他线程等着take了）
            leader = null;
            available.signal();
        }
        return true;
    } finally {
        lock.unlock();
    }
}

public void put(E e) {
    offer(e);
}
</code></pre>
<p>可以看到无论是哪种入队操作，都会加锁进行，属于常规操作。我们接着来看<code>take()</code>方法：</p>
<pre><code class="language-java">public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;   //出队也要先加锁，基操
    lock.lockInterruptibly();
    try {
        for (;;) {    //无限循环，常规操作
            E first = q.peek();    //获取队首元素
            if (first == null)     //如果为空那肯定队列为空，先等着吧，等有元素进来
                available.await();
            else {
                long delay = first.getDelay(NANOSECONDS);    //获取延迟，这里传入的时间单位是纳秒
                if (delay &lt;= 0)
                    return q.poll();     //如果获取到延迟时间已经小于0了，那说明ok，可以直接出队返回
                first = null;
                if (leader != null)   //这里用leader来减少不必要的等待时间，如果不是null那说明有线程在等待，为null说明没有线程等待
                    available.await();   //如果其他线程已经在等元素了，那么当前线程直接进永久等待状态
                else {
                    Thread thisThread = Thread.currentThread();
                    leader = thisThread;    //没有线程等待就将leader设定为当前线程
                    try {
                        available.awaitNanos(delay);     //获取到的延迟大于0，那么就需要等待延迟时间，再开始下一次获取
                    } finally {
                        if (leader == thisThread)
                            leader = null;
                    }
                }
            }
        }
    } finally {
        if (leader == null &amp;&amp; q.peek() != null)
            available.signal();   //当前take结束之后唤醒一个其他永久等待状态下的线程
        lock.unlock();   //解锁，完事
    }
}
</code></pre>
<p>到此，有关并发容器的讲解就到这里。</p>
<p>下一章我们会继续讲解线程池以及并发工具类。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM笔记（一）]]></title>
        <id>https://muouren7.github.io/post/JVM笔记（一）/</id>
        <link href="https://muouren7.github.io/post/JVM笔记（一）/">
        </link>
        <updated>2022-10-14T08:06:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="走进jvm">走进JVM</h1>
<p>JVM相对于Java应用层的学习难度更大，**开篇推荐掌握的预备知识：**C/C++(关键)、微机原理与接口技术、计算机组成原理、操作系统、数据结构与算法、编译原理（不推荐刚学完JavaSE的同学学习），如果没有掌握推荐的一半以上的预备知识，可能学习起来会比较吃力。</p>
<p>**本套课程中需要用到的开发工具：**CLion、IDEA、Jetbrains Gateway</p>
<p>此阶段，我们需要深入探讨Java的底层执行原理，了解Java程序运行的本质。开始之前，推荐各位都入手一本《深入理解Java虚拟机 第三版》这本书对于JVM的讲述非常地详细：</p>
<figure data-type="image" tabindex="1"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages-cn.ssl-images-amazon.cn%2Fimages%2FI%2F81zGZfnLdwL.__BG0%2C0%2C0%2C0_FMpng_AC_UL320_SR250%2C320_.jpg&amp;refer=http%3A%2F%2Fimages-cn.ssl-images-amazon.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1645933645&amp;t=1f5da62f1510b166c33f05b94a830b48" alt="点击查看图片来源" loading="lazy"></figure>
<p>我们在JavaSE阶段的开篇就进行介绍了，我们的Java程序之所以能够实现跨平台，本质就是因为它是运行在虚拟机之上的，而不同平台只需要安装对应平台的Java虚拟机即可运行（在JRE中包含），所有的Java程序都采用统一的标准，在任何平台编译出来的字节码文件(.class)也是同样的，最后实际上是将编译后的字节码交给JVM处理执行。</p>
<figure data-type="image" tabindex="2"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F314515%2F201912%2F314515-20191231163244928-184981058.png&amp;refer=http%3A%2F%2Fimg2018.cnblogs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1645942605&amp;t=53b5ab5873cf233ff45f9fefb8aa87e8" alt="点击查看图片来源" loading="lazy"></figure>
<p>也正是得益于这种统一规范，除了Java以外，还有多种JVM语言，比如Kotlin、Groovy等，它们的语法虽然和Java不一样，但是最终编译得到的字节码文件，和Java是同样的规范，同样可以交给JVM处理。</p>
<figure data-type="image" tabindex="3"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F2004486%2F202008%2F2004486-20200825201006756-1741469951.png&amp;refer=http%3A%2F%2Fimg2020.cnblogs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1645942643&amp;t=4624e818442fd4bc90b26df9a9f7e5d1" alt="点击查看图片来源" loading="lazy"></figure>
<p>所以，JVM是我们需要去关注的一个部分，通过了解Java的底层运作机制，我们的技术会得到质的提升。</p>
<h2 id="技术概述">技术概述</h2>
<p>首先我们要了解虚拟机的具体定义，我们所接触过的虚拟机有安装操作系统的虚拟机，也有我们的Java虚拟机，而它们所面向的对象不同，Java虚拟机只是面向单一应用程序的虚拟机，但是它和我们接触的系统级虚拟机一样，我们也可以为其分配实际的硬件资源，比如最大内存大小等。</p>
<p>并且Java虚拟机并没有采用传统的PC架构，比如现在的HotSpot虚拟机，实际上采用的是<code>基于栈的指令集架构</code>，而我们的传统程序设计一般都是<code>基于寄存器的指令集架构</code>，这里我们需要回顾一下<code>计算机组成原理</code>中的CPU结构：</p>
<figure data-type="image" tabindex="4"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F9251733-5b4556af04fa3e5e.png&amp;refer=http%3A%2F%2Fupload-images.jianshu.io&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1645971181&amp;t=c9aaa14cb580afd4bc5dca3319c5344b" alt="点击查看图片来源" loading="lazy"></figure>
<p>其中，<strong>AX，BX，CX，DX 称作为数据寄存器：</strong></p>
<ul>
<li>AX (Accumulator)：累加寄存器，也称之为累加器；</li>
<li>BX (Base)：基地址寄存器；</li>
<li>CX (Count)：计数器寄存器；</li>
<li>DX (Data)：数据寄存器；</li>
</ul>
<p>这些寄存器可以用来传送数据和暂存数据，并且它们还可以细分为一个8位的高位寄存器和一个8位的低位寄存器，除了这些通用功能，它们各自也有自己的一些专属职责，比如AX就是一个专用于累加的寄存器，用的也比较多。</p>
<p><strong>SP 和 BP 又称作为指针寄存器：</strong></p>
<ul>
<li>SP (Stack Pointer)：堆栈指针寄存器，与SS配合使用，用于访问栈顶；</li>
<li>BP (Base Pointer)：基指针寄存器，可用作SS的一个相对基址位置，用它可直接存取堆栈中的数据；</li>
</ul>
<p><strong>SI 和 DI 又称作为变址寄存器：</strong></p>
<ul>
<li>SI (Source Index)：源变址寄存器；</li>
<li>DI (Destination Index)：目的变址寄存器；</li>
</ul>
<p>主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。</p>
<p><strong>控制寄存器：</strong></p>
<ul>
<li>IP (Instruction Pointer)：指令指针寄存器；</li>
<li>FLAG：标志寄存器；</li>
</ul>
<p><strong>段寄存器：</strong></p>
<ul>
<li>CS (Code Segment)：代码段寄存器；</li>
<li>DS (Data Segment)：数据段寄存器；</li>
<li>SS (Stack Segment)：堆栈段寄存器；</li>
<li>ES (Extra Segment)：附加段寄存器；</li>
</ul>
<p>这里我们分别比较一下在x86架构下C语言和arm架构下编译之后的汇编指令不同之处：</p>
<pre><code class="language-c">int main() {     //实现一个最简的a+b功能，并存入变量c
    int a = 10;
    int b = 20;
    int c = a + b;
    return c;
}
</code></pre>
<pre><code class="language-sh">gcc -S main.c
</code></pre>
<pre><code class="language-assembly">	.file	&quot;main.c&quot;
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc  ;rbp寄存器是64位CPU下的基址寄存器，和8086CPU的16位bp一样
	pushq	%rbp     ;该函数中需要用到rbp寄存器，所以需要先把他原来的值压栈保护起来
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp    ;rsp是64位下的栈指针寄存器，这里是将rsp的值丢给rbp，因为局部变量是存放在栈中的，之后会使用rbp来访问局部变量
	.cfi_def_cfa_register 6
	movl	$10, -12(%rbp)    ;将10存入rbp所指向位置-12的位置 -&gt;  int a = 10;
	movl	$20, -8(%rbp)     ;将20存入rbp所指向位置-8的位置  -&gt; int b = 20;
	movl	-12(%rbp), %edx   ;将变量a的值交给DX寄存器（32位下叫edx，因为是int，这里只使用了32位）
	movl	-8(%rbp), %eax    ;同上，变量b的值丢给AX寄存器
	addl	%edx, %eax        ;将DX和AX寄存器中的值相加，并将结果存在AX中  -&gt;  tmp = a + b
	movl	%eax, -4(%rbp)    ;将20存入rbp所指向位置-4的位置  -&gt; int c = tmp;与上面合在一起就是int c = a + b;
	movl	-4(%rbp), %eax    ;根据约定，将函数返回值放在AX   -&gt; return c;
	popq	%rbp     ;函数执行完毕，出栈
	.cfi_def_cfa 7, 8
	ret      ;函数返回
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	&quot;GCC: (Ubuntu 7.5.0-6ubuntu2) 7.5.0&quot;
	.section	.note.GNU-stack,&quot;&quot;,@progbits
</code></pre>
<p>在arm架构下（Apple M1 Pro芯片）编译的结果为：</p>
<pre><code class="language-assembly">    .section   __TEXT,__text,regular,pure_instructions
   .build_version macos, 12, 0    sdk_version 12, 1
   .globl _main                           ; -- Begin function main
   .p2align   2
_main:                                  ; @main
   .cfi_startproc
; %bb.0:
   sub    sp, sp, #16                     ; =16
   .cfi_def_cfa_offset 16
   str    wzr, [sp, #12]
   mov    w8, #10
   str    w8, [sp, #8]
   mov    w8, #20
   str    w8, [sp, #4]
   ldr    w8, [sp, #8]
   ldr    w9, [sp, #4]
   add    w8, w8, w9
   str    w8, [sp]
   ldr    w0, [sp]
   add    sp, sp, #16                     ; =16
   ret
   .cfi_endproc
                                        ; -- End function
.subsections_via_symbols
</code></pre>
<p>我们发现，在不同的CPU架构下，实际上得到的汇编代码也不一样，并且在arm架构下并没有和x86架构一样的寄存器结构，因此只能使用不同的汇编指令操作来实现。所以这也是为什么C语言不支持跨平台的原因，我们只能将同样的代码在不同的平台上编译之后才能在对应的平台上运行我们的程序。而Java利用了JVM，它提供了很好的平台无关性（当然，JVM本身是不跨平台的），我们的Java程序编译之后，并不是可以由平台直接运行的程序，而是由JVM运行，同时，我们前面说了，JVM（如HotSpot虚拟机），实际上采用的是<code>基于栈的指令集架构</code>，它并没有依赖于寄存器，而是更多的利用操作栈来完成，这样不仅设计和实现起来更简单，并且也能够更加方便地实现跨平台，不太依赖于硬件的支持。</p>
<p>这里我们对一个类进行反编译查看：</p>
<pre><code class="language-java">public class Main {
    public int test(){    //和上面的例子一样
        int a = 10;
        int b = 20;
        int c = a + b;
        return c;
    }
}
</code></pre>
<pre><code class="language-sh">javap -v target/classes/com/test/Main.class #使用javap命令对class文件进行反编译
</code></pre>
<p>得到如下结果：</p>
<pre><code>...
public int test();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=4, args_size=1
         0: bipush        10
         2: istore_1
         3: bipush        20
         5: istore_2
         6: iload_1
         7: iload_2
         8: iadd
         9: istore_3
        10: iload_3
        11: ireturn
      LineNumberTable:
        line 5: 0
        line 6: 3
        line 7: 6
        line 8: 10
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      12     0  this   Lcom/test/Main;
            3       9     1     a   I
            6       6     2     b   I
           10       2     3     c   I
</code></pre>
<p>我们可以看到，java文件编译之后，也会生成类似于C语言那样的汇编指令，但是这些命令都是交给JVM去执行的命令（实际上虚拟机提供了一个类似于物理机的运行环境，也有程序计数器之类的东西），最下方存放的是本地变量（局部变量）表，表示此方法中出现的本地变量，实际上this也在其中，所以我们才能在非静态方法中使用<code>this</code>关键字，在最上方标记了方法的返回值类型、访问权限等。首先介绍一下例子中出现的命令代表什么意思：</p>
<ul>
<li>bipush   将单字节的常量值推到栈顶</li>
<li>istore_1   将栈顶的int类型数值存入到第二个本地变量</li>
<li>istore_2   将栈顶的int类型数值存入到第三个本地变量</li>
<li>istore_3   将栈顶的int类型数值存入到第四个本地变量</li>
<li>iload_1    将第二个本地变量推向栈顶</li>
<li>iload_2    将第三个本地变量推向栈顶</li>
<li>iload_3   将第四个本地变量推向栈顶</li>
<li>iadd   将栈顶的两个int类型变量相加，并将结果压入栈顶</li>
<li>ireturn   方法的返回操作</li>
</ul>
<p>有关详细的指令介绍列表可以参考《深入理解Java虚拟机 第三版》附录C。</p>
<p>JVM运行字节码时，所有的操作基本都是围绕两种数据结构，一种是堆栈（本质是栈结构），还有一种是队列，如果JVM执行某条指令时，该指令需要对数据进行操作，那么被操作的数据在指令执行前，必须要压到堆栈上，JVM会自动将栈顶数据作为操作数。如果堆栈上的数据需要暂时保存起来时，那么它就会被存储到局部变量队列上。</p>
<p>我们从第一条指令来依次向下解读，显示方法相关属性：</p>
<pre><code>descriptor: ()I     //参数以及返回值类型，()I就表示没有形式参数，返回值为基本类型int
flags: ACC_PUBLIC   //public访问权限
Code:
  stack=2, locals=4, args_size=1    //stack表示要用到的最大栈深度，本地变量数，堆栈上最大对象数量（这里指的是this）
</code></pre>
<p>有关descriptor的详细属性介绍，我们会放在之后的类结构中进行讲解。</p>
<p>接着我们来看指令：</p>
<pre><code>0: bipush        10     //0是程序偏移地址，然后是指令，最后是操作数
2: istore_1
</code></pre>
<p>这一步操作实际上就是使用<code>bipush</code>将10推向栈顶，接着使用<code>istore_1</code>将当前栈顶数据存放到第二个局部变量中，也就是a，所以这一步执行的是<code>int a = 10</code>操作。</p>
<pre><code>3: bipush        20
5: istore_2
</code></pre>
<p>同上，这里执行的是<code>int b = 20</code>操作。</p>
<pre><code>6: iload_1
7: iload_2
8: iadd
</code></pre>
<p>这里是将第二和第三个局部变量放到栈中，也就是取a和b的值到栈中，最后<code>iadd</code>操作将栈中的两个值相加，结果依然放在栈顶。</p>
<pre><code>9: istore_3
10: iload_3
11: ireturn
</code></pre>
<p>将栈顶数据存放到第四个局部变量中，也就是c，执行的是<code>int c = 30</code>，最后取出c的值放入栈顶，使用<code>ireturn</code>返回栈顶值，也就是方法的返回值。</p>
<p>至此，方法执行完毕。</p>
<p>实际上我们发现，JVM执行的命令基本都是入栈出栈等，而且大部分指令都是没有操作数的，传统的汇编指令有一操作数、二操作数甚至三操作数的指令，Java相比C编译出来的汇编指令，执行起来会更加复杂，实现某个功能的指令条数也会更多，所以Java的执行效率实际上是不如C/C++的，虽然能够很方便地实现跨平台，但是性能上大打折扣，所以在性能要求比较苛刻的Android上，采用的是定制版的JVM，并且是基于寄存器的指令集架构。此外，在某些情况下，我们还可以使用JNI机制来通过Java调用C/C++编写的程序以提升性能（也就是本地方法，使用到native关键字）</p>
<hr>
<h2 id="现在与未来">现在与未来</h2>
<p>随着时代的变迁，JVM的实现多种多样，而我们还要从最初的虚拟机说起。</p>
<h3 id="虚拟机的发展历程">虚拟机的发展历程</h3>
<p>在1996，Java1.0面世时，第一款商用虚拟机Sun Classic VM开始了它的使命，这款虚拟机提供了一个Java解释器，也就是将我们的class文件进行读取，最后像上面一样得到一条一条的命令，JVM再将指令依次执行。虽然这样的运行方式非常的简单易懂，但是它的效率实际上是很低的，就像你耳机里一边在放六级听力，你必须同时记在脑海里面然后等着问问题，再去选择问题的答案一样，更重要的是同样的代码每次都需要重新翻译再执行。</p>
<p>这个时候我们就需要更加高效的方式来运行Java程序，随着后面的发展，现在大多数的主流的JVM都包含即时<strong>编译器</strong>。JVM会根据当前代码的进行判断，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler）</p>
<figure data-type="image" tabindex="5"><img src="https://img2018.cnblogs.com/blog/955092/201911/955092-20191118100603404-2016014845.jpg" alt="img" loading="lazy"></figure>
<p>在JDK1.4时，Sun Classic VM完全退出了历史舞台，取而代之的是至今都在使用的HotSpot VM，它是目前使用最广泛的虚拟机，拥有上面所说的热点代码探测技术、准确式内存管理（虚拟机可以知道内存中某个位置的数据具体是什么类型）等技术，而我们之后的章节都是基于HotSpot虚拟机进行讲解。</p>
<h3 id="虚拟机发展的未来">虚拟机发展的未来</h3>
<p>2018年4月，Oracle Labs公开了最新的GraalVM，它是一种全新的虚拟机，它能够实现所有的语言统一运行在虚拟机中。</p>
<figure data-type="image" tabindex="6"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fatoracle.cn%2FUploads%2Fgraalvm%2Fgraalvm.png&amp;refer=http%3A%2F%2Fatoracle.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1646031057&amp;t=1cfa58c28f680c3f23eb85bde2d31e1f" alt="img" loading="lazy"></figure>
<p>Graal VM被官方称为“Universal VM”和“Polyglot VM”，这是一个在HotSpot虚拟机基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台使用，这里“任何语言”包括了Java、Scala、Groovy、Kotlin等基于Java虚拟机之上的语言，还包括了C、C++、Rust等基于LLVM的语言，同时支持其他像JavaScript、Ruby、Python和R语言等等。Graal VM可以无额外开销地混合使用这些编程语言，支持不同语言中混用对方的接口和对象，也能够支持这些语言使用已经编写好的本地库文件。</p>
<p>Graal VM的基本工作原理是将这些语言的源代码（例如JavaScript）或源代码编译后的中间格式（例如LLVM字节码）通过解释器转换为能被Graal VM接受的中间表示（Intermediate Representation，IR），譬如设计一个解释器专门对LLVM输出的字节码进行转换来支持C和C++语言，这个过程称为“程序特化”（Specialized，也常称为Partial Evaluation）。Graal VM提供了Truffle工具集来快速构建面向一种新语言的解释器，并用它构建了一个称为Sulong的高性能LLVM字节码解释器。</p>
<p>目前最新的SpringBoot已经提供了本地运行方案：https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/</p>
<blockquote>
<p>Spring Native支持使用<a href="https://www.graalvm.org/">GraalVM</a><a href="https://www.graalvm.org/reference-manual/native-image/">原生镜像</a>编译器将Spring应用程序编译为本机可执行文件。</p>
<p>与Java虚拟机相比，原生映像可以为许多类型的工作负载实现更简单、更加持续的托管。包括微服务、非常适合容器的功能工作负载和<a href="https://kubernetes.io/">Kubernetes</a></p>
<p>使用本机映像提供了关键优势，如即时启动、即时峰值性能和减少内存消耗。</p>
<p>GraalVM原生项目预计随着时间的推移会改进一些缺点和权衡。构建本机映像是一个比常规应用程序慢的繁重过程。热身后的本机映像运行时优化较少。最后，它不如JVM成熟，行为各不相同。</p>
<p>常规JVM和此原生映像平台的主要区别是：</p>
<ul>
<li>从主入口点对应用程序进行静态分析，在构建时进行。</li>
<li>未使用的部件将在构建时删除。</li>
<li>反射、资源和动态代理需要配置。</li>
<li>Classpath在构建时是固定的。</li>
<li>没有类惰性加载：可执行文件中运送的所有内容将在启动时加载到内存中。</li>
<li>一些代码将在构建时运行。</li>
<li>Java应用程序的某些方面有一些不受完全支持<a href="https://www.graalvm.org/reference-manual/native-image/Limitations/">的限制</a>。</li>
</ul>
<p>该项目的目标是孵化对Spring Native的支持，Spring Native是Spring JVM的替代品，并提供旨在打包在轻量级容器中的原生部署选项。在实践中，目标是在这个新平台上支持您的Spring应用程序，几乎未经修改。</p>
</blockquote>
<p>优点：</p>
<ol>
<li>立即启动，一般启动时间小于100ms</li>
<li>更低的内存消耗</li>
<li>独立部署，不再需要JVM</li>
<li>同样的峰值性能要比JVM消耗的内存小</li>
</ol>
<p>缺点：</p>
<ol>
<li>构建时间长</li>
<li>只支持新的Springboot版本（2.4.4+）</li>
</ol>
<hr>
<h2 id="手动编译jdk8">手动编译JDK8</h2>
<p>学习JVM最关键的是研究底层C/C++源码，我们首先需要搭建一个测试环境，方便我们之后对底层源码进行调试。但是编译这一步的坑特别多，请务必保证跟教程中的环境一致，尤其是编译环境，版本不能太高，因为JDK8属于比较早期的版本了，否则会遇到各种各样奇奇怪怪的问题。</p>
<h3 id="环境配置">环境配置</h3>
<ul>
<li>操作系统：Ubuntu 20.04 Server</li>
<li>硬件配置：i7-4790 4C8T/ 16G内存 / 128G硬盘 （不能用树莓派或是arm芯片Mac的虚拟机，配置越高越好，不然卡爆）</li>
<li>调试工具：Jetbrains Gateway（服务器运行CLion Backend程序，界面在Mac上显示）</li>
<li>OpenJDK源码：https://codeload.github.com/openjdk/jdk/zip/refs/tags/jdk8-b120</li>
<li>编译环境：
<ul>
<li>gcc-4.8</li>
<li>g++-4.8</li>
<li>make-3.81</li>
<li>openjdk-8</li>
</ul>
</li>
</ul>
<h3 id="开始折腾">开始折腾</h3>
<p>首选需要在我们的测试服务器上安装Ubuntu 20.04 Server系统，并通过ssh登录到服务器：</p>
<pre><code class="language-sh">Welcome to Ubuntu 20.04.3 LTS (GNU/Linux 5.4.0-96-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Sat 29 Jan 2022 10:33:03 AM UTC

  System load:  0.08               Processes:               156
  Usage of /:   5.5% of 108.05GB   Users logged in:         0
  Memory usage: 5%                 IPv4 address for enp2s0: 192.168.10.66
  Swap usage:   0%                 IPv4 address for enp2s0: 192.168.10.75
  Temperature:  32.0 C


37 updates can be applied immediately.
To see these additional updates run: apt list --upgradable


Last login: Sat Jan 29 10:27:06 2022
nagocoler@ubuntu-server:~$ 
</code></pre>
<p>先安装一些基本的依赖：</p>
<pre><code class="language-sh">sudo apt install build-essential libxrender-dev xorg-dev libasound2-dev libcups2-dev gawk zip libxtst-dev libxi-dev libxt-dev gobjc
</code></pre>
<p>接着我们先将JDK的编译环境配置好，首先是安装gcc和g++的4.8版本，但是最新的源没有这个版本了，我们先导入旧版软件源：</p>
<pre><code class="language-sh">sudo vim /etc/apt/sources.list
</code></pre>
<p>在最下方添加旧版源地址并保存：</p>
<pre><code>deb http://archive.ubuntu.com/ubuntu xenial main
deb http://archive.ubuntu.com/ubuntu xenial universe
</code></pre>
<p>接着更新一下apt源信息，并安装gcc和g++：</p>
<pre><code class="language-sh">sudo apt update
sudo apt install gcc-4.8 g++-4.8
</code></pre>
<p>接着配置：</p>
<pre><code class="language-sh">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 100
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.8 100
</code></pre>
<p>最后查看版本是否为4.8版本：</p>
<pre><code class="language-sh">nagocoler@ubuntu-server:~$ gcc --version
gcc (Ubuntu 4.8.5-4ubuntu2) 4.8.5
Copyright (C) 2015 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

nagocoler@ubuntu-server:~$ g++ --version
g++ (Ubuntu 4.8.5-4ubuntu2) 4.8.5
Copyright (C) 2015 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</code></pre>
<p>接着安装make 3.81版本，需要从官方下载：</p>
<pre><code class="language-sh">wget https://ftp.gnu.org/gnu/make/make-3.81.tar.gz
</code></pre>
<p>下载好之后进行解压，并进入目录：</p>
<pre><code class="language-sh">tar -zxvf make-3.81.tar.gz 
cd make-3.81/
</code></pre>
<p>接着我们修改一下代码，打开<code>glob/glob.c</code>文件：</p>
<pre><code class="language-c">...
#ifdef  HAVE_CONFIG_H
# include &lt;config.h&gt;
#endif

#define __alloca alloca   &lt;- 添加这一句
/* Enable GNU extensions 
...
</code></pre>
<p>接着进行配置并完成编译和安装：</p>
<pre><code class="language-sh">bash configure
sudo make install
</code></pre>
<p>安装完成后，将make已经变成3.81版本了：</p>
<pre><code class="language-sh">nagocoler@ubuntu-server:~/make-3.81$ make -verison
GNU Make 3.81
Copyright (C) 2006  Free Software Foundation, Inc.
This is free software; see the source for copying conditions.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.
</code></pre>
<p>由于JDK中某些代码是Java编写的，所以我们还需要安装一个启动JDK，启动JDK可以是当前版本或低一版本，比如我们要编译JDK8的源码，那么就可以使用JDK7、JDK8作为启动JDK，对源码中的一些java文件进行编译。这里我们选择安装OpenJDK8作为启动JDK：</p>
<pre><code class="language-sh">sudo apt install openjdk-8-jdk
</code></pre>
<p>这样，我们的系统环境就准备完成了，接着我们需要下载OpenJDK8的源码（已经放在网盘了）解压：</p>
<pre><code class="language-sh">unzip jdk-jdk8-b120.zip
</code></pre>
<p>接着我们需要安装JetBrains Gateway在我们的服务器上导入项目，这里我们使用CLion后端，等待下载远程后端，这样我们的Linux服务器上虽然没有图形化界面，但是依然可以使用IDEA、CLion等工具，只是服务器上只有后端程序，而界面由我们电脑上的前端程序提供（目前此功能还在Beta阶段，暂不支持arm架构的Linux服务器）整个过程根据服务器配置决定可能需要5-20分钟。</p>
<p>完成之后，我们操作起来就很方便了，界面和IDEA其实差不多，我们打开终端，开始进行配置：</p>
<pre><code class="language-sh">bash configure --with-debug-level=slowdebug --enable-debug-symbols ZIP_DEBUGINFO_FIELS=0
</code></pre>
<p>配置完成后，再次确认是否和教程中的配置信息一致：</p>
<pre><code>Configuration summary:
* Debug level:    slowdebug
* JDK variant:    normal
* JVM variants:   server
* OpenJDK target: OS: linux, CPU architecture: x86, address length: 64

Tools summary:
* Boot JDK:       openjdk version &quot;1.8.0_312&quot; OpenJDK Runtime Environment (build 1.8.0_312-8u312-b07-0ubuntu1~20.04-b07) OpenJDK 64-Bit Server VM (build 25.312-b07, mixed mode)  (at /usr/lib/jvm/java-8-openjdk-amd64)
* C Compiler:     gcc-4.8 (Ubuntu 4.8.5-4ubuntu2) version 4.8.5 (at /usr/bin/gcc-4.8)
* C++ Compiler:   g++-4.8 (Ubuntu 4.8.5-4ubuntu2) version 4.8.5 (at /usr/bin/g++-4.8)

Build performance summary:
* Cores to use:   3
* Memory limit:   3824 MB
* ccache status:  not installed (consider installing)

WARNING: The result of this configuration has overridden an older
configuration. You *should* run 'make clean' to make sure you get a
proper build. Failure to do so might result in strange build problems.
</code></pre>
<p>接着我们需要修改几个文件，不然一会会编译失败，首先是<code>hotspot/make/linux/Makefile</code>文件：</p>
<pre><code>原有的 SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 3%
修改为 SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 3% 4% 5%
</code></pre>
<p>接着是<code>hotspot/make/linux/makefiles/gcc.make</code>文件：</p>
<pre><code>原有的 WARNINGS_ARE_ERRORS = -Werror
修改为 #WARNINGS_ARE_ERRORS = -Werror
</code></pre>
<p>接着是<code>nashorn/make/BuildNashorn.gmk</code>文件：</p>
<pre><code>  $(CP) -R -p $(NASHORN_OUTPUTDIR)/nashorn_classes/* $(@D)/
  $(FIXPATH) $(JAVA) \
原有的 -cp &quot;$(NASHORN_OUTPUTDIR)/nasgen_classes$(PATH_SEP)$(NASHORN_OUTPUTDIR)/nashorn_classes&quot; \
修改为  -Xbootclasspath/p:&quot;$(NASHORN_OUTPUTDIR)/nasgen_classes$(PATH_SEP)$(NASHORN_OUTPUTDIR)/nashorn_classes&quot; \
   jdk.nashorn.internal.tools.nasgen.Main $(@D) jdk.nashorn.internal.objects $(@D)
</code></pre>
<p>OK，修改完成，接着我们就可以开始编译了：</p>
<pre><code>make all
</code></pre>
<p>整个编译过程大概需要持续10-20分钟，请耐心等待。构建完成后提示：</p>
<pre><code>----- Build times -------
Start 2022-01-29 11:36:35
End   2022-01-29 11:48:20
00:00:30 corba
00:00:25 demos
00:02:39 docs
00:03:05 hotspot
00:00:27 images
00:00:17 jaxp
00:00:31 jaxws
00:03:02 jdk
00:00:38 langtools
00:00:11 nashorn
00:11:45 TOTAL
-------------------------
Finished building OpenJDK for target 'all'
</code></pre>
<p>只要按照我们的教程一步步走，别漏了，应该是直接可以完成的，当然难免可能有的同学出现了奇奇怪怪的问题，加油，慢慢折腾，总会成功的~</p>
<p>接着我们就可以创建一个测试配置了，首先打开设置页面，找到<code>自定义构建目标</code>：</p>
<figure data-type="image" tabindex="7"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyux37s99nj31b80u076s.jpg" alt="image-20220129195318339" loading="lazy"></figure>
<p>点击<code>应用</code>即可，接着打开运行配置，添加一个新的自定义配置：</p>
<figure data-type="image" tabindex="8"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyux3axcknj31ai0u0wgy.jpg" alt="image-20220129195459914" loading="lazy"></figure>
<p>选择我们编译完成的java程序，然后测试-version查看版本信息，去掉下方的构建。</p>
<p>接着直接运行即可：</p>
<pre><code>/home/nagocoler/jdk-jdk8-b120/build/linux-x86_64-normal-server-slowdebug/jdk/bin/java -version
openjdk version &quot;1.8.0-internal-debug&quot;
OpenJDK Runtime Environment (build 1.8.0-internal-debug-nagocoler_2022_01_29_11_36-b00)
OpenJDK 64-Bit Server VM (build 25.0-b62-debug, mixed mode)

Process finished with exit code 0
</code></pre>
<p>我们可以将工作目录修改到其他地方，接着我们创建一个Java文件并完成编译，然后测试能否使用我们编译的JDK运行：</p>
<figure data-type="image" tabindex="9"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyux3dp9bsj31ai0u0wh5.jpg" alt="image-20220129195801789" loading="lazy"></figure>
<p>在此目录下编写一个Java程序，然后编译：</p>
<pre><code class="language-java">public class Main{
        public static void main(String[] args){
                System.out.println(&quot;Hello World!&quot;);
        }       
}       
</code></pre>
<pre><code class="language-sh">nagocoler@ubuntu-server:~$ cd JavaHelloWorld/
nagocoler@ubuntu-server:~/JavaHelloWorld$ vim Main.java
nagocoler@ubuntu-server:~/JavaHelloWorld$ javac Main.java 
nagocoler@ubuntu-server:~/JavaHelloWorld$ ls
Main.class  Main.java
</code></pre>
<p>点击运行，成功得到结果：</p>
<pre><code>/home/nagocoler/jdk-jdk8-b120/build/linux-x86_64-normal-server-slowdebug/jdk/bin/java Main
Hello World!

Process finished with exit code 0
</code></pre>
<p>我们还可以在CLion前端页面中进行断点调试，比如我们测试一个入口点JavaMain，在<code>jdk/src/share/bin/java.c</code>中的JavaMain方法：</p>
<figure data-type="image" tabindex="10"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyux47wgp9j31z00sc0xc.jpg" alt="image-20220129200244279" loading="lazy"></figure>
<p>点击右上角调试按钮，可以成功进行调试：</p>
<figure data-type="image" tabindex="11"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyux4lmirkj31mk0u0gq2.jpg" alt="image-20220129200314691" loading="lazy"></figure>
<p>至此，在Ubuntu系统上手动编译OpenJDK8完成。</p>
<hr>
<h2 id="jvm启动流程探究">JVM启动流程探究</h2>
<p>前面我们完成了JDK8的编译，也了解了如何进行断点调试，现在我们就可以来研究一下JVM的启动流程了，首先我们要明确，虚拟机的启动入口位于<code>jdk/src/share/bin/java.c</code>的<code>JLI_Launch</code>函数，整个流程分为如下几个步骤：</p>
<ol>
<li>配置JVM装载环境</li>
<li>解析虚拟机参数</li>
<li>设置线程栈大小</li>
<li>执行JavaMain方法</li>
</ol>
<p>首先我们来看看<code>JLI_Launch</code>函数是如何定义的：</p>
<pre><code class="language-c">int
JLI_Launch(int argc, char ** argv,              /* main argc, argc */
        int jargc, const char** jargv,          /* java args */
        int appclassc, const char** appclassv,  /* app classpath */
        const char* fullversion,                /* full version defined */
        const char* dotversion,                 /* dot version defined */
        const char* pname,                      /* program name */
        const char* lname,                      /* launcher name */
        jboolean javaargs,                      /* JAVA_ARGS */
        jboolean cpwildcard,                    /* classpath wildcard */
        jboolean javaw,                         /* windows-only javaw */
        jint     ergo_class                     /* ergnomics policy */
);
</code></pre>
<p>可以看到在入口点的参数有很多个，其中包括当前的完整版本名称、简短版本名称、运行参数、程序名称、启动器名称等。</p>
<p>首先会进行一些初始化操作以及Debug信息打印配置等：</p>
<pre><code class="language-c">InitLauncher(javaw);
DumpState();
if (JLI_IsTraceLauncher()) {
    int i;
    printf(&quot;Command line args:\n&quot;);
    for (i = 0; i &lt; argc ; i++) {
        printf(&quot;argv[%d] = %s\n&quot;, i, argv[i]);
    }
    AddOption(&quot;-Dsun.java.launcher.diag=true&quot;, NULL);
}
</code></pre>
<p>接着就是选择一个合适的JRE版本：</p>
<pre><code class="language-c">/*
 * Make sure the specified version of the JRE is running.
 *
 * There are three things to note about the SelectVersion() routine:
 *  1) If the version running isn't correct, this routine doesn't
 *     return (either the correct version has been exec'd or an error
 *     was issued).
 *  2) Argc and Argv in this scope are *not* altered by this routine.
 *     It is the responsibility of subsequent code to ignore the
 *     arguments handled by this routine.
 *  3) As a side-effect, the variable &quot;main_class&quot; is guaranteed to
 *     be set (if it should ever be set).  This isn't exactly the
 *     poster child for structured programming, but it is a small
 *     price to pay for not processing a jar file operand twice.
 *     (Note: This side effect has been disabled.  See comment on
 *     bugid 5030265 below.)
 */
SelectVersion(argc, argv, &amp;main_class);
</code></pre>
<p>接着是创建JVM执行环境，例如需要确定数据模型，是32位还是64位，以及jvm本身的一些配置在jvm.cfg文件中读取和解析：</p>
<pre><code class="language-c">CreateExecutionEnvironment(&amp;argc, &amp;argv,
                               jrepath, sizeof(jrepath),
                               jvmpath, sizeof(jvmpath),
                               jvmcfg,  sizeof(jvmcfg));
</code></pre>
<p>此函数只在头文件中定义，具体的实现是根据不同平台而定的。接着会动态加载jvm.so这个共享库，并把jvm.so中的相关函数导出并且初始化，而启动JVM的函数也在其中：</p>
<pre><code class="language-c">if (!LoadJavaVM(jvmpath, &amp;ifn)) {
    return(6);
}
</code></pre>
<p>比如mac平台下的实现：</p>
<pre><code class="language-c">jboolean
LoadJavaVM(const char *jvmpath, InvocationFunctions *ifn)
{
    Dl_info dlinfo;
    void *libjvm;

    JLI_TraceLauncher(&quot;JVM path is %s\n&quot;, jvmpath);

    libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);
    if (libjvm == NULL) {
        JLI_ReportErrorMessage(DLL_ERROR1, __LINE__);
        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());
        return JNI_FALSE;
    }

    ifn-&gt;CreateJavaVM = (CreateJavaVM_t)
        dlsym(libjvm, &quot;JNI_CreateJavaVM&quot;);
    if (ifn-&gt;CreateJavaVM == NULL) {
        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());
        return JNI_FALSE;
    }

    ifn-&gt;GetDefaultJavaVMInitArgs = (GetDefaultJavaVMInitArgs_t)
        dlsym(libjvm, &quot;JNI_GetDefaultJavaVMInitArgs&quot;);
    if (ifn-&gt;GetDefaultJavaVMInitArgs == NULL) {
        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());
        return JNI_FALSE;
    }

    ifn-&gt;GetCreatedJavaVMs = (GetCreatedJavaVMs_t)
    dlsym(libjvm, &quot;JNI_GetCreatedJavaVMs&quot;);
    if (ifn-&gt;GetCreatedJavaVMs == NULL) {
        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());
        return JNI_FALSE;
    }

    return JNI_TRUE;
}
</code></pre>
<p>最后就是对JVM进行初始化了：</p>
<pre><code class="language-c">return JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);
</code></pre>
<p>这也是由平台决定的，比如Mac下的实现为：</p>
<pre><code class="language-c">int
JVMInit(InvocationFunctions* ifn, jlong threadStackSize,
                 int argc, char **argv,
                 int mode, char *what, int ret) {
    if (sameThread) {
        //无需关心....
    } else {
      	//正常情况下走这个
        return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);
    }
}
</code></pre>
<p>可以看到最后进入了一个<code>ContinueInNewThread</code>函数（在刚刚的<code>java.c</code>中实现），这个函数会创建一个新的线程来执行：</p>
<pre><code class="language-c">int
ContinueInNewThread(InvocationFunctions* ifn, jlong threadStackSize,
                    int argc, char **argv,
                    int mode, char *what, int ret)
{

    ...

      rslt = ContinueInNewThread0(JavaMain, threadStackSize, (void*)&amp;args);
      /* If the caller has deemed there is an error we
       * simply return that, otherwise we return the value of
       * the callee
       */
      return (ret != 0) ? ret : rslt;
    }
}
</code></pre>
<p>接着进入了一个名为<code>ContinueInNewThread0</code>的函数，可以看到它将<code>JavaMain</code>函数传入作为参数，而此函数定义的第一个参数类型是一个函数指针：</p>
<pre><code class="language-c">int
ContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args) {
    int rslt;
    pthread_t tid;
    pthread_attr_t attr;
    pthread_attr_init(&amp;attr);
    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);

    if (stack_size &gt; 0) {
      pthread_attr_setstacksize(&amp;attr, stack_size);
    }

    if (pthread_create(&amp;tid, &amp;attr, (void *(*)(void*))continuation, (void*)args) == 0) {
      void * tmp;
      pthread_join(tid, &amp;tmp);
      rslt = (int)tmp;
    } else {
     /*
      * Continue execution in current thread if for some reason (e.g. out of
      * memory/LWP)  a new thread can't be created. This will likely fail
      * later in continuation as JNI_CreateJavaVM needs to create quite a
      * few new threads, anyway, just give it a try..
      */
      rslt = continuation(args);
    }

    pthread_attr_destroy(&amp;attr);
    return rslt;
}
</code></pre>
<p>最后实际上是在新的线程中执行<code>JavaMain</code>函数，最后我们再来看看此函数里面做了什么事情：</p>
<pre><code class="language-c">/* Initialize the virtual machine */
start = CounterGet();
if (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) {
    JLI_ReportErrorMessage(JVM_ERROR1);
    exit(1);
}
</code></pre>
<p>第一步初始化虚拟机，如果报错直接退出。接着就是加载主类（至于具体如何加载一个类，我们会放在后面进行讲解），因为主类是我们Java程序的入口点：</p>
<pre><code class="language-c">/*
 * Get the application's main class.
 *
 * See bugid 5030265.  The Main-Class name has already been parsed
 * from the manifest, but not parsed properly for UTF-8 support.
 * Hence the code here ignores the value previously extracted and
 * uses the pre-existing code to reextract the value.  This is
 * possibly an end of release cycle expedient.  However, it has
 * also been discovered that passing some character sets through
 * the environment has &quot;strange&quot; behavior on some variants of
 * Windows.  Hence, maybe the manifest parsing code local to the
 * launcher should never be enhanced.
 *
 * Hence, future work should either:
 *     1)   Correct the local parsing code and verify that the
 *          Main-Class attribute gets properly passed through
 *          all environments,
 *     2)   Remove the vestages of maintaining main_class through
 *          the environment (and remove these comments).
 *
 * This method also correctly handles launching existing JavaFX
 * applications that may or may not have a Main-Class manifest entry.
 */
mainClass = LoadMainClass(env, mode, what);
</code></pre>
<p>某些没有主方法的Java程序比如JavaFX应用，会获取ApplicationMainClass：</p>
<pre><code class="language-c">/*
 * In some cases when launching an application that needs a helper, e.g., a
 * JavaFX application with no main method, the mainClass will not be the
 * applications own main class but rather a helper class. To keep things
 * consistent in the UI we need to track and report the application main class.
 */
appClass = GetApplicationClass(env);
</code></pre>
<p>初始化完成：</p>
<pre><code class="language-c">/*
 * PostJVMInit uses the class name as the application name for GUI purposes,
 * for example, on OSX this sets the application name in the menu bar for
 * both SWT and JavaFX. So we'll pass the actual application class here
 * instead of mainClass as that may be a launcher or helper class instead
 * of the application class.
 */
PostJVMInit(env, appClass, vm);
</code></pre>
<p>接着就是获取主类中的主方法：</p>
<pre><code class="language-java">/*
 * The LoadMainClass not only loads the main class, it will also ensure
 * that the main method's signature is correct, therefore further checking
 * is not required. The main method is invoked here so that extraneous java
 * stacks are not in the application stack trace.
 */
mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, &quot;main&quot;,
                                   &quot;([Ljava/lang/String;)V&quot;);
</code></pre>
<p>没错，在字节码中<code>void main(String[] args)</code>表示为<code>([Ljava/lang/String;)V</code>我们之后会详细介绍。接着就是调用主方法了：</p>
<pre><code class="language-c">/* Invoke main method. */
(*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);
</code></pre>
<p>调用后，我们的Java程序就开飞速运行起来，直到走到主方法的最后一行返回：</p>
<pre><code class="language-c">/*
 * The launcher's exit code (in the absence of calls to
 * System.exit) will be non-zero if main threw an exception.
 */
ret = (*env)-&gt;ExceptionOccurred(env) == NULL ? 0 : 1;
LEAVE();
</code></pre>
<p>至此，一个Java程序的运行流程结束，在最后LEAVE函数中会销毁JVM。我们可以进行断点调试来查看是否和我们推出的结论一致：</p>
<figure data-type="image" tabindex="12"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyux4uqcxpj31sr0u0td4.jpg" alt="image-20220129211342240" loading="lazy"></figure>
<p>还是以我们之前编写的测试类进行，首先来到调用之前，我们看到主方法执行之前，控制台没有输出任何内容，接着我们执行此函数，再来观察控制台的变化：</p>
<figure data-type="image" tabindex="13"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyux4w5322j31zt0u0afp.jpg" alt="image-20220129211450939" loading="lazy"></figure>
<p>可以看到，主方法执行完成之后，控制台也成功输出了Hello World！</p>
<p>继续下一步，整个Java程序执行完成，得到退出状态码<code>0</code>：</p>
<figure data-type="image" tabindex="14"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyux4ydghaj31bk0eimy7.jpg" alt="image-20220129211540210" loading="lazy"></figure>
<p>成功验证，最后总结一下整个执行过程：</p>
<figure data-type="image" tabindex="15"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyux50ahdrj31d30u0tdu.jpg" alt="image-20220129213143973" loading="lazy"></figure>
<hr>
<h2 id="jni调用本地方法">JNI调用本地方法</h2>
<p>Java还有一个JNI机制，它的全称：Java Native Interface，即Java本地接口。它允许在Java虚拟机内运行的Java代码与其他编程语言（如C/C++和汇编语言）编写的程序和库进行交互（在Android开发中用得比较多）比如我们现在想要让C语言程序帮助我们的Java程序实现a+b的运算，首先我们需要创建一个本地方法：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        System.out.println(sum(1, 2));
    }

    //本地方法使用native关键字标记，无需任何实现，交给C语言实现
    public static native int sum(int a, int b);
}
</code></pre>
<p>创建好后，接着点击构建按钮，会出现一个out文件夹，也就是生成的class文件在其中，接着我们直接生成对应的C头文件：</p>
<pre><code class="language-sh">javah -classpath out/production/SimpleHelloWorld -d ./jni com.test.Main
</code></pre>
<p>生成的头文件位于jni文件夹下：</p>
<pre><code class="language-c">/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class com_test_Main */

#ifndef _Included_com_test_Main
#define _Included_com_test_Main
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
/*
 * Class:     com_test_Main
 * Method:    sum
 * Signature: (II)V
 */
JNIEXPORT void JNICALL Java_com_test_Main_sum
  (JNIEnv *, jclass, jint, jint);

#ifdef __cplusplus
}
#endif
#endif
</code></pre>
<p>接着我们在CLion中新建一个C++项目，并引入刚刚生成的头文件，并导入jni相关头文件（在JDK文件夹中）首先修改CMake文件：</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.21)
project(JNITest)

include_directories(/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/include)
include_directories(/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/include/darwin)
set(CMAKE_CXX_STANDARD 14)

add_executable(JNITest com_test_Main.cpp com_test_Main.h)
</code></pre>
<p>接着就可以编写实现了，首先认识一下引用类型对照表：</p>
<figure data-type="image" tabindex="16"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyux540wn7j30xc0h1q47.jpg" alt="img" loading="lazy"></figure>
<p>所以我们这里直接返回a+b即可：</p>
<pre><code class="language-cpp">#include &quot;com_test_Main.h&quot;

JNIEXPORT jint JNICALL Java_com_test_Main_sum
        (JNIEnv * env, jclass clazz, jint a, jint b){
    return a + b;
}
</code></pre>
<p>接着我们就可以将cpp编译为动态链接库，在MacOS下会生成<code>.dylib</code>文件，Windows下会生成<code>.dll</code>文件，我们这里就只以MacOS为例，命令有点长，因为还需要包含JDK目录下的头文件：</p>
<pre><code class="language-sh">gcc com_test_Main.cpp -I /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/include -I /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/include/darwin -fPIC -shared -o test.dylib -lstdc++
</code></pre>
<p>编译完成后，得到<code>test.dylib</code>文件，这就是动态链接库了。</p>
<p>最后我们再将其放到桌面，然后在Java程序中加载：</p>
<pre><code class="language-java">public class Main {
    static {
        System.load(&quot;/Users/nagocoler/Desktop/test.dylib&quot;);
    }

    public static void main(String[] args) {
        System.out.println(sum(1, 2));
    }

    public static native int sum(int a, int b);
}
</code></pre>
<p>运行，成功得到结果：</p>
<figure data-type="image" tabindex="17"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyux58pg32j31ag0smjv5.jpg" alt="image-20220129222858105" loading="lazy"></figure>
<p>通过了解JVM的一些基础知识，我们心目中大致有了一个JVM的模型，在下一章，我们将继续深入学习JVM的内存管理机制和垃圾收集器机制，以及一些实用工具。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM笔记（三）]]></title>
        <id>https://muouren7.github.io/post/JVM笔记（三）/</id>
        <link href="https://muouren7.github.io/post/JVM笔记（三）/">
        </link>
        <updated>2022-10-14T08:06:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="类与类加载">类与类加载</h1>
<p>前面我们讲解了JVM的内存结构，包括JVM如何对内存进行划分，如何对内存区域进行垃圾回收。接下来，我们来研究一下类文件结构以及类的加载机制。</p>
<h2 id="类文件结构">类文件结构</h2>
<p>在我们学习C语言的时候，我们的编程过程会经历如下几个阶段：写代码、保存、编译、运行。实际上，最关键的一步是编译，因为只有经历了编译之后，我们所编写的代码才能够翻译为机器可以直接运行的二进制代码，并且在不同的操作系统下，我们的代码都需要进行一次编译之后才能运行。</p>
<blockquote>
<p>如果全世界所有的计算机指令集只有x86一种，操作系统只有Windows一种，那也许就不会有Java语言的出现。</p>
</blockquote>
<p>随着时代的发展，人们迫切希望能够在不同的操作系统、不同的计算机架构中运行同一套编译之后的代码。本地代码不应该是我们编程的唯一选择，所以，越来越多的语言选择了与操作系统和机器指令集无关的中立格式作为编译后的存储格式。</p>
<p>“一次编写，到处运行”，Java最引以为傲的口号，标志着平台不再是限制编程语言的阻碍。</p>
<p>实际上，Java正式利用了这样的解决方案，将源代码编译为平台无关的中间格式，并通过对应的Java虚拟机读取和运行这些中间格式的编译文件，这样，我们只需要考虑不同平台的虚拟机如何编写，而Java语言本身很轻松地实现了跨平台。</p>
<p>现在，越来越多的开发语言都支持将源代码编译为<code>.class</code>字节码文件格式，以便能够直接交给JVM运行，包括Kotlin（安卓开发官方指定语言）、Groovy、Scala等。</p>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gznizn2l97j21qc0jedgq.jpg" alt="image-20220223162914535" loading="lazy"></figure>
<p>那么，让我们来看看，我们的源代码编译之后，是如何保存在字节码文件中的。</p>
<hr>
<h3 id="类文件信息">类文件信息</h3>
<p>我们之前都是使用<code>javap</code>命令来对字节码文件进行反编译查看的，那么，它以二进制格式是怎么保存呢？我们可以使用WinHex软件（Mac平台可以使用<a href="https://www.macwk.com/soft/010-editor">010 Editor</a>）来以十六进制查看字节码文件。</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        int i = 10;
        int a = i++;
        int b = ++i;
    }
}
</code></pre>
<p>找到我们在IDEA中编译出来的class文件，将其拖动进去：</p>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gznjij4fgpj21800u011h.jpg" alt="image-20220223164725971" loading="lazy"></figure>
<p>可以看到整个文件中，全是一个字节一个字节分组的样子，从左上角开始，一行一行向下读取。可以看到在右侧中还出现了一些我们之前也许见过的字符串，比如&quot;<init>&quot;、&quot;Object&quot;等。</p>
<p>实际上Class文件采用了一种类似于C中结构体的伪结构来存储数据（当然我们直接看是看不出来的），但是如果像这样呢？</p>
<pre><code>Classfile /Users/nagocoler/Develop.localized/JavaHelloWorld/target/classes/com/test/Main.class
  Last modified 2022-2-23; size 444 bytes
  MD5 checksum 8af3e63f57bcb5e3d0eec4b0468de35b
  Compiled from &quot;Main.java&quot;
public class com.test.Main
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #3.#21         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Class              #22            // com/test/Main
   #3 = Class              #23            // java/lang/Object
   #4 = Utf8               &lt;init&gt;
   #5 = Utf8               ()V
   #6 = Utf8               Code
   #7 = Utf8               LineNumberTable
   #8 = Utf8               LocalVariableTable
   #9 = Utf8               this
  #10 = Utf8               Lcom/test/Main;
  #11 = Utf8               main
  #12 = Utf8               ([Ljava/lang/String;)V
  #13 = Utf8               args
  #14 = Utf8               [Ljava/lang/String;
  #15 = Utf8               i
  #16 = Utf8               I
  #17 = Utf8               a
  #18 = Utf8               b
  #19 = Utf8               SourceFile
  #20 = Utf8               Main.java
  #21 = NameAndType        #4:#5          // &quot;&lt;init&gt;&quot;:()V
  #22 = Utf8               com/test/Main
  #23 = Utf8               java/lang/Object
{
  public com.test.Main();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 11: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/test/Main;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=4, args_size=1
         0: bipush        10
         2: istore_1
         3: iload_1
         4: iinc          1, 1
         7: istore_2
         8: iinc          1, 1
        11: iload_1
        12: istore_3
        13: return
      LineNumberTable:
        line 13: 0
        line 14: 3
        line 15: 8
        line 16: 13
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      14     0  args   [Ljava/lang/String;
            3      11     1     i   I
            8       6     2     a   I
           13       1     3     b   I
}
SourceFile: &quot;Main.java&quot;
</code></pre>
<p>乍一看，是不是感觉还真的有点结构体那味？</p>
<p>而结构体中，有两种允许存在的数据类型，一个是无符号数，还有一个是表。</p>
<ul>
<li>无符号数一般是基本数据类型，用u1、u2、u4、u8来表示，表示1个字节~8个字节的无符号数。可以表示数字、索引引用、数量值或是以UTF-8编码格式的字符串。</li>
<li>表包含多个无符号数，并且以&quot;_info&quot;结尾。</li>
</ul>
<p>我们首先从最简的开始看起。</p>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gznjcb9bipj21ro0iutfs.jpg" alt="image-20220223164126100" loading="lazy"></figure>
<p>首先，我们可以看到，前4个字节（共32位）组成了魔数（其实就是表示这个文件是一个JVM可以运行的字节码文件，除了Java以外，其他某些文件中也采用了这种魔数机制来进行区分，这种方式比直接起个文件扩展名更安全）</p>
<p>字节码文件的魔数为：CAFEBABE（这名字能想出来也是挺难的了，毕竟4个bit位只能表示出A-F这几个字母）</p>
<p>紧接着魔数的后面4个字节存储的是字节码文件的版本号，注意前两个是次要版本号（现在基本都不用了，都是直接Java8、Java9这样命名了），后面两个是主要版本号，这里我们主要看主版本号，比如上面的就是34，注意这是以16进制表示的，我们把它换算为10进制后，得到的结果为：<code>34  -&gt;  3*16 + 4 = 52</code>，其中<code>52</code>代表的是<code>JDK8</code>编译的字节码文件（51是JDK7、50是JDK6、53是JDK9，以此类推）</p>
<p>JVM会根据版本号决定是否能够运行，比如JDK6只能支持版本号为1.1<sub>6的版本，也就是说必须是Java6之前的环境编译出来的字节码文件，否则无法运行。又比如我们现在安装的是JDK8版本，它能够支持的版本号为1.1</sub>8，那么如果这时我们有一个通过Java7编译出来的字节码文件，依然是可以运行的，所以说Java版本是向下兼容的。</p>
<p>紧接着，就是类的常量池了，这里面存放了类中所有的常量信息（注意这里的常量并不是指我们手动创建的final类型常量，而是程序运行一些需要用到的常量数据，比如字面量和符号引用等）由于常量的数量不是确定的，所以在最开始的位置会存放常量池中常量的数量（是从1开始计算的，不是0，比如这里是18，翻译为10进制就是24，所以实际上有23个常量）</p>
<p>接着再往下，就是常量池里面的数据了，每一项常量池里面的数据都是一个表，我们可以看到他们都是以_info结尾的：</p>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gznkh0jr31j21800u07dm.jpg" alt="image-20220223171746645" loading="lazy"></figure>
<p>我们来看看一个表中定义了哪些内容：</p>
<figure data-type="image" tabindex="5"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gznkh14d4rj21b805wt9v.jpg" alt="image-20220223172031889" loading="lazy"></figure>
<p>首先上来就会有一个1字节的无符号数，它用于表示当前常量的类型（常量类型有很多个）这里只列举一部分的类型介绍：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">标志</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CONSTANT_Utf8_info</td>
<td style="text-align:center">1</td>
<td style="text-align:center">UTF-8编码格式的字符串</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Integer_info</td>
<td style="text-align:center">3</td>
<td style="text-align:center">整形字面量（第一章我们演示的很大的数字，实际上就是以字面量存储在常量池中的）</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Class_info</td>
<td style="text-align:center">7</td>
<td style="text-align:center">类或接口的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_String_info</td>
<td style="text-align:center">8</td>
<td style="text-align:center">字符串类型的字面量</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Fieldref_info</td>
<td style="text-align:center">9</td>
<td style="text-align:center">字段的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_Methodref_info</td>
<td style="text-align:center">10</td>
<td style="text-align:center">方法的符号引用</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_MethodType_info</td>
<td style="text-align:center">16</td>
<td style="text-align:center">方法类型</td>
</tr>
<tr>
<td style="text-align:center">CONSTANT_NameAndType_info</td>
<td style="text-align:center">12</td>
<td style="text-align:center">字段或方法的部分符号引用</td>
</tr>
</tbody>
</table>
<p>实际上这些东西，虽然我们不知道符号引用是什么东西，我们可以观察出来，这些东西或多或少都是存放类中一些名称、数据之类的东西。</p>
<p>比如我们来看第一个<code>CONSTANT_Methodref_info</code>表中存放了什么数据，这里我只列出它的结构表（详细的结构表可以查阅《深入理解Java虚拟机 第三版》中222页总表）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">常量</th>
<th style="text-align:center">项目</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CONSTANT_Methodref_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">值为10</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">指向声明方法的类描述父CONSTANT_Class_info索引项</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">指向名称及类型描述符CONSTANT_NameAndType_info索引项</td>
</tr>
</tbody>
</table>
<p>比如我们刚刚的例子中：</p>
<figure data-type="image" tabindex="6"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznnkpf7cqj21b40503zi.jpg" alt="image-20220223190659053" loading="lazy"></figure>
<p>可以看到，第一个索引项指向了第3号常量，我们来看看三号常量：</p>
<figure data-type="image" tabindex="7"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznnmsuh1pj219w03amxj.jpg" alt="image-20220223190957382" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:center">常量</th>
<th style="text-align:center">项目</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CONSTANT_Class_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">值为7</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">指向全限定名常量项的索引</td>
</tr>
</tbody>
</table>
<p>那么我们接着来看23号常量又写的啥：</p>
<figure data-type="image" tabindex="8"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznnqfknqaj21fo0j6te5.jpg" alt="image-20220223191325689" loading="lazy"></figure>
<p>可以看到指向的UTF-8字符串值为<code>java/lang/Object</code>这下搞明白了，首先这个方法是由Object类定义的，那么接着我们来看第二项u2 <code>name_and_type_index</code>，指向了21号常量，也就是字段或方法的部分符号引用：</p>
<figure data-type="image" tabindex="9"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzno0zakf9j21eg0qyqbl.jpg" alt="image-20220223191921550" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:center">常量</th>
<th style="text-align:center">项目</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CONSTANT_NameAndType_info</td>
<td style="text-align:center">tag</td>
<td style="text-align:center">u1</td>
<td style="text-align:center">值为12</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">指向字段或方法名称常量项的索引</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">index</td>
<td style="text-align:center">u2</td>
<td style="text-align:center">指向字段或方法描述符常量项的索引</td>
</tr>
</tbody>
</table>
<p>其中第一个索引就是方法的名称，而第二个就是方法的描述符，描述符明确了方法的参数以及返回值类型，我们分别来看看4号和5号常量：</p>
<figure data-type="image" tabindex="10"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzno0z1yp1j21eg0qyqbl.jpg" alt="image-20220223192332068" loading="lazy"></figure>
<p>可以看到，方法名称为&quot;<init>&quot;，一般构造方法的名称都是<init>，普通方法名称是什么就是什么，方法描述符为&quot;()V&quot;，表示此方法没有任何参数，并且返回值类型为void，描述符对照表如下：</p>
<figure data-type="image" tabindex="11"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzno2stssaj216i08mjsr.jpg" alt="image-20220223192518999" loading="lazy"></figure>
<p>比如这里有一个方法<code>public int test(double a, char c){ ... }</code>，那么它的描述符就应该是：<code>(DC)I</code>，参数依次放入括号中，括号右边是返回值类型。再比如<code>public String test(Object obj){ ... }</code>，那么它的描述符就应该是：<code>(Ljava/lang/Object;)Ljava/lang/String</code>，注意如果参数是对象类型，那么必须在后面添加<code>;</code></p>
<p>对于数组类型，只需要在类型最前面加上<code>[</code>即可，有几个维度，就加几个，比如<code>public void test(int[][] arr)</code>，参数是一个二维int类型数组，那么它的描述符为：<code>([[I)V</code></p>
<p>所以，这里表示的，实际上就是此方法是一个无参构造方法，并且是属于Object类的。那么，为什么这里需要Object类构造方法的符号引用呢？还记得我们在JavaSE中说到的，每个类都是直接或间接继承自Object类，所有类的构造方法，必须先调用父类的构造方法，但是如果父类存在无参构造，默认可以不用显示调用<code>super</code>关键字（当然本质上是调用了的）。</p>
<p>所以说，当前类因为没有继承自任何其他类，那么就默认继承的Object类，所以，在当前类的默认构造方法中，调用了父类Object类的无参构造方法，因此这里需要符号引用的用途显而易见，就是因为需要调用Object类的无参构造方法。</p>
<p>我们可以在反编译结果中的方法中看到：</p>
<pre><code>public com.test.Main();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 11: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/test/Main;
</code></pre>
<p>其中<code>invokespecial</code>（调用父类构造方法）指令的参数指向了1号常量，而1号常量正是代表的Object类的无参构造方法，虽然饶了这么大一圈，但是过程理清楚，还是很简单的。</p>
<p>虽然我们可以直接查看16进制的结果，但是还是不够方便，但是我们也不能每次都去使用<code>javap</code>命令，所以我们这里安装一个IDEA插件，来方便我们查看字节码中的信息，名称为<code>jclasslib Bytecode Viewer</code> ：</p>
<figure data-type="image" tabindex="12"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznojlqgl3j216y0dc0u0.jpg" alt="image-20220223194128297" loading="lazy"></figure>
<p>安装完成后，我们可以在我们的IDEA右侧看到它的板块，但是还没任何数据，那么比如现在我们想要查看Main类的字节码文件时，可以这样操作：</p>
<figure data-type="image" tabindex="13"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznomfiqu8j22ll0u0tfa.jpg" alt="image-20220223194410699" loading="lazy"></figure>
<p>首先在项目中选中我们的Main类，然后点击工具栏的视图，然后点击<code>Show Bytecode With Jclasslib</code>，这样右侧就会出现当前类的字节码解析信息了。注意如果修改了类的话，那么需要你点击运行或是构建，然后点击刷新按钮来进行更新。</p>
<p>接着我们来看下一个内容，在常量池之后，紧接着就是访问标志，访问标志就是类的种类以及类上添加的一些关键字等内容：</p>
<figure data-type="image" tabindex="14"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznos6c7j9j21e60giq7s.jpg" alt="image-20220223194942810" loading="lazy"></figure>
<p>可以看到它只占了2个字节，那么它是如何表示访问标志呢?</p>
<figure data-type="image" tabindex="15"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznp9glonej216i0hcjui.jpg" alt="image-20220223200619811" loading="lazy"></figure>
<p>比如我们这里的Main类，它是一个普通的class类型，并且访问权限为public，那么它的访问标志值是这样计算的：</p>
<p><code>ACC_PUBLIC | ACC_SUPER = 0x0001 | 0x0020 = 0x0021</code>（这里进行的是按位或运算），可以看到和我们上面的结果是一致的。</p>
<p>再往下就是类索引、父类索引、接口索引：</p>
<figure data-type="image" tabindex="16"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznp3uofdej219803q0t7.jpg" alt="image-20220223200054866" loading="lazy"></figure>
<p>可以看到它们的值也是指向常量池中的值，其中2号常量正是存储的当前类信息，3号常量存储的是父类信息，这里就不再倒推回去了，由于没有接口，所以这里接口数量为0，如果不为0还会有一个索引表来引用接口。</p>
<p>接着就是字段和方法表集合了：</p>
<figure data-type="image" tabindex="17"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznp8gd1nfj21ai04mdgp.jpg" alt="image-20220223200521912" loading="lazy"></figure>
<p>由于我们这里没有声明任何字段，所以我们先给Main类添加一个字段再重新加载一下：</p>
<pre><code class="language-java">public class Main {

    public static int a = 10;

    public static void main(String[] args) {
        int i = 10;
        int a = i++;
        int b = ++i;
    }
}
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznpbh3k7rj21bi06o3zn.jpg" alt="image-20220223200733342" loading="lazy"></figure>
<p>现在字节码就新增了一个字段表，这个字段表实际上就是我们刚刚添加的成员字段<code>a</code>的数据。</p>
<p>可以看到一共有四个2字节的数据：</p>
<figure data-type="image" tabindex="19"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznpcxjzgfj216o06et9o.jpg" alt="image-20220223200939786" loading="lazy"></figure>
<p>首先是<code>access_flags</code>，这个与上面类标志的计算规则是一样的，表还是先列出来吧：</p>
<figure data-type="image" tabindex="20"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznpe7is4wj21620eswh4.jpg" alt="image-20220223201053780" loading="lazy"></figure>
<p>第二个数据<code>name_index</code>表示字段的名称常量，这里指向的是5号常量，那么我们来看看5号常量是不是字段名称：</p>
<figure data-type="image" tabindex="21"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznpgw09wjj21bc0tuk0x.jpg" alt="image-20220223201327180" loading="lazy"></figure>
<p>没问题，这里就是<code>a</code>,下一个是<code>descirptor_index</code>，存放的是描述符，不过这里因为不是方法而是变量，所以描述符直接写对应类型的标识字符即可，比如这里是<code>int</code>类型，那么就是<code>I</code>。</p>
<p>最后，<code>attrbutes_count</code>属性计数器，用于描述一些额外信息，这里我们暂时不做介绍。</p>
<p>接着就是我们的方法表了：</p>
<figure data-type="image" tabindex="22"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznppnxpcqj21ai04odgx.jpg" alt="image-20220223202153955" loading="lazy"></figure>
<p>可以看到方法表中一共有三个方法，其中第一个方法我们刚刚已经介绍过了，它的方法名称为<code>&lt;init&gt;</code>，表示它是一个构造方法，我们看到最后一个方法名称为<code>&lt;clinit&gt;</code>，这个是类在初始化时会调用的方法（是隐式的，自动生成的），它主要是用于静态变量初始化语句和静态块的执行，因为我们这里给静态成员变量a赋值为10，所以会在一开始为其赋值：</p>
<figure data-type="image" tabindex="23"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznpt5dhg3j224c0katcg.jpg" alt="image-20220223202515287" loading="lazy"></figure>
<p>而第二个方法，就是我们的<code>main</code>方法了，但是现在我们先不急着去看它的详细实现过程，我们来看看它的属性表。</p>
<p>属性表实际上类中、字段中、方法中都可以携带自己的属性表，属性表存放的正是我们的代码、本地变量等数据，比如main方法就存在4个本地变量，那么它的本地变量存放在哪里呢：</p>
<figure data-type="image" tabindex="24"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznpy0i9ehj21by0hywii.jpg" alt="image-20220223202955858" loading="lazy"></figure>
<p>可以看到，属性信息呈现套娃状态，在此方法中的属性包括了一个Code属性，此属性正是我们的Java代码编译之后变成字节码指令，然后存放的地方，而在此属性中，又嵌套了本地变量表和源码行号表。</p>
<p>可以看到code中存放的就是所有的字节码指令：</p>
<figure data-type="image" tabindex="25"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznq0wqe4xj215a0bi76l.jpg" alt="image-20220223203241262" loading="lazy"></figure>
<p>这里我们暂时不对字节码指令进行讲解（其实也用不着讲了，都认识的差不多了）。我们接着来看本地变量表，这里存放了我们方法中要用到的局部变量：</p>
<figure data-type="image" tabindex="26"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznq26f7rhj219w0ekq5v.jpg" alt="image-20220223203356129" loading="lazy"></figure>
<p>可以看到一共有四个本地变量，而第一个变量正是main方法的形参<code>String[] args</code>，并且表中存放了本地变量的长度、名称、描述符等内容。当然，除了我们刚刚认识的这几个属性之外，完整属性可以查阅《深入理解Java虚拟机 第三版》231页。</p>
<p>最后，类也有一些属性：</p>
<figure data-type="image" tabindex="27"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznq712n66j21dw0n20xw.jpg" alt="image-20220223203835282" loading="lazy"></figure>
<p>此属性记录的是源文件名称。</p>
<p>这样，我们对一个字节码文件的认识差不多就结束了，在了解了字节码文件的结构之后，是不是感觉豁然开朗？</p>
<hr>
<h3 id="字节码指令">字节码指令</h3>
<p>虚拟机的指令是由一个字节长度的、代表某种特定操作含义的数字（操作码，类似于机器语言），操作后面也可以携带0个或多个参数一起执行。我们前面已经介绍过了，JVM实际上并不是面向寄存器架构的，而是面向操作数栈，所以大多数指令都是不带参数的。</p>
<p>由于之前已经讲解过大致运行流程，这里我们就以当前的Main类中的main方法作为教材进行讲解：</p>
<pre><code class="language-java">public static void main(String[] args) {
    int i = 10;
    int a = i++;
    int b = ++i;
}
</code></pre>
<p>可以看到，main方法中首先是定义了一个int类型的变量i，并赋值为10，然后变量a接收<code>i++</code>的值，变量b接收<code>++i</code>的值。</p>
<p>那么我们来看看编译成字节码之后，是什么样的：</p>
<figure data-type="image" tabindex="28"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gznqsryzgfj225c0lgq6o.jpg" alt="image-20220223205928901" loading="lazy"></figure>
<ul>
<li>首先第一句，<code>bipush</code>，将10送至操作数栈顶。</li>
<li>接下来将操作数栈顶的数值存进1号本地变量，也就是变量i中。</li>
<li>接着将变量i中的值又丢向操作数栈顶</li>
<li>这里使用<code>iinc</code>指令，将1号本地变量的值增加1（结束之后i的值就是11了）</li>
<li>接着将操作数栈顶的值（操作数栈顶的值是10）存入2号本地变量（这下彻底知道i++到底干了啥才会先返回后自增了吧，从原理角度来说，实际上i是先自增了的，但由于这里取的是操作数栈中的值，所以说就得到了i之前的值）</li>
<li>接着往下，我们看到++i是先直接将i的值自增1</li>
<li>然后在将其值推向操作数栈顶</li>
</ul>
<figure data-type="image" tabindex="29"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzns3syhe7j21x8090q5k.jpg" alt="image-20220223214441621" loading="lazy"></figure>
<p>而从结果来看，<code>i++</code>操作确实是先返回再自增的，而字节码指令层面来说，却是截然相反的，只是结果一致罢了。</p>
<hr>
<h3 id="asm字节码编程">ASM字节码编程</h3>
<p>既然字节码文件结构如此清晰，那么我们能否通过编程，来直接创建一个字节码文件呢？如果我们可以直接编写一个字节码文件，那么我们就可以省去编译的过程。ASM（某些JDK中内置）框架正是用于支持字节码编程的框架。</p>
<p>比如现在我们需要创建一个普通的Main类（暂时不写任何内容）</p>
<p>首先我们来看看如何通过编程创建一个Main类的字节码文件：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);
    }
}
</code></pre>
<p>首先需要获取<code>ClassWriter</code>对象，我们可以使用它来编辑类的字节码文件，在构造时需要传入参数：</p>
<ul>
<li>0     这种方式不会自动计算操作数栈和局部临时变量表大小，需要自己手动来指定</li>
<li>ClassWriter.COMPUTE_MAXS(1)     这种方式会自动计算上述操作数栈和局部临时变量表大小，但需要手动触发。</li>
<li>ClassWriter.COMPUTE_FRAMES(2)   这种方式不仅会计算上述操作数栈和局部临时变量表大小，而且会自动计算StackMapFrames</li>
</ul>
<p>这里我们使用<code>ClassWriter.COMPUTE_MAXS</code>即可。</p>
<p>接着我们首先需要指定类的一些基本信息：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        //因为这里用到的常量比较多，所以说直接一次性静态导入：import static jdk.internal.org.objectweb.asm.Opcodes.*;
        writer.visit(V1_8, ACC_PUBLIC,&quot;com/test/Main&quot;, null, &quot;java/lang/Object&quot;,null);
    }
}
</code></pre>
<p>这里我们将字节码文件的版本设定位Java8，然后修饰符设定为<code>ACC_PUBLIC</code>代表<code>public class Main</code>，类名称注意要携带包名，标签设置为<code>null</code>，父类设定为Object类，然后没有实现任何接口，所以说最后一个参数也是<code>null</code>。</p>
<p>接着，一个简答的类字节码文件就创建好了，我们可以尝试将其进行保存：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        writer.visit(V1_8, ACC_PUBLIC,&quot;com/test/Main&quot;, null, &quot;java/lang/Object&quot;,null);
        //调用visitEnd表示结束编辑
        writer.visitEnd();

        try(FileOutputStream stream = new FileOutputStream(&quot;./Main.class&quot;)){
            stream.write(writer.toByteArray());  //直接通过ClassWriter将字节码文件转换为byte数组，并保存到根目录下
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>可以看到，在IDEA中反编译的结果为：</p>
<pre><code class="language-java">package com.test;

public class Main {
}
</code></pre>
<p>我们知道，正常的类在编译之后，如果没有手动添加构造方法，那么会自带一个无参构造，但是我们这个类中还没有，所以我们来手动添加一个无参构造方法：</p>
<pre><code class="language-java">//通过visitMethod方法可以添加一个新的方法
writer.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);
</code></pre>
<p>可以看到反编译的结果中已经存在了我们的构造方法：</p>
<pre><code class="language-java">package com.test;

public class Main {
    public Main() {
    }
}
</code></pre>
<p>但是这样是不合法的，因为我们的构造方法还没有添加父类构造方法调用，所以说我们还需要在方法中添加父类构造方法调用指令：</p>
<pre><code>public com.test.Main();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 11: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/test/Main;
</code></pre>
<p>我们需要对方法进行详细编辑：</p>
<pre><code class="language-java">//通过MethodVisitor接收返回值，进行进一步操作
MethodVisitor visitor = writer.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);
//开始编辑代码
visitor.visitCode();

//Label用于存储行号
Label l1 = new Label();
//当前代码写到哪行了，l1得到的就是多少行
visitor.visitLabel(l1);
//添加源码行数对应表（其实可以不用）
visitor.visitLineNumber(11, l1);

//注意不同类型的指令需要用不同方法来调用，因为操作数不一致，具体的注释有写
visitor.visitVarInsn(ALOAD, 0);
visitor.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);
visitor.visitInsn(RETURN);

Label l2 = new Label();
visitor.visitLabel(l2);
//添加本地变量表，这里加的是this关键字，但是方法中没用到，其实可以不加
visitor.visitLocalVariable(&quot;this&quot;, &quot;Lcom/test/Main;&quot;, null, l1, l2, 0);

//最后设定最大栈深度和本地变量数
visitor.visitMaxs(1, 1);
//结束编辑
visitor.visitEnd();
</code></pre>
<p>我们可以对编写好的class文件进行反编译，看看是不是和IDEA编译之后的结果差不多：</p>
<pre><code>{
  public com.test.Main();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #8                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/test/Main
      LineNumberTable:
        line 11: 0
}
</code></pre>
<p>可以看到和之前的基本一致了，到此为止我们构造方法就编写完成了，接着我们来写一下main方法，一会我们就可以通过main方法来运行Java程序了。比如我们要编写这样一个程序：</p>
<pre><code class="language-java">public static void main(String[] args) {
    int a = 10;
    System.out.println(a);
}
</code></pre>
<p>看起来很简单的一个程序对吧，但是我们如果手动去组装指令，会极其麻烦！首先main方法是一个静态方法，并且方法是public权限，然后还有一个参数<code>String[] args</code>，所以说我们这里要写的内容有点小多：</p>
<pre><code class="language-java">//开始安排main方法
MethodVisitor v2 = writer.visitMethod(ACC_PUBLIC | ACC_STATIC, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;, null, null);
v2.visitCode();
//记录起始行信息
Label l3 = new Label();
v2.visitLabel(l3);
v2.visitLineNumber(13, l3);

//首先是int a = 10的操作，执行指令依次为：
// bipush 10     将10推向操作数栈顶
// istore_1      将操作数栈顶元素保存到1号本地变量a中
v2.visitIntInsn(BIPUSH, 10);
v2.visitVarInsn(ISTORE, 1);
Label l4 = new Label();
v2.visitLabel(l4);
//记录一下行信息
v2.visitLineNumber(14, l4);

//这里是获取System类中的out静态变量（PrintStream接口），用于打印
v2.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
//把a的值取出来
v2.visitVarInsn(ILOAD, 1);
//调用接口中的抽象方法println
v2.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(I)V&quot;, false);

//再次记录行信息
Label l6 = new Label();
v2.visitLabel(l6);
v2.visitLineNumber(15, l6);

v2.visitInsn(RETURN);
Label l7 = new Label();
v2.visitLabel(l7);

//最后是本地变量表中的各个变量
v2.visitLocalVariable(&quot;args&quot;, &quot;[Ljava/lang/String;&quot;, null, l3, l7, 0);
v2.visitLocalVariable(&quot;a&quot;, &quot;I&quot;, null, l4, l7, 1);
v2.visitMaxs(1, 2);
//终于OK了
v2.visitEnd();
</code></pre>
<p>可以看到，虽然很简单的一个程序，但是如果我们手动去编写字节码，实际上是非常麻烦的，但是要实现动态代理之类的操作（可以很方便地修改字节码创建子类），是不是感觉又Get到了新操作（其实Spring实现动态代理的CGLib框架底层正是调用了ASM框架来实现的），所以说了解一下还是可以的，不过我们自己肯定是没多少玩这个的机会了。</p>
<hr>
<h2 id="类加载机制">类加载机制</h2>
<p>现在，我们已经了解了字节码文件的结构，以及JVM如何对内存进行管理，现在只剩下最后一个谜团等待解开了，也就是我们的类字节码文件到底是如何加载到内存中的，加载之后又会做什么事情。</p>
<h3 id="类加载过程">类加载过程</h3>
<p>首先，要加载一个类，一定是出于某种目的的，比如我们要运行我们的Java程序，那么就必须要加载主类才能运行主类中的主方法，又或是我们需要加载数据库驱动，那么可以通过反射来将对应的数据库驱动类进行加载。</p>
<p>所以，一般在这些情况下，如果类没有被加载，那么会被自动加载：</p>
<ul>
<li>使用new关键字创建对象时</li>
<li>使用某个类的静态成员（包括方法和字段）的时候（当然，final类型的静态字段有可能在编译的时候被放到了当前类的常量池中，这种情况下是不会触发自动加载的）</li>
<li>使用反射对类信息进行获取的时候（之前的数据库驱动就是这样的）</li>
<li>加载一个类的子类时</li>
<li>加载接口的实现类，且接口带有<code>default</code>的方法默认实现时</li>
</ul>
<p>比如这种情况，那么需要用到另一个类中的成员字段，所以就必须将另一个类加载之后才能访问：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        System.out.println(Test.str);
    }

    public static class Test{
        static {
            System.out.println(&quot;我被初始化了！&quot;);
        }

        public static String str = &quot;都看到这里了，不给个三连+关注吗？&quot;;
    }
}
</code></pre>
<p>这里我们就演示一个不太好理解的情况，我们现在将静态成员变量修改为final类型的：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        System.out.println(Test.str);
    }

    public static class Test{
        static {
            System.out.println(&quot;我被初始化了！&quot;);
        }

        public final static String str = &quot;都看到这里了，不给个三连+关注吗？&quot;;
    }
}
</code></pre>
<p>可以看到，在主方法中，我们使用了Test类的静态成员变量，并且此静态成员变量是一个final类型的，也就是说不可能再发生改变。那么各位觉得，Test类会像上面一样被初始化吗？</p>
<p>按照正常逻辑来说，既然要用到其他类中的字段，那么肯定需要加载其他类，但是这里我们结果发现，并没有对Test类进行加载，那么这是为什么呢？我们来看看Main类编译之后的字节码指令就知道了：</p>
<figure data-type="image" tabindex="30"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzoizzv7azj227c0lcjvp.jpg" alt="image-20220224131511381" loading="lazy"></figure>
<p>很明显，这里使用的是<code>ldc</code>指令从常量池中将字符串取出并推向操作数栈顶，也就是说，在编译阶段，整个<code>Test.str</code>直接被替换为了对应的字符串（因为final不可能发生改变的，编译就会进行优化，直接来个字符串比你去加载类在获取快得多不是吗，反正结果都一样），所以说编译之后，实际上跟Test类半毛钱关系都没有了。</p>
<p>所以说，当你在某些情况下疑惑为什么类加载了或是没有加载时，可以从字节码指令的角度去进行分析，一般情况下，只要遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这些指令时，都会进行类加载，比如：</p>
<figure data-type="image" tabindex="31"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzoj5isswmj22520j877u.jpg" alt="image-20220224132029992" loading="lazy"></figure>
<p>这里很明显，是一定会将Test类进行加载的。除此之外，各位也可以试试看数组的定义会不会导致类被加载。</p>
<p>好了，聊完了类的加载触发条件，我们接着来看一下类的详细加载流程。</p>
<figure data-type="image" tabindex="32"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzojblu4woj21380jkjtf.jpg" alt="image-20220224132621764" loading="lazy"></figure>
<p>首先类的生命周期一共有7个阶段，而首当其冲的就是加载，加载阶段需要获取此类的二进制数据流，比如我们要从硬盘中读取一个class文件，那么就可以通过文件输入流来获取类文件的<code>byte[]</code>，也可以是其他各种途径获取类文件的输入流，甚至网络传输并加载一个类也不是不可以。然后交给类加载器进行加载（类加载器可以是JDK内置的，也可以是开发者自己撸的，后面会详细介绍）类的所有信息会被加载到方法区中，并且在堆内存中会生成一个代表当前类的Class类对象（那么思考一下，同一个Class文件加载的类，是唯一存在的吗？），我们可以通过此对象以及反射机制来访问这个类的各种信息。</p>
<p>数组类要稍微特殊一点，通过前面的检验，我没发现数组在创建后是不会导致类加载的，数组类型本身不会通过类加载器进行加载的，不过你既然要往里面丢对象进去，那最终依然是要加载类的。</p>
<p>接着我们来看验证阶段，验证阶段相当于是对加载的类进行一次规范校验（因为一个类并不一定是由我们使用IDEA编译出来的，有可能是像我们之前那样直接用ASM框架写的一个），如果说类的任何地方不符合虚拟机规范，那么这个类是不会验证通过的，如果没有验证机制，那么一旦出现危害虚拟机的操作，整个程序会出现无法预料的后果。</p>
<p>验证阶段，首先是文件格式的验证：</p>
<ul>
<li>是否魔数为CAFEBABE开头。</li>
<li>主、次版本号是否可以由当前Java虚拟机运行</li>
<li>Class文件各个部分的完整性如何。</li>
<li>...</li>
</ul>
<p>有关类验证的详细过程，可以参考《深入理解Java虚拟机 第三版》268页。</p>
<p>接下来就是准备阶段了，这个阶段会为类变量分配内存，并为一些字段设定初始值，注意是系统规定的初始值，不是我们手动指定的初始值。</p>
<p>再往下就是解析阶段，此阶段是将常量池内的符号引用替换为直接引用的过程，也就是说，到这个时候，所有引用变量的指向都是已经切切实实地指向了内存中的对象了。</p>
<p>到这里，链接过程就结束了，也就是说这个时候类基本上已经完成大部分内容的初始化了。</p>
<p>最后就是真正的初始化阶段了，从这里开始，类中的Java代码部分，才会开始执行，还记得我们之前介绍的<code>&lt;clinit&gt;</code>方法吗，它就是在这个时候执行的，比如我们的类中存在一个静态成员变量，并且赋值为10，或是存在一个静态代码块，那么就会自动生成一个<code>&lt;clinit&gt;</code>方法来进行赋值操作，但是这个方法是自动生成的。</p>
<p>全部完成之后，我们的类就算是加载完成了。</p>
<hr>
<h3 id="类加载器">类加载器</h3>
<p>Java提供了类加载器，以便我们自己可以更好地控制类加载，我们可以自定义类加载器，也可以使用官方自带的类加载器去加载类。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。</p>
<p>也就是说，一个类可以由不同的类加载器加载，并且，不同的类加载器加载的出来的类，即使来自同一个Class文件，也是不同的，只有两个类来自同一个Class文件并且是由同一个类加载器加载的，才能判断为是同一个。默认情况下，所有的类都是由JDK自带的类加载器进行加载。</p>
<p>比如，我们先创建一个Test类用于测试：</p>
<pre><code class="language-java">package com.test;

public class Test {
    
}
</code></pre>
<p>接着我们自己实现一个ClassLoader来加载我们的Test类，同时使用官方默认的类加载器来加载：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) throws ReflectiveOperationException {
        Class&lt;?&gt; testClass1 = Main.class.getClassLoader().loadClass(&quot;com.test.Test&quot;);
        CustomClassLoader customClassLoader = new CustomClassLoader();
        Class&lt;?&gt; testClass2 = customClassLoader.loadClass(&quot;com.test.Test&quot;);

     	  //看看两个类的类加载器是不是同一个
        System.out.println(testClass1.getClassLoader());
        System.out.println(testClass2.getClassLoader());
				
      	//看看两个类是不是长得一模一样
        System.out.println(testClass1);
        System.out.println(testClass2);

      	//两个类是同一个吗？
        System.out.println(testClass1 == testClass2);
      
      	//能成功实现类型转换吗？
        Test test = (Test) testClass2.newInstance();
    }

    static class CustomClassLoader extends ClassLoader {
        @Override
        public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
            try (FileInputStream stream = new FileInputStream(&quot;./target/classes/&quot;+name.replace(&quot;.&quot;, &quot;/&quot;)+&quot;.class&quot;)){
                byte[] data = new byte[stream.available()];
                stream.read(data);
                if(data.length == 0) return super.loadClass(name);
                return defineClass(name, data, 0, data.length);
            } catch (IOException e) {
                return super.loadClass(name);
            }
        }
    }
}
</code></pre>
<p>通过结果我们发现，即使两个类是同一个Class文件加载的，只要类加载器不同，那么这两个类就是不同的两个类。</p>
<p>所以说，我们当时在JavaSE阶段讲解的每个类都在堆中有一个唯一的Class对象放在这里来看，并不完全正确，只是当前为了防止各位初学者搞混。</p>
<p>实际上，JDK内部提供的类加载器一共有三个，比如上面我们的Main类，其实是被AppClassLoader加载的，而JDK内部的类，都是由BootstrapClassLoader加载的，这其实就是为了实现双亲委派机制而做的。</p>
<figure data-type="image" tabindex="33"><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzpoy41z31j20wb0u040w.jpg" alt="image-20220225132629954" loading="lazy"></figure>
<p>有关双亲委派机制，我们在JavaSE阶段反射板块已经讲解过了，所以说这就不多做介绍了。</p>
]]></content>
    </entry>
</feed>