<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>c语言程序设计（二） | muouren7のBlog</title>

<link rel="shortcut icon" href="https://muouren7.github.io/favicon.ico?v=1665903129413">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://muouren7.github.io/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            muouren7のBlog
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1665903129413"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    c语言程序设计（二）
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2022-10-14 ·
                    </time>
                    
                        <a href="https://muouren7.github.io/tag/nmTcLhTtl/" class="post-tags">
                            # c
                        </a>
                    
                </div>
                <div class="post-content">
                    <figure data-type="image" tabindex="1"><img src="https://s2.loli.net/2022/06/17/nzpG5CLfUg927Rr.jpg" alt="" loading="lazy"></figure>
<h1 id="c语言基础">C语言基础</h1>
<p>前面我们已经搭建好了基本的学习环境，现在就让我们开始C语言的学习吧！</p>
<p>C语言的语法层面内容相比其他语言来说，其实算少的了，但是它的难点在于很多概念上的理解，这也是为什么上一章一直在说一些计算机基础相关内容（包括这一章还会继续补一点），这样会有助于各位对于语言的理解，C语言可以说是步入编程领域的分水岭，跨过了这道坎，后续其他编程语言的学习都会无比轻松。</p>
<p>学习编程的过程可能会很枯燥，但是请各位一定不要心急，一步一个脚印，相信大家一定能通关。</p>
<h2 id="c程序基本格式">C程序基本格式</h2>
<p>前面我们在创建项目之后自动生成了一个<code>.c</code>文件，这个就是我们编写的程序代码文件：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello World!&quot;);
  	return 0;
}
</code></pre>
<p>操作系统需要执行我们的程序，但是我们的程序中可能写了很多很多的代码，那么肯定需要知道从哪里开始执行才可以，也就是程序的入口，所以我们需要提供一个入口点，我们的C语言程序入口点就是<code>main</code>函数（不过现在还没有讲到函数，所以各位就理解为固定模式即可）它的写法是：</p>
<pre><code class="language-c">int main() {  //所有的符号一律采用英文的，别用中文
    程序代码...
}
</code></pre>
<p>注意是<code>int</code>后面空格跟上<code>main()</code>，我们的程序代码使用花括号<code>{}</code>进行囊括（有的人为了方便查阅，会把前半个花括号写在下面）</p>
<p>然后我们看到，如果我们需要打印一段话到控制台，那么就需要使用<code>printf(内容)</code>来完成，这其实就是一种函数调用，但是现在我们还没有接触到，我们注意到括号里面的内容就是我们要打印到控制台的内容：</p>
<pre><code class="language-c">printf(&quot;Hello World!&quot;);   //注意最后需要添加;来结束这一行，注意是英文的分号，不是中文的！
</code></pre>
<p>我们要打印的内容需要采用双引号进行囊括，被双引号囊括的这一端话，我们称为字符串，当然我们现在还没有学到，所以各位也是记固定模式就好，当我们需要向控制台打印一段话时，就要用双引号囊括这段话，然后放入<code>printf</code>即可。我们会在后续的学习中逐渐认识<code>printf</code>函数。</p>
<p>最顶上还有一句：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
</code></pre>
<p>这个是引入系统库为我们提供的函数，包括<code>printf</code>在内，所以我们以后编写一个C语言程序，就按照固定模式：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    程序代码
}
</code></pre>
<p>除了程序代码部分我们会进行编写之外，其他的地方采用固定模式就好。</p>
<p>我们在写代码的过程中可以添加一些注释文本，这些文本内容在编译时自动忽略，所以比如我们想边写边记点笔记，就可以添加注释，注释的格式为：</p>
<pre><code class="language-java">#include &lt;stdio.h&gt;   //引入标准库头文件

int main() {   //主函数，程序的入口点
    printf(&quot;Hello World!&quot;);  //向控制台打印字符串
}
</code></pre>
<p>当然我们也可以添加多行注释：</p>
<pre><code class="language-java">#include &lt;stdio.h&gt;

/*
 * 这是由IDE自动生成的测试代码
 * 还是可以的
 */
int main() {
    printf(&quot;Hello World!&quot;);
  	//最后还有一句 return 0; 但是我们可以不用写，编译器会自动添加，所以后面讲到之后我们再来说说这玩意。
}
</code></pre>
<p>OK，基本的一些内容就讲解完毕了。</p>
<h2 id="基本数据类型">基本数据类型</h2>
<p>我们的程序离不开数据，比如我们需要保存一个数字或是字母，这时候这些东西就是作为数据进行保存，不过不同的数据他们的类型可能不同，比如1就是一个整数，0.5就是一个小数，A就是一个字符，C语言提供了多种数据类型供我们使用，我们就可以很轻松的使用这些数据了。</p>
<p>不同的数据类型占据的空间也会不同，这里我们需要先提一个概念，就是字、字节是什么？</p>
<p>我们知道，计算机底层实际上只有0和1能够表示，这时如果我们要存储一个数据，比如十进制的3，那么就需要使用2个二进制位来保存，二进制格式为<code>11</code>，占用两个位置，再比如我们要表示十进制的15，这时转换为二进制就是<code>1111</code>占用四个位置（4个bit位）来保存。一般占用8个bit位表示一个字节（B），2个字节等于1个字，所以一个字表示16个bit位，它们是计量单位。</p>
<p>我们常说的内存大小1G、2G等，实际上就是按照下面的进制进行计算的：</p>
<p>8 bit = 1 B ，1024 B = 1KB，1024 KB = 1 MB，1024 MB = 1GB，1024 GB = 1TB，1024TB = 1PB（基本上是1024一个大进位，但是有些硬盘生产厂商是按照1000来计算的，所以我们买电脑的硬盘容量可能是512G的但是实际容量可能会缩水）</p>
<p>在不同位数的系统下基本数据类型的大小可能会不同，因为现在主流已经是64位系统，本教程统一按照64位系统进行讲解。</p>
<h3 id="原码-反码和补码">原码、反码和补码</h3>
<h4 id="原码">原码</h4>
<p>上面我们说了实际上所有的数字都是使用0和1这样的二进制数来进行表示的，但是这样仅仅只能保存正数，那么负数怎么办呢？</p>
<p>比如现在一共有4个bit位来保存我们的数据，为了表示正负，我们可以让第一个bit位专门来保存符号，这样，我们这4个bit位能够表示的数据范围就是：</p>
<ul>
<li>最小：1111 =&gt; - (2<sup>2+2</sup>1+2^0) =&gt; -7</li>
<li>最大：0111 =&gt; + (2<sup>2+2</sup>1+2^0) =&gt; +7 =&gt; 7</li>
</ul>
<p>虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：</p>
<p>1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道，计算机顶多知道1+1需要进位！）</p>
<p>我们得创造一种更好的表示方式！于是我们引入了反码：</p>
<h4 id="反码">反码</h4>
<p>正数的反码是其本身<br>
负数的反码是在其原码的基础上, 符号位不变，其余各个位取反<br>
经过上面的定义，我们再来进行加减法：</p>
<p>1+(-1) = 0001 + 1110 = 1111 =&gt; -0 （直接相加，这样就简单多了！）</p>
<p>思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？</p>
<p>0既不是正数也不是负数，那么显然这样的表示依然不够合理！</p>
<h4 id="补码">补码</h4>
<p>根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下：</p>
<p>正数的补码就是其本身 （不变！）<br>
负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)<br>
其实现在就已经能够想通了，-0其实已经被消除了！我们再来看上面的运算：</p>
<p>1+(-1) = 0001 + 1111 = (1)0000 =&gt; +0 （现在无论你怎么算，也不会有-0了！）</p>
<p>所以现在，4bit位能够表示的范围是：-8~+7（C使用的就是补码！）</p>
<h3 id="整数类型">整数类型</h3>
<p>我们首先来看看整数类型，整数就是不包含小数点的数据，比如<code>1</code>，<code>99</code>，<code>666</code>等数字，整数包含以下几种类型：</p>
<ul>
<li>int   -    占用 4 个字节，32个bit位，能够表示 -2,147,483,648 到 2,147,483,647 之间的数字，默认一般都是使用这种类型</li>
<li>long   -   占用 8 个字节，64个bit位。</li>
<li>short   -    占用2个字节，16个bit位。</li>
</ul>
<h3 id="浮点类型">浮点类型</h3>
<p>浮点类一般用于保存小数，不过为啥不叫小数类型而是浮点类型呢？因为我们的一个小数分为整数部分和小数部分，我们需要用一部分的bit位去表示整数部分，而另一部分去表示小数部分，至于整数部分和小数部分各自占多少并不是固定的，而是浮动决定的（在计算机组成原理中会深入学习，这里就不多介绍了）</p>
<ul>
<li>float   -   单精度浮点，占用4个字节，32个bit位。</li>
<li>double    -    双精度浮点，占用8个字节，64个bit位。</li>
</ul>
<h3 id="字符类型">字符类型</h3>
<p>除了保存数字之外，C语言还支持字符类型，我们的每一个字符都可以使用字符类型来保存：</p>
<ul>
<li>char   -    占用1个字节（-128~127），可以表示所有的ASCII码字符，每一个数字对应的是编码表中的一个字符：</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://s2.loli.net/2022/06/17/BoaWb5EHOM7wJVy.jpg" alt="image-20220603114358826" loading="lazy"></figure>
<p>编码表中包含了所有我们常见的字符，包括运算符号、数字、大小写字母等（注意只有英文相关的，没有中文和其他语言字符，包括中文的标点符号也没有）</p>
<p>某些无法直接显示的字符（比如换行，换行也算一个字符）需要使用转义字符来进行表示：</p>
<figure data-type="image" tabindex="3"><img src="https://s2.loli.net/2022/06/17/fqnzER2AS4YleTG.jpg" alt="img" loading="lazy"></figure>
<p>有关基本类型的具体使用我们放到下一节进行讲解。</p>
<hr>
<h2 id="变量">变量</h2>
<p>前面我们了解了C语言中的基本类型，那么我们如何使用呢？这时我们就可以创建不同类型的变量了。</p>
<h3 id="变量的使用">变量的使用</h3>
<p>变量就像我们在数学中学习的<code>x</code>，<code>y</code>一样，我们可以直接声明一个变量，并利用这些变量进行基本的运算，声明变量的格式为：</p>
<pre><code class="language-c">数据类型 变量名称 = 初始值;    //其中初始值可以不用在定义变量时设定
// = 是赋值操作，可以将等号后面的值赋值给前面的变量，等号后面可以直接写一个数字（常量）、变量名称、算式
</code></pre>
<p>比如我们现在想要声明一个整数类型的变量：</p>
<pre><code class="language-java">int a = 10;   //变量类型为int（常用），变量名称为a，变量的初始值为10
</code></pre>
<pre><code class="language-c">int a = 10, b = 20;   //多个变量可以另起一行编写，也可以像这样用逗号隔开，注意类型必须是一样的
</code></pre>
<p>其中，变量的名称并不是随便什么都可以的，它有以下规则：</p>
<ul>
<li>不能重复使用其他变量使用过的名字。</li>
<li>只能包含英文字母或是下划线、数字，并且严格区分大小写，比如<code>a</code>和<code>A</code>不算同一个变量。</li>
<li>虽然可以包含数字，但是不能以数字开头。</li>
<li>不能是关键字（比如我们上面提到的所有基本数据类型，当然还有一些关键字我们会在后面认识）</li>
<li>（建议）使用英文单词，不要使用拼音，多个词可以使用驼峰命名法或是通过下划线连接。</li>
</ul>
<p>初始值可以是一个常量数据（比如直接写10、0.5这样的数字）也可以是其他变量，或是运算表达式的结果，这样会将其他变量的值作为初始值。</p>
<p>我们可以使用变量来做一些基本的运算：</p>
<pre><code class="language-java">#include &lt;stdio.h&gt;

int main() {
    int a = 10;  //将10作为a的值
    int b = 20;
    int c = a + b;   //注意变量一定要先声明再使用，这里是计算a + b的结果（算式），并作为c的初始值
}
</code></pre>
<p>这里使用到了<code>+</code>运算符（之后我们还会介绍其他类型的运算符）这个运算符其实就是我们数学中学习的加法运算，会将左右两边的变量值加起来，得到结果，我们可以将运算结果作为其他变量的初始值，还是很好理解的。</p>
<p>但是现在虽然做了运算，我们还不知道运算的具体结果是什么，所以这里我们通过前面认识的<code>printf</code>函数来将结果打印到控制台：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    int b = 20;
    int c = a + b;

    printf(c);   //直接打印变量c
}
</code></pre>
<p>但是我们发现这样似乎运行不出来结果，不对啊，前面你不是说把要打印到控制台的内容写到<code>printf</code>中吗，怎么这里不行呢？实际上<code>printf</code>是用于格式化打印的，我们来看看如何进行格式化打印，输出我们的变量值：</p>
<pre><code class="language-c">printf(&quot;c的结果是：%d&quot;, );   //使用%d来代表一个整数类型的数据（占位符），在打印时会自动将c的值替换上去
</code></pre>
<p>我们来看看效果：</p>
<figure data-type="image" tabindex="4"><img src="https://s2.loli.net/2022/06/17/lb4T2HEXP7jCWIx.jpg" alt="image-20220603131740600" loading="lazy"></figure>
<p>这样，我们就知道该如何打印我们变量的值了，当然，除了使用<code>%d</code>打印有符号整数之外，还有其他的：</p>
<table>
<thead>
<tr>
<th>格式控制符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%c</td>
<td>输出一个单一的字符</td>
</tr>
<tr>
<td>%hd、%d、%ld</td>
<td>以十进制、有符号的形式输出 short、int、long 类型的整数</td>
</tr>
<tr>
<td>%hu、%u、%lu</td>
<td>以十进制、无符号的形式输出 short、int、long 类型的整数</td>
</tr>
<tr>
<td>%ho、%o、%lo</td>
<td>以八进制、不带前缀、无符号的形式输出 short、int、long 类型的整数</td>
</tr>
<tr>
<td>%#ho、%#o、%#lo</td>
<td>以八进制、带前缀、无符号的形式输出 short、int、long 类型的整数</td>
</tr>
<tr>
<td>%hx、%x、%lx %hX、%X、%lX</td>
<td>以十六进制、不带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字也小写；如果 X 大写，那么输出的十六进制数字也大写。</td>
</tr>
<tr>
<td>%#hx、%#x、%#lx %#hX、%#X、%#lX</td>
<td>以十六进制、带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字和前缀都小写；如果 X 大写，那么输出的十六进制数字和前缀都大写。</td>
</tr>
<tr>
<td>%f、%lf</td>
<td>以十进制的形式输出 float、double 类型的小数</td>
</tr>
<tr>
<td>%e、%le %E、%lE</td>
<td>以指数的形式输出 float、double 类型的小数。如果 e 小写，那么输出结果中的 e 也小写；如果 E 大写，那么输出结果中的 E 也大写。</td>
</tr>
<tr>
<td>%g、%lg %G、%lG</td>
<td>以十进制和指数中较短的形式输出 float、double 类型的小数，并且小数部分的最后不会添加多余的 0。如果 g 小写，那么当以指数形式输出时 e 也小写；如果 G 大写，那么当以指数形式输出时 E 也大写。</td>
</tr>
<tr>
<td>%s</td>
<td>输出一个字符串</td>
</tr>
</tbody>
</table>
<p>比如现在我们要进行小数的运算，还记得我们前面介绍的小数类型有哪些吗？</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    double a = 0.5;
    float b = 2.5f;   //注意直接写2.5默认表示的是一个double类型的值，我们需要再后面加一个f或是F表示是flaot类型值

    printf(&quot;a + b的结果是：%f&quot;, a + b);   //根据上表得到，小数类型需要使用%f表示，这里我们可以直接将a + b放入其中
}
</code></pre>
<p>可以看到，结果也是正确的：</p>
<figure data-type="image" tabindex="5"><img src="https://s2.loli.net/2022/06/17/M8ia6jKlW7epwXg.jpg" alt="image-20220603132459810" loading="lazy"></figure>
<p>当然，我们也可以一次性打印多个，只需要填写多个占位符表示即可：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    double a = 0.5;
    float b = 2.5f;   //整数类型默认是int，如果要表示为long类型的值，也是需要在最后添加一个l或L

    printf(&quot;a = %f, b = %f&quot;, a, b);   //后面可以一直添加（逗号隔开），但是注意要和前面的占位符对应
}
</code></pre>
<p>结果也是正常的：</p>
<figure data-type="image" tabindex="6"><img src="https://s2.loli.net/2022/06/17/2n6GfkdlFPX4Bv1.jpg" alt="image-20220603132713970" loading="lazy"></figure>
<p>我们再来看看字符类型：</p>
<pre><code class="language-c">char c = 'A';   //字符需要使用单引号囊括，且只能有一个字符，不能写成'AA'，这就不是单个字符了
//注意这里的A代表的是A这个字符，对应的ASCII码是65，实际上c存储的是65这个数字
</code></pre>
<p>我们也可以通过格式化打印来查看它的值：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 'A';
    printf(&quot;变量c的值为：%c 对应的ASCII码为：%d&quot;, c, c);   //这里我们使用%c来以字符形式输出，%d输出的是变量数据的整数形式，其实就是对应的ASCII码
}
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://s2.loli.net/2022/06/17/VsMorWTd13YLp8Q.jpg" alt="image-20220603133727498" loading="lazy"></figure>
<p>当然，我们也可以直接让char存储一个数字（ASCII码），同样也可以打印出对应的字符：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 66;
    printf(&quot;变量c的值为：%c 对应的ASCII码为：%d&quot;, c, c);
}
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://s2.loli.net/2022/06/17/shjrQKayID9YwVc.jpg" alt="image-20220603133858133" loading="lazy"></figure>
<p>那么现在请各位小伙伴看看下面这段代码会输出什么：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    char c = 'a';
    printf(&quot;变量c的ASCII码为：%d&quot;, c);
}
</code></pre>
<p>没错，这里得到的结果就是字符<code>a</code>的ASCII码值，注意千万不要认为c得到的是变量a的值，这里使用的是字符<code>a</code>，跟上面的变量a半毛钱关系都没有：</p>
<figure data-type="image" tabindex="9"><img src="https://s2.loli.net/2022/06/17/X1f6SzW7aBoFnJh.jpg" alt="image-20220603134234040" loading="lazy"></figure>
<p>但是如果我们去掉引号，就相当于把变量a的值给了c，c现在的ASCII码就是10了，所以这里一定要分清楚。</p>
<p>对于某些无法表示的字符，比如换行这类字符，我们没办法直接敲出来，只能使用转义字符进行表示：</p>
<pre><code class="language-c">char c = '\n';
</code></pre>
<p>详细的转义字符表参见前面的基本数据类型章节。</p>
<p>变量除了有初始值之外，也可以在后续的过程中得到新的值：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    short s = 10;
    s = 20;    //重新赋值为20，注意这里就不要再指定类型了，指定类型只有在声明变量时才需要
    printf(&quot;%d&quot;, s);   //打印结果
}
</code></pre>
<p>可以看到，得到的是我们最后一次对变量修改的结果：</p>
<figure data-type="image" tabindex="10"><img src="https://s2.loli.net/2022/06/17/mIXbe91qu7B5ZKU.jpg" alt="image-20220603135152184" loading="lazy"></figure>
<p>那要是我们不对变量设定初始值呢？那么变量会不会有默认值：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a, b, c, d;
    printf(&quot;%d,%d,%d,%d&quot;, a, b, c, d);
}
</code></pre>
<p>可以看到，虽然定义变量但是我们没有为其设定初始值，那么它的值就是不确定的了（千万注意并不是不设定值默认就是0）：</p>
<figure data-type="image" tabindex="11"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2v11c4z44j212o02mmxa.jpg" alt="image-20220603141341554" loading="lazy"></figure>
<p>所以各位小伙伴以后在使用时一定要注意这个问题，至于为什么不是0，这是因为内存分配机制，我们在下一章高级篇再进行讲解。</p>
<p>我们再来看一个例子：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 127;    //已经到达c的最大值了
    c = c + 1;   //我不管，我就要再加
    printf(&quot;%d&quot;, c);    //这时会得到什么结果？
}
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://s2.loli.net/2022/06/17/N7lGU4n2OkxjLcF.jpg" alt="image-20220603143909688" loading="lazy"></figure>
<p>怎么127加上1还变成-128了呢？这是由于位数不够，导致运算结果值溢出：</p>
<ul>
<li>127  +   1= 01111111   +    1</li>
<li>由于现在是二进制，满2进1，所以最后变成</li>
<li>10000000   =   补码形式的 -128</li>
</ul>
<p>所以，了解上面这些计算机底层原理是很重要的，我们能够很轻松地知道为什么会这样。</p>
<p>在我们的运算中，可能也会存在一些一成不变的值，比如<code>π</code>的值永远都是<code>3.1415....</code>，在我们的程序中，也可以使用这样不可变的变量，我们成为常量。</p>
<p>定义常量和变量比较类似，但是需要在前面添加一个<code>const</code>关键字，表示这是一个常量：</p>
<figure data-type="image" tabindex="13"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2v0s7fdvgj2128052gls.jpg" alt="image-20220603140454728" loading="lazy"></figure>
<p>可以看到，常量在一开始设定初始值后，后续是不允许进行修改的。</p>
<h3 id="无符号数">无符号数</h3>
<p>我们知道，所有的数据底层都是采用二进制来进行保存的，而第一位则是用于保存符号位，但是如果我们不考虑这个符号位，那么所有的数都是按照正数来表示，比如考虑了符号位的<code>char</code>类型：</p>
<ul>
<li>考虑符号表示范围：-128~127</li>
<li>不考虑符号：0~255</li>
</ul>
<p>我们也可以直接使用这些不带符号位的数据类型：</p>
<pre><code class="language-c">int main() {
    unsigned char c = -65;   //数据类型前面添加unsigned关键字表示采用无符号形式
    printf(&quot;%u&quot;, c);    //%u以无符号形式输出十进制数据
}
</code></pre>
<p>可以看到这里给了无符号char类型c一个-65的值，但是现在很明显符号位也是作为数值的表示部分，所以结果肯定不是-65：</p>
<figure data-type="image" tabindex="14"><img src="https://s2.loli.net/2022/06/17/Hkg4MIFcXzKwClp.jpg" alt="image-20220603142210120" loading="lazy"></figure>
<p>结合我们前面学习的基础知识，我们来看看为什么得到的是191这个数字。首先char类型占据一个字节，8个bit位：</p>
<ul>
<li>00000000   -&gt;    现在赋值-65    -&gt;    -65的补码形式   -&gt;     10111111</li>
<li>由于现在没有符号位，一律都是正数，所以，10111111  =  128 + 32 + 16 + 8 + 4 + 2 + 1 = 191</li>
</ul>
<p>我们也可以直接以无符号数形式打印：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int i = -1;
    printf(&quot;%u&quot;, i);    //%u以无符号形式输出十进制数据
}
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://s2.loli.net/2022/06/17/PYNZLCWc6OFVui8.jpg" alt="image-20220603143441616" loading="lazy"></figure>
<p>得到无符号int的最大值。</p>
<h3 id="类型转换">类型转换</h3>
<p>一种类型的数据可以转换为其他类型的数据，这种操作我们称为类型转换，类型转换分为<strong>自动类型转换</strong>和<strong>强制类型转换</strong>，比如我们现在希望将一个short类型的数据转换为int类型的数据：</p>
<pre><code class="language-java">#include &lt;stdio.h&gt;

int main() {
    short s = 10;
    int i = s;   //直接将s的值传递给i即可，但是注意此时s和i的类型不同
}
</code></pre>
<p>这里其实就是一种自动类型转换，自动类型转换就是编译器隐式地进行的数据类型转换，这种转换不需要我们做什么，我们直接写就行，会自动进行转换操作。</p>
<pre><code class="language-c">float a = 3;    //包括这里我们给的明明是一个int整数3但是却可以赋值给float类型，说明也是进行了自动类型转换
</code></pre>
<p>如果我们使用一个比转换的类型最大值都还要大的值进行类型转换，比如：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 511;
    char b = a;   //最大127
    printf(&quot;%d&quot;, b);
}
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://s2.loli.net/2022/06/17/U9rxV53lCzB4ARm.jpg" alt="image-20220606180919318" loading="lazy"></figure>
<p>很明显char类型是无法容纳大于127的数据的，因为只占一个字节，而int占4个字节，如果需要进行转换，那么就只能丢掉前面的就只保留char所需要的那几位了，所以这里得到的就是-1：</p>
<ul>
<li>511 = int  -&gt;  00000000 00000000 00000001 11111111</li>
<li>char   -&gt;   11111111   -&gt;    -1</li>
</ul>
<p>我们也可以将整数和小数类型的数据进行互相转换：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 99;
    double d = a;
    printf(&quot;%f&quot;, d);
}
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2yolhtg3rj215o02iq2z.jpg" alt="image-20220606180529600" loading="lazy"></figure>
<p>不过这里需要注意的是，小数类型在转换回整数类型时，会丢失小数部分（注意，不是四舍五入，是直接丢失小数！）：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    double a = 3.14;
    int b = a;    //这里编译器还提示了黄标，我们可以通过之后讲到的强制类型转换来处理
    printf(&quot;%d&quot;, b);
}
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2yoncxo3gj210o02kmx5.jpg" alt="image-20220606180719070" loading="lazy"></figure>
<p>除了赋值操作可以进行自动类型转换之外，在运算中也会进行自动类型转换，比如：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    float a = 2;
    int b = 3;
    double c = b / a;   //  &quot;/&quot; 是除以的意思，也就是我们数学中的除法运算，这里表示a除以b
    printf(&quot;%f&quot;, c);
}
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://s2.loli.net/2022/06/17/FQpoer6ANgjsIlY.jpg" alt="image-20220606191838425" loading="lazy"></figure>
<p>可以看到，这里得到的结果是小数1.5，但是参与运算的既有整数类型，又有浮点类型，结果为什么就确定为浮点类型了呢？这显然是由于类型转换导致的。那么规则是什么呢？</p>
<figure data-type="image" tabindex="20"><img src="https://s2.loli.net/2022/06/17/39b2LouK8dfnNhv.jpg" alt="image-20220606191412418" loading="lazy"></figure>
<ul>
<li>不同的类型优先级不同（根据长度而定）</li>
<li>char和short类型在参与运算时一律转换为int再进行运算。</li>
<li>浮点类型默认按双精度进行计算，所以就算有float类型，也会转换为double类型参与计算。</li>
<li>当有一个更高优先级的类型和一个低优先级的类型同时参与运算时，统一转换为高优先级运算，比如int和long参与运算，那么int转换为long再算，所以结果也是long类型，int和double参与运算，那么先把int转换为double再算。</li>
</ul>
<p>我们接着来看看强制类型转换，我们可以为手动去指定类型，强制类型转换格式如下：</p>
<pre><code class="language-c">(强制转换类型) 变量、常量或表达式;
</code></pre>
<p>比如：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = (int) 2.5;   //2.5是一个double类型的值，但是我们可以强制转换为int类型赋值给a，强制转换之后小数部分丢失
    printf(&quot;%d&quot;, a);
}
</code></pre>
<p>我们也可以对一个算式的结果进行类型转换：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    double a = 3.14;
    int b = (int) (a + 2.8);   //注意得括起来表示对整个算式的结果进行类型转换（括号跟数学中的挺像，也是提升优先级使用的，我们会在运算符部分详细讲解），不然强制类型转换只对其之后紧跟着的变量生效
    printf(&quot;%d&quot;, b);
}
</code></pre>
<p>在我们需要得到两个int相除之后带小数的结果时，强制类型转换就显得很有用：</p>
<pre><code class="language-java">#include &lt;stdio.h&gt;

int main() {
    int a = 10, b = 4;
    double c = a / b;    //不进行任何的类型转换，int除以int结果仍然是int，导致小数丢失
    double d = (double) a / b;   //对a进行强制类型转换，现在是double和int计算，根据上面自动类型转换规则，后面的int自动转换为double，结果也是double了，这样就是正确的结果了
    printf(&quot;不进行类型转换: %f, 进行类型转换: %f&quot;, c, d);
}
</code></pre>
<p>合理地使用强制类型转换，能够解决我们很多情况下的计算问题。</p>
<hr>
<h2 id="运算符">运算符</h2>
<p>前面我们了解了如何声明变量以及变量的类型转换，那么我们如何去使用这些变量来参与计算呢？这是我们本小节的重点。</p>
<h3 id="基本运算符">基本运算符</h3>
<p>基本运算符包含我们在数学中常用的一些操作，比如加减乘除，分别对应：</p>
<ul>
<li>加法运算符：+</li>
<li>减法运算符：-</li>
<li>乘法运算符：*</li>
<li>除法运算符：/（注意不是“\”，看清楚一点）</li>
</ul>
<p>当然，还有我们之前使用的赋值运算符<code>=</code>，我们先来看看赋值运算符的使用，其实在之前我们已经学习过了：</p>
<pre><code class="language-c">变量 = 值   //其中，值可以直接是一个数字、一个变量、表达式的结果等
</code></pre>
<p>实际上等号左边的内容准确的说应该是一个左值，不过大部分情况下都是变量，这里就不展开左值和右值的话题了（感兴趣的小伙伴可以去详细了解，有助于后面学习C++理解右值引用）</p>
<p>最简单的用法就是我们前面所说的，对一个变量进行赋值操作：</p>
<pre><code class="language-c">int a = 10;
</code></pre>
<p>也可以连续地使用赋值操作，让一连串的变量都等于后面的值：</p>
<pre><code class="language-c">int a, b;
a = b = 20;   //从右往左依次给b和a赋值20
</code></pre>
<p>可以看出，实际上<code>=</code>运算除了赋值之外，和加减乘除运算一样也是有结果的，比如上面的 a = 就是b = 20 运算的结果（可以看着一个整体），只不过运算的结果就是b被赋值的值，也就是20。</p>
<p>我们接着来看加减法，这个就和我们数学中的是一样的了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10, b = 5;
    printf(&quot;%d&quot;, a + b);   //打印 a + b 的结果
}
</code></pre>
<p>当然也可以像数学中那样写在一个数或是变量的最前面，表示是正数：</p>
<pre><code class="language-c">int a = +10, b = +5;
</code></pre>
<p>不过默认情况下就是正数，所以没必要去写一个+号。减法运算符其实也是一样的：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10, b = 5;
    printf(&quot;%d&quot;, a - b);   //打印 a - b 的结果
}
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = -10;   //等于 -10
    printf(&quot;%d&quot;, -a);   //输出 -a 的值，就反着来嘛
}
</code></pre>
<p>接着我们来看看乘法和除法运算：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 20, b = 10;
    printf(&quot;%d, %d&quot;, a * b, a / b);   //使用方式和上面的加减法是差不多的
}
</code></pre>
<p>还有一个比较有意思的取模运算：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 20, b = 8;
    printf(&quot;%d&quot;, a % b);   //取模运算实际上就是计算a除以b的余数
}
</code></pre>
<p>不过很遗憾，在C中没有指数相关的运算符（比如要计算5的10次方），在后面学习了循环语句之后，我们可以尝试来自己实现一个指数运算。</p>
<h3 id="运算符优先级">运算符优先级</h3>
<p>和数学中一样，运算符是有优先级的：</p>
<pre><code class="language-java">#include &lt;stdio.h&gt;

int main() {
    int a = 20, b = 10;
    printf(&quot;%d&quot;, a + a * b);   //如果没有优先级，那么结果应该是400
}
</code></pre>
<p>很明显这里的结果是考虑了优先级的：</p>
<figure data-type="image" tabindex="21"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ytdqy91yj211o02wq2u.jpg" alt="image-20220606205103154" loading="lazy"></figure>
<p>在数学中，加减运算的优先级是没有乘除运算优先级高的，所以我们需要先计算那些乘除法，最后再来进行加减法的计算，而C语言中也是这样，运算符之间存在优先级概念。我们在数学中，如果需要优先计算加减法再计算乘除法，那么就需要使用括号来提升加减法的优先级，C语言也可以：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 20, b = 10;
    printf(&quot;%d&quot;, (a + a) * b);   //优先计算 a + a 的结果，再乘以 b
}
</code></pre>
<p>那要是遇到多重的呢？类似于下面的这种：</p>
<pre><code>数学上的写法：[1 - (3 + 4)] x (-2 ÷ 1) = ?
</code></pre>
<p>那么我们在C中就可以这样编写：</p>
<pre><code class="language-java">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;%d&quot;, (1 - (3 + 4)) * (-2 / 1));   //其实写法基本差不多，只需要一律使用小括号即可
}
</code></pre>
<p>这样，我们就可以通过<code>()</code>运算符，来提升运算优先级了。</p>
<p>我们来总结一下，上面运算符优先级如下，从左往右依次递减：</p>
<ul>
<li><code>()</code>  &gt;   <code>+ - (做符号表示，比如-9)</code>  &gt;  <code>* / %</code>  &gt;  <code>+ - (做加减运算)</code>  &gt;  <code>=</code></li>
</ul>
<p>根据上面的优先级，我们来看看下面<code>a</code>的结果是什么：</p>
<pre><code class="language-c">int c;
int a = (3 + (c = 2)) * 6;
</code></pre>
<pre><code class="language-c">int b, c;
int a = (b = 5, c = b + 8);  //逗号运算符从前往后依次执行，赋值结果是最后边的结果
</code></pre>
<h3 id="自增自减运算符">自增自减运算符</h3>
<p>我们可以快速使用自增运算符来将变量的值<code>+1</code>，正常情况下我们想要让一个变量值自增需要：</p>
<pre><code class="language-c">int a = 10;
a = a + 1;
</code></pre>
<p>现在我们只需要替换为：</p>
<pre><code class="language-c">int a = 10;
++a;   //使用自增运算符，效果等价于 a = a + 1
</code></pre>
<p>并且它也是有结果的，除了做自增运算之外，它的结果是自增之后的值：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    //int b = a = a + 1;  下面效果完全一致
    int b = ++a;
    printf(&quot;%d&quot;, b);
}
</code></pre>
<p>当然我们也可以将自增运算符写到后面，和写在前面的区别是，它是先返回当前变量的结果，再进行自增的，顺序是完全相反的：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    int b = a++;   //写在后面和写在前面是有区别的
    printf(&quot;a = %d, b = %d&quot;, a, b);
}
</code></pre>
<blockquote>
<p>重点内容：自增运算符<code>++</code>在前，那么先自增再出结果；自增运算符<code>++</code>在后，那么先出结果再自增。各位小伙伴可以直接记运算符的位置，来方便记忆。</p>
</blockquote>
<p>那要是现在我们不想自增1而是自增2或是其他的数字呢？我们可以使用复合赋值运算符，正常情况下依然是使用普通的赋值运算符：</p>
<pre><code class="language-c">int a = 10;
a = a + 5;
</code></pre>
<p>但是现在我们可以简写：</p>
<pre><code class="language-c">int a = 10;
a += 5;
</code></pre>
<p>效果和上面是完全一样的，并且得到的结果也是在自增之后的：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    int b = a += 5;
    printf(&quot;a = %d&quot;, b);
}
</code></pre>
<p>复合赋值运算符不仅仅支持加法，还支持各种各样的运算：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    a %= 3;   //可以复合各种运算，比如加减乘除、模运算、包括我们我们还要讲到的位运算等
    printf(&quot;a = %d&quot;, a);
}
</code></pre>
<p>当然，除了自增操作之外，还有自减操作：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    a--;   //--是自减操作，相当于a = a - 1，也可以在前后写，规则和上面的自增是一样的
    printf(&quot;a = %d&quot;, a);
}
</code></pre>
<p>注意自增自减运算符和<code>+</code>、<code>-</code>做符号是的优先级一样，仅次于<code>()</code>运算符，所以在编写时一定要注意：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    int b = 5 * --a;
    printf(&quot;b = %d&quot;, b);
}
</code></pre>
<h3 id="位运算符">位运算符</h3>
<p>前面我们学习了乘法运算符<code>*</code>，当我们想要让一个变量的值变成2倍，只需要做一次乘法运算即可：</p>
<pre><code class="language-c">int a = 10;
a *= 2;  //很明显算完之后a就是20了
</code></pre>
<p>但是我们现在可以利用位运算来快速进行计算：</p>
<pre><code class="language-c">int a = 10;
a = a &lt;&lt; 1;   //也可以写成复合形式 a &lt;&lt;= 1
</code></pre>
<p>我们会发现这样运算之后得到的结果居然也是20，这是咋算出来的呢？实际上<code>&lt;&lt;</code>是让所有的bit位进行左移操作，上面就是左移1位，我们可以来看看：</p>
<ul>
<li>10  =  00001010     现在所以bit位上的数据左移一位    00010100   =   20</li>
</ul>
<p>是不是感觉特别神奇？就像我们在十进制中，做乘以10的操作一样：22乘以10那么就直接左移了一位变成220，而二进制也是一样的，如果让这些二进制数据左移的话，那么相当于在进行乘2的操作。</p>
<p>比如：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 6;
    a = a &lt;&lt; 2;   //让a左移2位，实际上就是 a * 2 * 2，a * 2的平方（类比十进制，其实还是很好理解的）
    printf(&quot;a = %d&quot;, a);
}
</code></pre>
<p>当然能左移那肯定也可以右移：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 6;
    a = a &gt;&gt; 1;   //右移其实就是除以2的操作
    printf(&quot;a = %d&quot;, a);
}
</code></pre>
<p>当然除了移动操作之外，我们也可以进行按位比较操作，先来看看按位与操作：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 6, b = 4;
    int c = a &amp; b;   //按位与操作
    printf(&quot;c = %d&quot;, c);
}
</code></pre>
<p>按位与实际上也是根据每个bit位来进行计算的：</p>
<ul>
<li>4  =  00000100</li>
<li>6  =  00000110</li>
<li>按位与实际上就是让两个数的每一位都进行比较，如果两个数对应的bit位都是1，那么结果的对应bit位上就是1，其他情况一律为0</li>
<li>所以计算结果为：00000100    =    4</li>
</ul>
<p>除了按位与之外，还有按位或运算：</p>
<pre><code class="language-c">int a = 6, b = 4;
int c = a | b;
</code></pre>
<ul>
<li>4  =  00000100</li>
<li>6  =  00000110</li>
<li>按位与实际上也是让两个数的每一位都进行比较，如果两个数对应bit位上其中一个是1，那么结果的对应bit位上就是1，其他情况为0。</li>
<li>所以计算结果为：00000110  =  6</li>
</ul>
<p>还有异或和按位非（按位否定）：</p>
<pre><code class="language-c">int a = 6, b = 4;
int c = a ^ b;    //注意^不是指数运算，表示按位异或运算，让两个数的每一位都进行比较，如果两个数对应bit位上不同时为1或是同时为0，那么结果就是1，否则结果就是0，所以这里的结果就是2
a = ~a;   //按位否定针对某个数进行操作，它会将这个数的每一个bit位都置反，0变成1，1变成0，猜猜会变成几
</code></pre>
<p>按位运算都是操作数据底层的二进制位来进行的。</p>
<h3 id="逻辑运算符">逻辑运算符</h3>
<p>最后我们来看一下逻辑运算符，逻辑运算符主要用到下一节的流程控制语句中。</p>
<p>逻辑运算符用于计算真和假，比如今天要么下雨要么不下雨，现在我们想要在程序中判断一下是否下雨了，这时就需要用到逻辑运算符，我们来举个例子：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 10;
    _Bool c = a &lt; 0;    //我们现在想要判断a的值是否小于0，我们可以直接使用小于符号进行判断，最后得到的结果只能是1或0
  	//虽然结果是一个整数，但是这里推荐使用_Bool类型进行接收，它只能表示0和1（更加专业一些）
    printf(&quot;c = %d&quot;, c);  
}
</code></pre>
<p>实际上在C语言中，0一般都表示为假，而非0的所有值（包括正数和负数）都表示为真，上面得到1表示真，0表示假。</p>
<p>除了小于符号可以判断大小之外，还有：<code>&lt;</code>、<code> &lt;=</code>、<code>&gt;=</code>、<code>&gt;</code></p>
<p>比如我们现在想要判断字符C是否为大写字母：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 'D';
    printf(&quot;c是否为大写字母：%d&quot;, c &gt;= 'A');    //由于底层存储的就是ASCII码，这里可以比较ASCII码，也可以写成字符的形式
}
</code></pre>
<p>但是我们发现，现在我们的判断只能判断一个条件，也就是说只能判断c是否是大于等于'A'的，但是不能同时判断c的值是否是小于等于'Z'的，所以这时，我们就需要利用逻辑与和逻辑或来连接两个条件了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 'D';
    printf(&quot;c是否为大写字母：%d&quot;, c &gt;= 'A' &amp;&amp; c &lt;= 'Z');   //使用&amp;&amp;表示逻辑与，逻辑与要求两边都是真，结果才是真
}
</code></pre>
<p>又比如现在我们希望判断c是否不是大写字母：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 'D';
    printf(&quot;c是否不为大写字母：%d&quot;, c &lt; 'A' || c &gt; 'Z');   //使用||表示逻辑或，只要两边其中一个为真或是都为真，结果就是真
}
</code></pre>
<p>当然我们也可以判断c是否为某个字母：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 'D';
    printf(&quot;c是否为字母A：%d&quot;, c == 'A');    //注意判断相等时使用==双等号
}
</code></pre>
<p>判断不相等也可以使用：</p>
<pre><code class="language-c">printf(&quot;c是否不为字母A：%d&quot;, c != 'A');
</code></pre>
<p>我们也可以对某个结果取反：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int i = 20;
    printf(&quot;i是否不小于20：%d&quot;, !(i &lt; 20));   //使用!来对结果取反，注意!优先级很高，一定要括起来，不然会直接对i生效
}
</code></pre>
<p>这里要注意一下<code>!</code>如果直接作用于某个变量或是常量，那么会直接按照上面的规则（0表示假，非0表示真）非0一律转换为0，0一律转换为1。</p>
<p>这里我们可以结合三目运算符来使用这些逻辑运算符：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int i = 0;
    char c = i &gt; 10 ? 'A' : 'B';    //三目运算符格式为：expression ? 值1 : 值2，返回的结果会根据前面判断的结果来的
    //这里是判断i是否大于10，如果大于那么c的值就是A，否则就是B
  	printf(&quot;%d&quot;, c);
}
</code></pre>
<p>最后，我们来总结一下前面认识的所有运算符的优先级，从上往下依次降低：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>解释</th>
<th>结合方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>()</td>
<td>同数学中的括号，直接提升到最高优先级</td>
<td>由左向右</td>
</tr>
<tr>
<td>! ~ ++ -- + -</td>
<td>否定，按位否定，增量，减量，正负号</td>
<td>由右向左</td>
</tr>
<tr>
<td>* / %</td>
<td>乘，除，取模</td>
<td>由左向右</td>
</tr>
<tr>
<td>+ -</td>
<td>加，减</td>
<td>由左向右</td>
</tr>
<tr>
<td>&lt;&lt; &gt;&gt;</td>
<td>左移，右移</td>
<td>由左向右</td>
</tr>
<tr>
<td>&lt; &lt;= &gt;= &gt;</td>
<td>小于，小于等于，大于等于，大于</td>
<td>由左向右</td>
</tr>
<tr>
<td>== !=</td>
<td>等于，不等于</td>
<td>由左向右</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
<td>由左向右</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>由左向右</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>由左向右</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>由左向右</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
<td>由左向右</td>
</tr>
<tr>
<td>? :</td>
<td>条件</td>
<td>由右向左</td>
</tr>
<tr>
<td>= += -= *= /= &amp;= ^= |= &lt;&lt;= &gt;&gt;=</td>
<td>各种赋值</td>
<td>由右向左</td>
</tr>
<tr>
<td>,</td>
<td>逗号（顺序）</td>
<td>由左向右</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="流程控制">流程控制</h2>
<p>前面我们学习了运算符，知道该如何使用运算符来计算我们想要的内容，但是仅仅依靠计算我们的程序还没办法实现丰富多样的功能，我们还得加点额外的控制操作。</p>
<h3 id="分支语句-if">分支语句 - if</h3>
<p>我们可能会有这样的一个需求，就是判断某个条件，当满足此条件时，才执行某些代码，那这个时候该怎么办呢？我们可以使用<code>if</code>语句来实现：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int i = 0;
    if(i &gt; 20) {    //我们只希望i大于20的时候才执行下面的打印语句
        printf(&quot;Hello World!&quot;);
    }
  	printf(&quot;Hello World?&quot;);   //后面的代码在if之外，无论是否满足if条件，都跟后面的代码无关，所以这里的代码任何情况下都会执行
}
</code></pre>
<p>if语句的标准格式如下：</p>
<pre><code class="language-c">if(判断条件) {
    执行的代码
}
</code></pre>
<p>当然如果只需要执行一行代码的话，可以省略花括号：</p>
<pre><code class="language-c">if(判断条件)
  一行执行的代码   //注意这样只有后一行代码生效，其他的算作if之外的代码了
</code></pre>
<p>现在我们需求升级了，我们需要判断某个条件，当满足此条件时，执行某些代码，而不满足时，我们想要执行另一段代码，我们就可以结合else语句来实现：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int i = 0;
    if(i &gt; 20) {
        printf(&quot;Hello World!&quot;);   //满足if条件才执行
    } else {
        printf(&quot;LBWNB&quot;);   //不满足if条件才执行
    }
}
</code></pre>
<p>但是这样可能还是不够用，比如我们现在希望判断学生的成绩，不同分数段打印的等级不一样，比如90以上就是优秀，70以上就是良好，60以上是及格，其他的都是不及格，那么这种我们又该如何判断呢？要像这样进行连续判断，我们需要使用<code>else-if</code>来完成：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int score =  2;
    if(score &gt;= 90) {
        printf(&quot;优秀&quot;);
    } else if (score &gt;= 70) {
        printf(&quot;良好&quot;);
    } else if (score &gt;= 60){
        printf(&quot;及格&quot;);
    } else{
        printf(&quot;不及格&quot;);
    }
}
</code></pre>
<p><code>if</code>这类的语句（包括我们下面还要介绍的三种）都是支持嵌套使用的，比如我们现在希望低于60分的同学需要补习，0-30分需要补Java，30-60分需要补C++，这时我们就需要用到嵌套：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int score =  2;
    if(score &lt; 60) {   //先判断不及格
        if(score &gt; 30) {   //在内层再嵌套一个if语句进行进一步的判断
            printf(&quot;学习C++&quot;);
        } else{
            printf(&quot;学习Java&quot;);
        }
    }
}
</code></pre>
<h3 id="分支语句-switch">分支语句 - switch</h3>
<p>前面我们介绍了if语句，我们可以通过一个if语句轻松地进行条件判断，然后根据对应的条件，来执行不同的逻辑，当然除了这种方式之外，我们也可以使用switch语句来实现，它更适用于多分支的情况：</p>
<pre><code class="language-c">switch (目标) {   //我们需要传入一个目标，比如变量，或是计算表达式等
  case 匹配值:    //如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码
    代码...
    break;    //代码执行结束后需要使用break来结束，否则会继续溜到下一个case继续执行代码
}
</code></pre>
<p>比如现在我们要根据学生的等级进行分班，学生有ABC三个等级：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 'A';
    switch (c) {  //这里目标就是变量c
        case 'A':    //分别指定ABC三个匹配值，并且执行不同的代码
            printf(&quot;去尖子班！准备冲刺985大学！&quot;);
            break;   //执行完之后一定记得break，否则会继续向下执行下一个case中的代码
        case 'B':
            printf(&quot;去平行班！准备冲刺一本！&quot;);
            break;
        case 'C':
            printf(&quot;去职高深造。&quot;);
            break;
    }
}
</code></pre>
<p>switch可以精准匹配某个值，但是它不能进行范围判断，比如我们要判断分数段，这时用switch就很鸡肋了。</p>
<p>当然除了精准匹配之外，其他的情况我们可以用default来表示：</p>
<pre><code class="language-c">switch (目标) {
    case: ...
    default:
    		其他情况下执行的代码
}
</code></pre>
<p>比如：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 'A';
    switch (c) {
        case 'A':
            printf(&quot;去尖子班！&quot;);
            break;
        case 'B':
            printf(&quot;去平行班！&quot;);
            break;
        case 'C':
            printf(&quot;去差生班！&quot;);
            break;
        default:   //其他情况一律就是下面的代码了
            printf(&quot;去读职高，分流&quot;);
    }
}
</code></pre>
<p>当然switch中可以继续嵌套其他的流程控制语句，比如if：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char c = 'A';
    switch (c) {
        case 'A':
            if(c == 'A') {    //嵌套一个if语句
                printf(&quot;去尖子班！&quot;);   
            }
            break;
        case 'B':
            printf(&quot;去平行班！&quot;);
            break;
    }
}
</code></pre>
<h3 id="循环语句-for">循环语句 - for</h3>
<p>通过前面的学习，我们了解了如何使用分支语句来根据不同的条件执行不同的代码，我们接着来看第二种重要的流程控制语句，循环语句。</p>
<p>我们在某些时候，可能需要批量执行某些代码：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;伞兵一号卢本伟准备就绪！&quot;);   //把这句话给我打印三遍
    printf(&quot;伞兵一号卢本伟准备就绪！&quot;);
    printf(&quot;伞兵一号卢本伟准备就绪！&quot;);
}
</code></pre>
<p>遇到这种情况，我们由于还没学习循环语句，那么就只能写N次来实现这样的多次执行。现在我们可以使用for循环语句来多次执行：</p>
<pre><code class="language-c">for (表达式1表达式2;表达式3) {
    循环体
}
</code></pre>
<p>我们来介绍一下：</p>
<ul>
<li>表达式1：在循环开始时仅执行一次。</li>
<li>表达式2：每次循环开始前会执行一次，要求为判断语句，用于判断是否可以结束循环，若结果为真，那么继续循环，否则结束循环。</li>
<li>表达式3：每次循环完成后会执行一次。</li>
<li>循环体：每次循环都会执行循环体里面的内容，直到循环结束。</li>
</ul>
<p>一个标准的for循环语句写法如下：</p>
<pre><code class="language-c">//比如现在我们希望循环4次
for (int i = 0; i &lt; 4; ++i) {
    //首先定义一个变量i用于控制循环结束
  	//表达式2在循环开始之前判断是否小于4
  	//表达式3每次循环结束都让i自增一次，这样当自增4次之后不再满足条件，循环就会结束，正好4次循环
}
</code></pre>
<p>我们来看看按顺序打印的结果：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    //比如现在我们希望循环4次
    for (int i = 0; i &lt; 4; ++i) {
        printf(&quot;%d, &quot;, i);
    }
}
</code></pre>
<figure data-type="image" tabindex="22"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h34bzvoslpj2136030aa3.jpg" alt="image-20220611152257585" loading="lazy"></figure>
<p>这样，利用循环我们就可以批量执行各种操作了。</p>
<p>注意，如果表达式2我们什么都不写，那么会默认判定为真：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    for (int i = 0; ; ++i) {   //表达式2不编写任何内容，默认为真，这样的话循环永远都不会结束
        printf(&quot;%d, &quot;, i);
    }
}
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://s2.loli.net/2022/06/17/AHoTpOIEYu8Jc7R.jpg" alt="image-20220612164349847" loading="lazy"></figure>
<p>所以，如果我们想要编写一个无限循环，其实什么都不用写就行了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    for (;;) {   //什么都不写直接无限循环，但是注意，两个分号还是要写的
        printf(&quot;Hello World!\n&quot;);   //这里用到了\n表示换行
    }
}
</code></pre>
<p>当然，我们也可以在循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字：</p>
<pre><code class="language-c">for (int i = 0; i &lt; 10; ++i) {
    if(i == 5) break;   //比如现在我们希望在满足某个条件下提前终止循环，可以使用break关键字来跳出循环
    printf(&quot;%d&quot;, i);
}
</code></pre>
<figure data-type="image" tabindex="24"><img src="https://s2.loli.net/2022/06/17/vW37gTywX92AI1r.jpg" alt="image-20220613101128788" loading="lazy"></figure>
<p>可以看到，当满足条件时，会直接通过break跳出循环，循环不再继续下去，直接结束掉。</p>
<p>我们也可以加速循环：</p>
<pre><code class="language-c">for (int i = 0; i &lt; 10; ++i) {
    if(i == 5) continue;   //使用continue关键字会加速循环，无论后面有没有未执行完的代码，都会直接开启下一轮循环
    printf(&quot;%d&quot;, i);
}
</code></pre>
<figure data-type="image" tabindex="25"><img src="https://s2.loli.net/2022/06/17/WeHJkqmEfGcn53r.jpg" alt="image-20220613101847762" loading="lazy"></figure>
<p>虽然使用break和continue关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（就近原则）：</p>
<pre><code class="language-c">for (int i = 1; i &lt; 4; ++i) {
    for (int j = 1; j &lt; 4; ++j) {
        if(i == j) continue;    //当i == j时加速循环
        printf(&quot;%d, %d\n&quot;, i, j);
    }
}
</code></pre>
<figure data-type="image" tabindex="26"><img src="https://s2.loli.net/2022/06/17/Kh9U3l7rEqtGuQ1.jpg" alt="image-20220613102100374" loading="lazy"></figure>
<p>可以看到，continue仅仅加速的是内层循环，而对外层循环没有任何效果，同样的，break也只会终结离它最近的：</p>
<pre><code class="language-c">for (int i = 1; i &lt; 4; ++i) {
    for (int j = 1; j &lt; 4; ++j) {
        if(i == j) break;    //当i == j时终止循环
        printf(&quot;%d, %d\n&quot;, i, j);
    }
}
</code></pre>
<figure data-type="image" tabindex="27"><img src="https://s2.loli.net/2022/06/17/6TaNChfX9tI351r.jpg" alt="image-20220613102347086" loading="lazy"></figure>
<h3 id="循环语句-while">循环语句 - while</h3>
<p>前面我们介绍了for循环语句，我们接着来看第二种while循环，for循环要求我们填写三个表达式，而while相当于是一个简化版本，它只需要我们填写循环的维持条件即可，比如：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    while (1) {   //每次循环开始之前都会判断括号内的内容是否为真，如果是就继续循环
        printf(&quot;Hello World!\n&quot;);   //这里会无限循环
    }
}
</code></pre>
<p>相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当<code>i</code>大于10时需要结束循环，但是<code>i</code>在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int i = 100;   //比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确
    while (i &gt; 0) {   //现在唯一知道的是循环条件，只要大于0那么就可以继续除
        printf(&quot;%d, &quot;, i);
        i /= 2;   //每次循环都除以2
    }
}
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://s2.loli.net/2022/06/17/xBE3NKZipVqJwjP.jpg" alt="image-20220612170911315" loading="lazy"></figure>
<p>while也支持使用break和continue来进行循环的控制：</p>
<pre><code class="language-c">int i = 100;
while (i &gt; 0) {
    if(i &lt; 30) break;
    printf(&quot;%d, &quot;, i);
    i /= 2;
}
</code></pre>
<figure data-type="image" tabindex="29"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h36er98fx8j213002u0sy.jpg" alt="image-20220613102935994" loading="lazy"></figure>
<p>我们可以反转循环判断的位置，可以先执行循环内容，然后再做循环条件判断，这里要用到<code>do-while</code>语句：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    do {  //无论满不满足循环条件，先执行循环体里面的内容
        printf(&quot;Hello World!&quot;);
    } while (0);   //再做判断，如果判断成功，开启下一轮循环，否则结束
}
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://s2.loli.net/2022/06/17/clJF7jrBqWAtbZ4.jpg" alt="image-20220613103504978" loading="lazy"></figure>
<h3 id="实战寻找水仙花数">实战：寻找水仙花数</h3>
<blockquote>
<p>“水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指**一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身。**例如：1^3 + 5^3+ 3^3 = 153。”</p>
</blockquote>
<p>现在请你设计一个C语言程序，打印出所有1000以内的水仙花数。</p>
<h3 id="实战打印九九乘法表">实战：打印九九乘法表</h3>
<figure data-type="image" tabindex="31"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h36fd08zh4j21dk0bmq4j.jpg" alt="image-20220613105029975" loading="lazy"></figure>
<p>现在我们要做的是在我们的程序中，也打印出这样的一个乘法表出来，请你设计一个C语言程序来实现它。</p>
<figure data-type="image" tabindex="32"><img src="https://s2.loli.net/2022/06/17/BW7lvFXy4GRb1P5.jpg" alt="image-20220613105519595" loading="lazy"></figure>
<h3 id="实战斐波那契数列解法其一">实战：斐波那契数列解法其一</h3>
<blockquote>
<p>斐波那契数列（Fibonacci sequence），又称<a href="https://baike.baidu.com/item/%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2/115896">黄金分割</a>数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：**1、1、2、3、5、8、13、21、34、……*<em>在数学上，斐波那契数列以如下被以递推的方法定义：<em>F</em>(0)=0，<em>F</em>(1)=1, <em>F</em>(n)=<em>F</em>(n - 1)+<em>F</em>(n - 2)（<em>n</em> ≥ 2，<em>n</em> ∈ N</em>）在现代物理、准<a href="https://baike.baidu.com/item/%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84/10401467">晶体结构</a>、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从 1963 年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p>
</blockquote>
<p>斐波那契数列：1，1，2，3，5，8，13，21，34，55，89...，不难发现一个规律，实际上从第三个数开始，每个数字的值都是前两个数字的和，现在请你设计一个C语言程序，可以获取斐波那契数列上任意一位的数字，比如获取第5个数，那么就是5。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int target = 7, result;  //target是要获取的数，result是结果

    //请在这里实现算法

    printf(&quot;%d&quot;, result);
}
</code></pre>
<hr>
<h2 id="数组">数组</h2>
<p>现在我们有一个新的需求，我们需要存储2022年每个月都天数，那么此时，为了保存这12个月的天数，我们就得创建12个变量：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int january = 31, february = 28, march = 31 ...
}
</code></pre>
<p>这样是不是太累了点？万一我们想保存100个商品的售价，那岂不是得创建100个变量？这肯定不行啊。</p>
<h3 id="数组的创建和使用">数组的创建和使用</h3>
<p>为了解决这种问题，我们可以使用数组，什么是数组呢？简单来说，就是存放数据的一个组，所有的数据都统一存放在这一个组中，一个数组可以同时存放多个数据。比如现在我们想保存12个月的天数，那么我们只需要创建一个int类型的数组就可以了，它可以保存很多个int类型的数据，这些保存在数组中的数据，称为“元素”：</p>
<pre><code class="language-c">int arr[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};  //12个月的数据全部保存在了一起
</code></pre>
<p>可以看到，数组的定义方式也比较简单：</p>
<pre><code class="language-c">类型 数组名称[数组大小] = {数据1, 数据2...};  //后面的数据可以在一开始的时候不赋值，并且数组大小必须是整数
</code></pre>
<p>注意数组只能存放指定类型的数据，一旦确定是不能更改的，因为数组声明后，会在内存中开辟一块连续的区域，来存放这些数据，所以类型和长度必须在一开始就明确。</p>
<figure data-type="image" tabindex="33"><img src="https://s2.loli.net/2022/06/17/ESJ5WmydXrxfwsU.jpg" alt="image-20220613113423268" loading="lazy"></figure>
<p>创建数组的方式有很多种：</p>
<pre><code class="language-c">int a[10];   //直接声明int类型数组，容量为10

int b[10] = {1, 2, 4};   //声明后，可以赋值初始值，使用{}囊括，不一定需要让10个位置都有初始值，比如这里仅仅是为前三个设定了初始值，注意，跟变量一样，如果不设定初始值，数组内的数据并不一定都是0

int c[10] = {1, 2, [4] = 777, [9] = 666}; //我们也可以通过 [下标] = 的形式来指定某一位的初始值，注意下标是从0开始的，第一个元素就是第0个下标位置，比如这里数组容量为10，那么最多到9

int c[] = {1, 2, 3};  //也可以根据后面的赋值来决定数组长度
</code></pre>
<p>基本类型都可以声明数组：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char str[] = {'A', 'B', 'C'};   //多个字符
  
    char str2[] = &quot;ABC&quot;;  //实际上字符串就是多个字符的数组形式，有关字符串我们会在下一节进行讲解
}
</code></pre>
<p>那么数组定义好了，如何去使用它呢？比如我们现在需要打印12个月的天数：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int arr[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    for (int i = 0; i &lt; 12; ++i) {
        int days = arr[i];   //直接通过数组 名称[下标] 来访问对应的元素值，再次提醒，下标是从0开始的，不是1
        printf(&quot;2022年 %d 月的天数是：%d 天\n&quot;, (i + 1), days);
    }
}
</code></pre>
<figure data-type="image" tabindex="34"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h36h0hctkdj21b204w0t5.jpg" alt="image-20220613114739872" loading="lazy"></figure>
<p>当然我们也可以对数组中的值进行修改：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int arr[] = {666, 777, 888};
    arr[1] = 999;   //比如我们现在想要让第二个元素的值变成999
    printf(&quot;%d&quot;, arr[1]);   //打印一下看看是不是变成了999
}
</code></pre>
<figure data-type="image" tabindex="35"><img src="https://s2.loli.net/2022/06/17/Q4bnsaIyz7NXReF.jpg" alt="image-20220613114928435" loading="lazy"></figure>
<p>注意，和变量一样，如果只是创建数组但是不赋初始值的话，因为是在内存中随机申请的一块空间，有可能之前其他地方使用过，保存了一些数据，所以数组内部的元素值并不一定都是0：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int arr[10];
    for (int i = 0; i &lt; 10; ++i) {
        printf(&quot;%d, &quot;, arr[i]);
    }
}
</code></pre>
<figure data-type="image" tabindex="36"><img src="https://s2.loli.net/2022/06/17/63BLiUNexSjJgym.jpg" alt="image-20220613115108971" loading="lazy"></figure>
<p>不要尝试去访问超出数组长度位置的数据，虽然可以编译通过，但是会给警告，这些数据是毫无意义的：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int arr[] = {111, 222, 333};
    printf(&quot;%d&quot;, arr[3]);  //不能去访问超出数组长度的元素，很明显这里根本就没有第四个元素
}
</code></pre>
<h3 id="多维数组">多维数组</h3>
<p>数组不仅仅只可以有一个维度，我们可以创建二维甚至多维的数组，简单来说就是，存放数组的数组（套娃了属于是）：</p>
<pre><code class="language-c">int arr[][2] = {{20, 10}, {18, 9}};   //可以看到，数组里面存放的居然是数组
//存放的内层数组的长度是需要确定的，存放数组的数组和之前一样，可以根据后面的值决定
</code></pre>
<p>比如现在我们要存放2020-2022年每个月的天数，那么此时用一维数组肯定是不方便了，我们就可以使用二维数组来处理：</p>
<pre><code class="language-c">int arr[3][12] = {{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, //2020年是闰年，2月有29天
                  {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
                  {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}};
</code></pre>
<p>这样，我们就通过二维数组将这三年每个月的天数都保存下来了。</p>
<figure data-type="image" tabindex="37"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h36hpql8tpj211s05w3yp.jpg" alt="image-20220613121156024" loading="lazy"></figure>
<p>那么二维数组又该如何去访问呢？</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int arr[3][12] = {{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, //2020年是闰年，2月有29天
                      {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
                      {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}};
    printf(&quot;%d&quot;, arr[0][1]);   //比如现在我们想要获取2020年2月的天数，首先第一个是[0]表示存放的第一个数组，第二个[1]表示数组中的第二个元素
}
</code></pre>
<p>当然除了二维还可以上升到三维、四维：</p>
<pre><code class="language-c">int arr[2][2][2] = {{{1, 2}, {1, 2}}, {{1, 2}, {1, 2}}};
</code></pre>
<p>有关多维数组，暂时先介绍到这里。</p>
<h3 id="实战冒泡排序算法">实战：冒泡排序算法</h3>
<p>现在有一个int数组，但是数组内的数据是打乱的，现在请你通过C语言，实现将数组中的数据按<strong>从小到大</strong>的顺序进行排列：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int arr[10] = {3, 5, 7, 2, 9, 0, 6, 1, 8, 4};  //乱序的
    //请编写代码对以上数组进行排序
}
</code></pre>
<p>这里我们使用冒泡排序算法来实现，此算法的核心思想是：</p>
<ul>
<li>假设数组长度为N</li>
<li>进行N轮循环，每轮循环都选出一个最大的数放到后面。</li>
<li>每次循环中，从第一个数开始，让其与后面的数两两比较，如果更大，就交换位置，如果更小，就不动。</li>
</ul>
<p>动画演示：https://visualgo.net/zh/sorting?slide=2-2</p>
<h3 id="实战斐波那契数列解法其二">实战：斐波那契数列解法其二</h3>
<p>学习了数组，我们来看看如何利用数组来计算斐波那契数列，这里采用动态规划的思想。</p>
<blockquote>
<p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有<a href="https://baike.baidu.com/item/%E6%9C%80%E4%BC%98%E5%80%BC">最优值</a>的解。动态规划算法与<a href="https://baike.baidu.com/item/%E5%88%86%E6%B2%BB%E6%B3%95">分治法</a>类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从<a href="https://baike.baidu.com/item/%E8%BF%99%E4%BA%9B%E5%AD%90">这些子</a>问题的解得到原问题的解。</p>
</blockquote>
<p>我们可以在一开始创建一个数组，然后从最开始的条件不断向后推导，从斐波那契数列的规律我们可以得知：</p>
<ul>
<li><code>fib[i] = fib[i - 1] + fib[i - 2]</code>（这里<code>fib</code>代表斐波那契数列）</li>
</ul>
<p>得到这样的一个关系（递推方程）就好办了，我们要求解数列第<code>i</code>个位置上的数，只需要知道<code>i - 1</code>和<code>i - 2</code>的值即可，这样，一个大问题，就分成了两个小问题，比如现在我们要求解斐波那契数列的第5个元素：</p>
<ul>
<li><code>fib[4] = fib[3] + fib[2]</code>现在我们只需要知道<code>fib[3]</code>和<code>fib[2]</code>即可，那么我们接着来看：</li>
<li><code>fib[3] = fib[2] + fib[1]</code>以及<code>fib[2] = fib[1] + fib[0]</code></li>
<li>由于<code>fib[0]</code>和<code>fib[1]</code>我们已经明确知道是<code>1</code>了，那么现在问题其实已经有结果了，把这些小问题的结果组合起来不就能得到原来大问题的结果了吗？</li>
</ul>
<p>现在请你设计一个C语言程序，利用动态规划的思想解决斐波那契数列问题。</p>
<h3 id="实战打家劫舍">实战：打家劫舍</h3>
<p>我们继续通过一道简单的算法题来强化动态规划思想。</p>
<p><strong>来源：力扣（LeetCode）No.198 打家劫舍</strong>：https://leetcode.cn/problems/house-robber/</p>
<blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：[1,2,3,1]<br>
输出：4<br>
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>
偷窃到的最高金额 = 1 + 3 = 4 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：[2,7,9,3,1]<br>
输出：12<br>
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>
偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
</blockquote>
<figure data-type="image" tabindex="38"><img src="https://s2.loli.net/2022/06/17/WvZltqPwyUEhkJY.jpg" alt="image-20220613124415156" loading="lazy"></figure>
<p>这道题我们也可以很轻松地按照上面的动态规划思路来处理，首先我们可以将问题分为子问题，比如现在有<code>[2,7,9,3,1]</code>五个房屋，这个问题看起来比较复杂，我们不妨先将大问题先简化成小问题，我们来看看只有N个房屋的情况：</p>
<ul>
<li>假设现在只有<code>[2]</code>这一个房屋，那么很明显，我可以直接去偷一号房，得到2块钱，所以当有一个房子时最大能偷到2块钱。</li>
<li>假设现在有<code>[2, 7]</code>这两个房屋，那么很明显，我可以直接去偷二号房，得到7块钱，所以当有两个房子时最大能偷到7块钱。</li>
<li>假设现在只有<code>[2, 7, 9]</code>这三个房屋，我们就要来看看了，是先偷一号房再偷三号房好，还是只偷二号房好，根据前面的结论，如果我们偷了一号房，那么就可以继续偷三号房，并且得到的钱就是从一号房过来的钱+三号房的钱，也就是2+9块钱，但是如果只偷二号房的话，那么就只能得到7块钱，所以，三号房能够偷到的最大金额有以下关系（dp是我们求出的第i个房屋的最大偷钱数量，value表示房屋价值，max表示取括号中取最大的一个）：
<ul>
<li><code>dp[i] = max(dp[i - 1], dp[i - 2] + value[i])</code>  -&gt; <strong>递推方程已得到</strong></li>
</ul>
</li>
<li>这样就不难求出：<code>dp[2] = max(dp[1], dp[0] + value[i])</code> = <code>dp[2] = max(7, 2 + 9)</code> = <code>dp[2] = 11</code>，所以有三个房屋时最大的金额是11块钱。</li>
<li>所以，实际上我们只需要关心前面计算出来的盗窃最大值即可，而不需要关心前面到底是怎么在偷。</li>
<li>我们以同样的方式来计算四个房屋<code>[2, 7, 9, 3]</code>的情况：
<ul>
<li><code>dp[3] = max(dp[2], dp[1] + value[3])</code> = <code>dp[3] = max(11, 7 + 3)</code> = <code>dp[3] = 11</code></li>
</ul>
</li>
<li>所以，当有四个房屋时，我们依然采用先偷一后偷三的方案，不去偷四号，得到最大价值11块钱。</li>
</ul>
<p>好了，现在思路已经出来了，我们直接上算法吧，现在请你实现下面的C语言程序：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int arr[] = {2,7,9,3,1}, size = 5, result;

    //请补充程序

    printf(&quot;%d&quot;, result);
}
</code></pre>
<p>力扣提交，建议各位小伙伴学习了函数和指针之后再回来看看，这里暂时可以跳过。</p>
<figure data-type="image" tabindex="39"><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h36jb2k9ldj20yy06kq3h.jpg" alt="image-20220613130702396" loading="lazy"></figure>
<pre><code class="language-c">int max(int a, int b) {
    return a &gt; b ? a : b;
}

int rob(int* nums, int numsSize){
    if(numsSize == 0) return 0;
    if(numsSize == 1) return nums[0];
    if(numsSize == 2) return max(nums[1], nums[0]);

    int dp[numsSize];
    dp[0] = nums[0];
    dp[1] = max(nums[1], nums[0]);

    for (int i = 2; i &lt; numsSize; ++i) {
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
    }

    return dp[numsSize - 1];
}
</code></pre>
<hr>
<h2 id="字符串">字符串</h2>
<p>前面我们学习了数组，而对于字符类型的数组，比较特殊，它实际上可以作为一个字符串（String）表示，字符串就是一个或多个字符的序列，比如我们在一开始认识的<code>&quot;Hello World!&quot;</code>，像这样的多个字符形成的一连串数据，就是一个字符串，而<code>printf</code>函数接受的第一个参数也是字符串。</p>
<p>那么，我们就来认识一下字符串。</p>
<h3 id="字符串的创建和使用">字符串的创建和使用</h3>
<p>在C语言中并没有直接提供存储字符串的类型，我们熟知的能够存储字符的只有char类型，但是它只能存储单个字符，而一连串的字符想要通过变量进行保存，那么就只能依靠数组了，char类型的数组允许我们存放多个字符，这样的话就可以表示字符串了。</p>
<p>比如我们现在想要存储<code>Hello</code>这一连串字符：</p>
<pre><code class="language-c">char str[] = {'H', 'e', 'l', 'l', 'o', '\0'};  //直接保存单个字符，但是注意，无论内容是什么，字符串末尾必须添加一个‘\0’字符（ASCII码为0）表示结束。
printf(&quot;%s&quot;, str);   //用%s来作为一个字符串输出
</code></pre>
<p>不过这样写起来实在是太麻烦了，我们可以使用更加简便的写法：</p>
<pre><code class="language-c">char str[] = &quot;Hello&quot;;   //直接使用双引号将所有的内容囊括起来，并且也不需要补充\0（但是本质上是和上面一样的字符数组）
//也可以添加 const char str[] = &quot;Hello World!&quot;; 双引号囊括的字符串实际上就是一个const char数组类型的值
printf(&quot;%s&quot;, str);
</code></pre>
<p>这下终于明白了，原来我们一直在写的双引号，其实表示的就是一个字符串。</p>
<p>那么现在请各位小伙伴看看下面的写法有什么不同：</p>
<pre><code class="language-c">&quot;c&quot;
'c'
</code></pre>
<p>我们发现一个问题，char类型只能保存ASCII编码表中的字符，但是我们发现实际上中文也是可以正常打印的：</p>
<pre><code class="language-c">printf(&quot;你这瓜保熟吗&quot;);
</code></pre>
<figure data-type="image" tabindex="40"><img src="https://s2.loli.net/2022/06/17/jC9Vn4MbgOzt7LB.jpg" alt="image-20220616114344138" loading="lazy"></figure>
<p>这是什么情况？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文。这时，我们就需要扩展字符集了。</p>
<blockquote>
<p>我们可以使用两个甚至多个字节来表示一个中文字符，这样我们能够表示的数量就大大增加了，GB2132方案规定当连续出现两个大于127的字节时（注意不考虑符号位，此时相当于是第一个bit位一直为1了），表示这是一个中文字符（所以为什么常常有人说一个英文字符占一字节，一个中文字符占两个字节），这样我们就可以表示出超过7000种字符了，不仅仅是中文，甚至中文标点、数学符号等，都可以被正确的表示出来。</p>
<pre><code class="language-c">10000011 10000110   //这就是一个连续出现都大于127的字节（注意这里是不考虑符号位的）
</code></pre>
<p>不过这样能够表示的内容还是不太够，除了那些常见的汉字之外，还有很多的生僻字，比如龘、錕、釿、拷这类的汉字，后来干脆直接只要第一个字节大于127，就表示这是一个汉字的开始，无论下一个字节是什么内容（甚至原来的128个字符也被编到新的表中），这就是Windows至今一直在使用的默认GBK编码格式。</p>
<p>虽然这种编码方式能够很好的解决中文无法表示的问题，但是由于全球还有很多很多的国家以及很多很多种语言，所以我们的最终目标是能够创造一种可以表示全球所有字符的编码方式，整个世界都使用同一种编码格式，这样就可以同时表示全球的语言了。所以这时就出现了一个叫做ISO的（国际标准化组织）组织，来定义一套编码方案来解决所有国家的编码问题，这个新的编码方案就叫做Unicode，规定每个字符必须使用俩个字节，即用16个bit位来表示所有的字符（也就是说原来的那128个字符也要强行用两位来表示）</p>
<p>但是这样的话实际上是很浪费资源的，因为这样很多字符都不会用到两字节来保存，但是又得这样去表示，这就导致某些字符浪费了很多空间。所以最后就有了UTF-8编码格式，区分每个字符的开始是根据字符的高位字节来区分的，比如用一个字节表示的字符，第一个字节高位以“0”开头；用两个字节表示的字符，第一个字节的高位为以“110”开头，后面一个字节以“10开头”；用三个字节表示的字符，第一个字节以“1110”开头，后面俩字节以“10”开头；用四个字节表示的字符，第一个字节以“11110”开头，后面的三个字节以“10”开头：</p>
<table>
<thead>
<tr>
<th>Unicode符号范围（十六进制）</th>
<th>UTF-8编码方式(二进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000 0000 ~ 0000 007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0000 0080 ~ 0000 07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0000 0800 ~ 0000 FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0001 0000 ~ 0010 FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>所以如果我们的程序需要表示多种语言，最好采用UTF-8编码格式。</p>
</blockquote>
<p>简而言之，我们的中文实际上是依靠多个char来进行表示的。</p>
<figure data-type="image" tabindex="41"><img src="https://s2.loli.net/2022/06/17/yJjkVABhZCa5Dx2.jpg" alt="image-20220616134302528" loading="lazy"></figure>
<figure data-type="image" tabindex="42"><img src="https://s2.loli.net/2022/06/17/ckD2LWU7MlfSTtb.jpg" alt="image-20220616134330805" loading="lazy"></figure>
<p>这样，我们就了解了字符串的使用。</p>
<h3 id="scanf-gets-puts函数">scanf、gets、puts函数</h3>
<p>函数我们会在下一章详细介绍，不过这里还是要再提到一个比较重要的函数。</p>
<p>前面我们认识了<code>printf</code>函数，实际上这个函数就是用于打印字符串到控制台，我们只需要填入一个字符串和后续的参数即可。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    const char str[] = &quot;Hello World!&quot;;   //注意printf需要填写一个const char数组进去，也就是字符串
    printf(str);
}
</code></pre>
<p>现在我们知道该如何输出，那么输入该如何实现呢，比如我们现在希望将我们想要说的话告诉程序，让程序从控制台读取我们输入的内容，这时我们就需要使用到<code>scanf</code>函数了：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char str[10];
    scanf(&quot;%s&quot;, str);   //使用scanf函数来接受控制台输入，并将输入的结果按照格式，分配给后续的变量
  	//比如这里我们想要输入一个字符串，那么依然是使用%s（和输出是一样的占位符），后面跟上我们要赋值的数组（存放输入的内容）
    printf(&quot;输入的内容为：%s&quot;, str);
}
</code></pre>
<p>可以看到，成功接收到用户输入：</p>
<figure data-type="image" tabindex="43"><img src="https://s2.loli.net/2022/06/17/RoEjaFVL4P9fWil.jpg" alt="image-20220616141313060" loading="lazy"></figure>
<p>当然除了能够扫描成字符串之外，我们也可以直接扫描为一个数字：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a, b;
    scanf(&quot;%d&quot;, &amp;a);   //连续扫描两个int数字
    scanf(&quot;%d&quot;, &amp;b);   //注意，如果不是数组类型，那么这里在填写变量时一定要在前面添加一个&amp;符号（至于为什么，下一章在指针小节中会详细介绍）这里的&amp;不是做与运算，而是取地址操作。

    printf(&quot;a + b = %d&quot;, a + b);   //扫描成功后，我们来计算a + b的结果
}
</code></pre>
<p>除了使用<code>scanf</code>之外，我们也可以使用字符串专用的函数来接受字符串类型的输入和输出：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char str[10];
    gets(str);   //gets也是接收控制台输入，然后将结果丢给str数组中
    puts(str);   //puts其实就是直接打印字符串到控制台
}
</code></pre>
<p>当然也有专门用于字符输入输出的函数：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int c = getchar();
    putchar(c);
}
</code></pre>
<p>由于我们目前还没有学习函数，所以这里稍微提及一下即可。</p>
<h3 id="实战回文串判断">实战：回文串判断</h3>
<p>“回文串”是一个正读和反读都一样的字符串，请你实现一个C语言程序，判断用户输入的字符串（仅出现英文字符）是否为“回文”串。</p>
<blockquote>
<p>ABCBA    就是一个回文串，因为正读反读都是一样的</p>
<p>ABCA    就不是一个回文串，因为反着读不一样</p>
</blockquote>
<h3 id="实战字符串匹配kmp算法">实战：字符串匹配KMP算法</h3>
<p>现在有两个字符串：</p>
<blockquote>
<p>str1 = &quot;abcdabbc&quot;</p>
<p>str2 = &quot;cda&quot;</p>
</blockquote>
<p>现在请你设计一个C语言程序，判断第一个字符串中是否包含了第二个字符串，比如上面的例子中，很明显第一个字符串包含了第二个字符串。</p>
<ul>
<li>暴力解法</li>
<li>KMP算法</li>
</ul>
<p>我们着重来看一下KMP算法，实际上我们发现，暴力解法虽然很好理解，但是可能会做一些毫无意义的比较：</p>
<figure data-type="image" tabindex="44"><img src="https://s2.loli.net/2022/06/24/RgP7i1dYsxNGTnb.png" alt="image-20220624105606429" loading="lazy"></figure>
<p>当发生不匹配时，又会重新开始比较下一个：</p>
<figure data-type="image" tabindex="45"><img src="https://s2.loli.net/2022/06/24/NZ8sEG9Q2bCAMlv.png" alt="image-20220624105650078" loading="lazy"></figure>
<p>但是我们不难发现，因为不匹配的位置发生在第三个字符，而前面是<code>a,b</code>两个字符都匹配，显然完全没有必要再继续挨着去比较<code>a</code>和<code>b</code>了，因为很明显不可能匹配。</p>
<figure data-type="image" tabindex="46"><img src="https://s2.loli.net/2022/06/24/tB9KHhYXZN6g2bz.png" alt="image-20220624142802170" loading="lazy"></figure>
<p>实际上我们可以直接跳过<code>b</code>，因为我们一眼就能看出肯定不匹配，所以直接跳过从后面继续判断，能节省不少的时间。我相信如果让你通过自己的人脑去进行匹配，也是按照这样的方式去比较的吧？</p>
<p>不过关键点就在于怎么在程序中得知该不该跳过呢，又该跳过多少个字符不判断呢？所以我们在拿到子串的时候，就需要根据子串来计算一个叫做<code>next</code>的数组，与子串的长度相同，它存储了<strong>当不匹配发生在对应的位置上时，应该在哪一个位置开始继续比较。</strong></p>
<p>这里说一下怎么去求（计算机领域大佬总结出来的算法）：</p>
<blockquote>
<p>从第一位开始依次推导。</p>
<p>next数组的第一位一定是0。</p>
<p>从第二位开始（用<code>i</code>表示），将第<code>i-1</code>个字符（也就是前一个）与其对应的<code>next[i - 1] - 1</code>位上的字符进行比较。</p>
<p>如果相等，那么<code>next[i]</code>位置的值就是<code>next[i - 1] + 1</code></p>
<p>如果不相等，则继续向前计算一次<code>next[next[i-1] - 1] - 1</code>位置上的字符和第<code>i-1</code>个字符是否相同，直到找到相等的为止，并且这个位置对应的值加上<code>1</code>就是<code>next[i]</code>的值了，要是都已经到头了都没遇到相等的，那么<code>next[i]</code>直接等于<code>1</code>。</p>
</blockquote>
<p>比如：</p>
<figure data-type="image" tabindex="47"><img src="https://s2.loli.net/2022/06/24/cvFlTtLy2QhDbo6.png" alt="image-20220624113812730" loading="lazy"></figure>
<p>首先一二位明确是0和1，这里我们从第三位开始计算，根据我们前面的规则：</p>
<ol>
<li>首先判断<code>str[next[1] - 1] == str[1]</code>，显然不相等。</li>
<li>此时无法继续向前走了，<code>next[2]</code>直接等于<code>1</code>即可。</li>
</ol>
<figure data-type="image" tabindex="48"><img src="https://s2.loli.net/2022/06/24/iEmjYkhTdz8CqfV.png" alt="image-20220624114135711" loading="lazy"></figure>
<p>我们接着来看第四位：</p>
<ol>
<li>首先判断<code>str[next[2] - 1] == str[2]</code>，发现相等。</li>
<li>此时<code>next[2]</code>直接等于<code>next[2 - 1] + 1</code>即可。</li>
</ol>
<figure data-type="image" tabindex="49"><img src="https://s2.loli.net/2022/06/24/ZDPF5BMtqpiAO9f.png" alt="image-20220624114743673" loading="lazy"></figure>
<p>最后一位也是一样的判断方式：</p>
<ol>
<li>首先判断<code>str[next[3] - 1] == str[3]</code>，发现相等。</li>
<li>此时<code>next[3]</code>直接等于<code>next[3 - 1] + 1</code>即可。</li>
</ol>
<figure data-type="image" tabindex="50"><img src="https://s2.loli.net/2022/06/24/u21aR6hZVT3P7OA.png" alt="image-20220624115015885" loading="lazy"></figure>
<p>至此，next数组求解完毕，之后比较只需要多考虑一下next数组即可：</p>
<figure data-type="image" tabindex="51"><img src="https://s2.loli.net/2022/06/24/8jLzZVOmgQHUcwW.png" alt="image-20220624115417358" loading="lazy"></figure>
<p>当不匹配发生在第三位时，此时<code>next[2] = 1</code>， 所以我们将第一个元素移动到c的位置重新开始比较：</p>
<figure data-type="image" tabindex="52"><img src="https://s2.loli.net/2022/06/24/gAY6DCnV2FOKSlo.png" alt="image-20220624142642394" loading="lazy"></figure>
<p>发现不匹配，直接继续向后比较，重复上述操作，像这样这样跳着去比较就大大节省了时间。</p>
<p>OK，理论差不多结束了，上代码。</p>
<p>有关C语言的基础部分内容，我们就讲解到这里，从下一章开始，难度将会有一定的提升，所以请各位小伙伴务必将本章知识点梳理清楚，牢记心中。</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://muouren7.github.io/post/Docker容器技术/" class="post-title gt-a-link">
                    Docker容器技术
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">温故而知新</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://muouren7.github.io/atom.xml" target="_blank">RSS</a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

    </div>
</div>
</body>
</html>
