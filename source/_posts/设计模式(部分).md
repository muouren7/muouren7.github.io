---
title: 设计模式(部分)
tags: [设计模式]
---

## 开闭原则

对于一个类来说，我们如果想增加它的功能，无非就两种方式，要么修改这个类要么扩展这个类。而开闭原则就是指导我们在对一个类升级的时候如何在这两者之间取舍。

**概念定义**：程序对于扩展是开放的，对于修改是封闭的。

**解释**：鼓励我们对于已经有的且比较稳定的代码，尽量不要改动，而是创建子类通过重写父类的部分逻辑来实现新的行为。





## 单例模式

### 概念定义

确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。（全局唯一）

根据实例的的初始化时间分为饿汉式与懒汉式。

饿汉式：即在类加载的时候就进行实例化。(**线程安全**)

懒汉式：即不在类加载时候进行实例化，而是在第一次使用的时候进行实例化。（**存在线程风险**）

示例：饿汉式

```java
//饿汉式
class Singleton{
	private static Singleton singleton = new Singleton();

	private Singleton(){}
	public static Singleton getIntstance(){
		return singleton;
	}
}
public class Main {
	public static void main(String[] args) {
	   Singleton singleton = Singleton.getIntstance();
	   Singleton singleton2 = Singleton.getIntstance();
	   System.out.println(singleton==singleton2);   
	}
}
```

示例：懒汉式

```java
class Singleton{
	private static Singleton singleton;
	
	private Singleton(){}
	public synchronized static Singleton getIntstance(){
		if(singleton == null){
			singleton = new Singleton();
		}
        return singleton;
	}
}
```

加锁的目的是为了防止被多次实例化，那么为什么会出现多次实例化的情况呢，我们假设有A，B两个线程同时获取实例对象，而此时的实例对象还没有被实例化，那么A，B两个线程就会同时执行到**if判断**，也就会同时new两个Singleton对象。

**双重检查锁**：

前面我们可以看到，synchronized是加在整个方法上的，无论是第一次实例化对象还是后续对象的获取，都会进入到同步块中。但是我们真正需要同步的只有第一次实例化对象的时候，也就是说其实只有if语句里的内容才需要同步。

```java
class Singleton{
	private volatile static Singleton singleton;
	
	private Singleton(){}
	public static Singleton getIntstance(){
		if(singleton == null){
			synchronized (Singleton.class) {
				if(singleton == null){
					singleton = new Singleton();
				}
			}
		}
		return singleton;
	}
}
```

使用双重检查锁进行初始化的实例必须使用**volatile**关键字进行修饰。

原因：

singleton = new Singleton(); 语句的执行可以拆解为3步：

1：分配内存

2：初始化对象

3：指向刚分配的内存

由于cpu的优化，可能导致指令1，2，3的执行顺序进行重排序。

假设A线程执行了1，3 还没有执行 2，B线程来到了判断NULL，B线程就会直接返回还没有初始化的intstance。volatile关键字可避免重排序

**注意**：单例模式在以下情况会出现多个实例

1：分布式系统，会有多个jvm虚拟机，每个jvm虚拟机都有一个实例。

2：同一个jvm虚拟机中的多个类加载器同时加载这个类，产生了多个实例。

单例模式最佳实践是无状态的，一般以工具类的方式进行提供。

### 





## 简单工厂模式

### 概念定义

属于创建型模式，又叫做静态工厂方法，在简单工厂模式中，可以根据参数的不同而返回不同的实例对象。简单工厂模式专门定义了一个类来负责创建其他类的实例，被创建的实例通常具有相同的父类。

示例：

```java
//抽象产品类
abstract class Product{
    abstract void print();
}

class ProductA extends  Product{
    @Override
    void print() {
        System.out.println("产品A");
    }
}

class ProductB extends  Product{
    @Override
    void print() {
        System.out.println("产品B");
    }
}

//工厂类
class SimpleFactory{
    public static Product createP(String type){
        if(type.equals("A")){
            return new ProductA();
        }else{
            return new ProductB();
        }
    }
}
```

理解：根据传入不同的参数，返回不同类型的实例对象。

优点：实现对象的创建和使用分离。

缺点：如果要新增一个产品的话，就得修改工厂类的内部逻辑。如果产品特别多的话，这个逻辑就会非常复杂。

### JDK中的简单工厂模式

例如抽象类DateFormat，（get）

### 





## 工厂模式

在简单工程模式当中，最核心的工厂类需要指导产品的实例化具体细节，并且决定何时实例化哪一种产品类。而在工厂模式当中，之前的核心工厂变成了一个抽象接口，它负责给出工厂应该要实现的方法，但不负责产品的创建，而是将产品的创建交给子类去完成。

为什么要这么麻烦，又是抽象类，又是子类的，而不是去直接修改工厂类呢？ 原因也是因为开闭原则。

### 概念定义

定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。

示例：

```java
//抽象工厂
abstract class Factory{
    abstract Produce createP();
}

//抽象产品
abstract class Produce{
    abstract void print();
}

//具体的产品A
class ProduceA extends Produce{
    @Override
    void print() {
        System.out.println("产品A");
    }
}
//具体的产品B
class ProduceB extends Produce{
    @Override
    void print() {
        System.out.println("产品B");
    }
}

//具体的工厂A
class FacotryA extends Factory{
    @Override
    public Produce createP() {
        return new ProduceA();
    }
}
//具体的工厂B
class FacotryB extends Factory{
    @Override
    public Produce createP() {
        return new ProduceB();
    }
}

public class Main {
    public static void main(String[] args) {
        Produce p = new FacotryA().createP();
        p.print();
        Produce p1 = new FacotryB().createP();
        p1.print();
    }
}
```



### JDK中的工厂模式

Collection集合：

Collection接口就是我们刚才说的抽象工厂，Iterator是抽象产品接口，真正负责生产产品的其实是LinkedList和ArrayList这两个具体的工厂，而根据工厂的不同，生产不同的迭代器对象，LinkedList就负责生产ListItr迭代器对象，ArrayList就负责生产Itr迭代器对象。

![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304231419750.png)



## 模板模式

### 概念定义

定义一个操作中的算法的框架，而将一些步骤延迟到子类当中。使得子类可以不改变算法的结构即可重新定义该算法的某些特定步骤。

情景：

现在有一个新人，想学习做菜，于是去请教本地的一位名厨。老师傅就告诉新人，他是按照这些步骤进行做菜的，但是不同的菜具体的做法不同。由于是要做菜，所以必须按照这个模板来，但是具体的实现由新人自己负责。  	

![做菜](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304221703385.png)

示例：

```java
//做菜模板
abstract class  Cooking{
	protected abstract void step1();
	protected abstract void step2();
	public void cook(){
		System.out.println("开始做饭");
		this.step1();
		this.step2();
		System.out.println("做饭结束");
	}
}
//做菜具体实现
class CookFood extends Cooking{
	@Override
	protected void step1() {
		System.out.println("放入西红柿和鸡蛋");
	}
	@Override
	protected void step2() {
		System.out.println("少放盐多放味精");
	}
}

public class Test {
	public static void main(String[] args) {
		Cooking cooking = new CookFood();
		cooking.cook();
	}
}
```

![模板类图](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304221717703.png)

### 适应场景

一次性实现一个算法的不变的部分，将可变的行为留给子类实现

### JDK中的模板方法

我们在写代码的时候经常会用到Comparator比较器来对集合对象进行排序，我们一般会实现他的**compare**方法，之后就可以通过Collections.sort() 或者 Arrays.sort() 方法进行排序了。

再例如：Spring中的**JdbcTemplate**也使用了模板模式

示例：

```java
ArrayList<Integer> list = new ArrayList<>();
for(int i=0;i<10;i++){
    list.add(new Random().nextInt(50));
}

Collections.sort(list,new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o1-o2;
    }
});

list.forEach(e->{
    System.out.println(e);
});	
```

### 理解

由抽象类（父类）制定做某件事的**骨架**（模板）,抽象类只需要考虑做这件事有哪些步骤，不需要考虑步骤具体的内容是怎么样的，而流程中的步骤的具体**实施**交给子类完成，同样，子类也无需关心整件事的步骤有哪些，只需要关心当前手中的步骤的具体实现。



## 装饰器模式

### 概念定义

是指在不改变原有对象的基础之上，将功能附加到对象上，提供了比继承更有弹性的替代方案(扩展原有对象的功能)，属于结构型模式。装饰器模式的核心是功能扩展，使用装饰器模式可以透明且动态地扩展类的功能。

情景：

假设我们买了一个机器人，这个机器人可以唱，rap，但是不会跳和打篮球。那么我现在想让他有跳和打篮球的功能，于是我们联系到厂家，厂家说目前是第一代的产品，需要等到第二代产品升级的时候，才会在原有的设计上添加跳，打篮球的功能。但是如果我们是一个手工牛人，认为不用等待厂家制作第二代机器人，自己就可以对机器人进行升级，那么我们需要怎么做呢。我们直接给机器人装上了一个箱子，然后再箱子的外面加上一对胳膊和一双腿，这样子也拥有了同样的功能。就可以不需要等待厂家的重新设计研发，而是可以很灵活的扩展想要的功能。

![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304221734622.png)

这两种方式：

第一种称为类继承机制，就是继承一个现有的类，然后在子类里面进行扩展功能。

第二种称为关联机制，就是把一个类的对象嵌入到另一个类的对象当中，类似于把机器人嵌入到箱子里，给他套上一层壳子来扩展功能，那么这层壳子也叫装饰器，第二种方式也成为装饰器模式。

**区别：**

第一种方式是静态的，一定要写一个新的子类，在类层级进行扩展。

第二种方式是动态的，我们只要拿到一个对象就可以对其进行扩展，不需要修改原有的类逻辑。就增加功能而言，装饰模式比生成子类更为灵活。

示例：

```java
//机器人接口
interface Robot{
	void doSomething();
}
//第一代机器人
class FirstRobot implements Robot{
	@Override
	public void doSomething() {
		System.out.println("唱歌");
		System.out.println("rap");
	}
}
//装饰器
class RobotDecorator implements Robot{
	private Robot robot;
	public RobotDecorator(Robot robot){
		this.robot = robot;
	}
	@Override
	public void doSomething() {
		robot.doSomething();
	}
	public void doMorething(){
		robot.doSomething();
		System.out.println("跳舞");
		System.out.println("打篮球");
	}
}
public class Test {
	public static void main(String[] args) {
		new RobotDecorator(new FirstRobot()).doMorething();
	}
}
```

### JDK中的装饰模式

在刚才的例子中我们不难发现，使用的时候，new装饰器，把原先的对象放进去就行了，这种方式是否有些熟悉，我们在使用输入输出流的时候经常用到。没错，Java的IO流也使用了大量的装饰器模式，

![](https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304221828698.png)



## 代理模式

### 概念定义

为其他对象提供一种代理以控制对这个对象的访问。

情景：

由于一些众所周知的原因，大家知道在国内我们是无法直接访问到谷歌的，但是可以通过某些代理软件连接到谷歌。那么代理软件做了一件什么事情呢？首先呢这个软件有一个海外的服务器，这个服务器去访问到谷歌（充当代理人的角色），拿到想要的页面，然后再把页面发送到我们的设备上。我们虽然不能直接访问谷歌的服务器，但是可以访问这个代理人。

再比如开发当中，远程调用的时候接口在我们这边，但是实现类（即具体的逻辑部分）是在另一台服务器上，这个时候在本地可以有一个代理类，它用于建立网络的连接，远程调用另一个服务器的实现类，最后返回实现结果。

类图;

<img src="https://muouren7hexo-1305003515.cos.ap-chengdu.myqcloud.com/HexoPic/202304231824311.png" style="zoom:150%;" />



作用：

例如在调用真正的目标类之前可以先建立网络的连接，IO的连接，日志记录或者一些结果解析。

示例：

```java
/*
* 代理模式
* */
class ProxyPattern{}
//目标类代理类接口
interface Subject{
    void doWork();
}
//实际的目标类
class RealSubject implements Subject{
    @Override
    public void doWork() {
        System.out.println("Hello Proxy");
    }
}
//实际的代理类
class RealProxy implements Subject{
    private RealSubject realSubject;
    public RealProxy(){
        try{
            this.realSubject = (RealSubject) this.getClass().getClassLoader().loadClass("Demo.RealSubject").newInstance();
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    public void connect(){
        System.out.println("建立连接");
    }
    public void log(){
        System.out.println("记录日志");
    }
    @Override
    public void doWork() {
        connect();
        realSubject.doWork();
        log();
    }
}

public class Main {
    public static void main(String[] args) {
        new RealProxy().doWork();
    }
}
```

代理模式与装饰器模式的区别：

代理模式关注的是：你必须通过我们代理类去访问目标对象，代理对象就是控制目标对象的访问的。

装饰器模式：更侧重的是动态的给一些对象添加原本没有的功能。





